file C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS

file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\uLCD-43PT.fnc

000001  000001  #platform "uLCD-43PT"
000002  000001  #platform "uLCD-43PT"
000003  000008  */
000004  000009      #constant uLCD_43PT_GFX2
000005  000009      #constant uLCD_43PT_GFX2
000006  000010        
000007  000011      #IFNOT EXISTS PICASO_FUNCTIONS
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\PicasoFunctions.fnc

000008  000012          #inherit "PicasoFunctions.fnc"        // inherit the generic functions
000009  000012          #inherit "PicasoFunctions.fnc"        // inherit the generic functions
000010  000001        
000011  000002  // Common inheritance for PicasoGFX2 platforms
000012  000003        
000013  000004  #constant PICASO_FUNCTIONS
000014  000004  #constant PICASO_FUNCTIONS
000015  000005        
000016  000006        
000017  000007  #CONST
000018  000017  #END
000019  000018        
000020  000019  #CONST
000021  000025  #END
000022  000026        
000023  000027        
000024  000028  #CONST
000025  000040  #END
000026  000041        
000027  000042        
000028  000043  #CONST
000029  000208  #END
000030  000209        
000031  000210        
000032  000211  // baud divisor rates for setbaud(n);
000033  000212  #CONST
000034  000234  #END
000035  000235        
000036  000236        
000037  000237        
000038  000238        
000039  000243  */
000040  000244        
000041  000245        
000042  000246  //==============================================//
000043  000247  // EVE bios functions                           //
000044  000248  //==============================================//
000045  000249                                                  //
000046  000250  func serin(), 1;                // read a byte from COM0
000047  000251  // Syntax: serin();
000048  000252  // Usage : char := serin();
000049  000253  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
000050  000254  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000051  000255  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000052  000256  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000053  000257  //     : Returns: -1 if no character is available
000054  000258  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
000055  000259  //     : Returns: positive value 0 to 255 for a valid character received
000056  000260        
000057  000261  func putch("char"), 0;                // write single char to current output device
000058  000262  // Syntax: putch("char");
000059  000263  // Usage : putch("A");
000060  000264  // Notes : Transmits a single byte from the Serial Port COM0. The transmission format is:
000061  000265  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000062  000266  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000063  000267  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000064  000268  //     : The arguments can be a variable, array element, expression or constant
000065  000269        
000066  000270  func serout("char"), 0;                // write a byte to COM0
000067  000271  // Syntax: serout1("char");
000068  000272  // Usage : serout1(ch);
000069  000273  // Notes : send character to COM1
000070  000274        
000071  000275  func setbaud("baudnum"), 0;            // set baud rate of COM0
000072  000276  // Syntax: setbaud(baud_number);
000073  000277  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
000074  000278  // *Notes : argument specifies the baud rate using pre-defined constant.
000075  000279  //       : The pre-defined constant is a value of 0-19 , and internally
000076  000280  //       : this is used as a table pointer to get the baud rate divisor
000077  000281  //       : value for one of the 20 selected baud rates, control is then
000078  000282  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
000079  000283  //       : The pre-defined constants equate to a value of 0-19.
000080  000284  //       : If a value other than 0-19 is used, a run time error (eror 25)
000081  000285  //       : will occur.
000082  000286        
000083  000287  func to("device"), 1;                // output device redirection
000084  000288  // Syntax: to(outstream);
000085  000289  // Usage : to(APPEND); putstr("TWO ");
000086  000290  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000087  000291  //     :
000088  000292  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000089  000293  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000090  000294  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000091  000295  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000092  000296  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000093  000297  //     : completed its action. The APPEND argument is used to send the printed output to the same
000094  000298  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000095  000299  //     : sequential data to a media stream.
000096  000300  //     :
000097  000301  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000098  000302  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000099  000303  //     :                            appended to user memory if previous redirection was to an array.
000100  000304  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000101  000305  //     : TEXT           0xFF08      Output is directed to the screen (default).
000102  000306  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000103  000307  //     : I2C            0xF820      Output is directed to the I2C port.
000104  000308  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000105  000309        
000106  000310        
000107  000311  func pause("milliseconds"), 0;            // blocking delay
000108  000312  // Syntax: pause(milliseconds);
000109  000313  // Usage : pause(1000);                //pause for 1 second
000110  000314  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000111  000315        
000112  000316  func putnum("arg1","arg2"), 1;            // print number to current output device
000113  000317  // Syntax: putnum(format, value);
000114  000318  // Usage : var := putnum(HEX, val);
000115  000319  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000116  000320  //     : Format: A constant that specifies the number format
000117  000321  //     : Value : The number to be printed
000118  000322  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000119  000323  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000120  000324  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000121  000325  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000122  000326  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000123  000327  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000124  000328  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000125  000329  //     :                                     BIN6     BIN6Z     BIN6ZB
000126  000330  //     :                                     BIN7     BIN7Z     BIN7ZB
000127  000331  //     :                                     BIN8     BIN8Z     BIN8ZB
000128  000332  //     :                                     BIN9     BIN9Z     BIN9ZB
000129  000333  //     :                                     BIN10     BIN10Z     BIN10ZB
000130  000334  //     :                                     BIN11     BIN11Z     BIN11ZB
000131  000335  //     :                                     BIN12     BIN12Z     BIN12ZB
000132  000336  //     :                                     BIN13     BIN13Z     BIN13ZB
000133  000337  //     :                                     BIN14     BIN14Z     BIN14ZB
000134  000338  //     :                                     BIN15     BIN15Z     BIN15ZB
000135  000339  //     :                                     BIN16     BIN16Z     BIN16ZB
000136  000340  //     : field: Returns the the default width of the numeric field (digit count), usually ignored.
000137  000341  //     : bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
000138  000342  //     : | | | | \___ ___/ \__ __/ \_____ _____/
000139  000343  //     : | | | | V V V
000140  000344  //     : | | | | | | |
000141  000345  //     : | | | | | |
000142  000346  //     : | | | | (nb 0 = 16) | |____BASE (usually 2,10 or 16)
000143  000347  //     : | | | | digit count |
000144  000348  //     : | | | | |___reserved (not used on GOLDELOX)
000145  000349  //     : | | | |
000146  000350  //     : | | | |
000147  000351  //     : | | | |
000148  000352  //     : | | | |
000149  000353  //     : | | | |
000150  000354  //     : | | | |______ 1 = leading zeros included
000151  000355  //     : | | | 0 = leading zeros suppressed
000152  000356  //     : | | |
000153  000357  //     : | | |
000154  000358  //     : | | |_______ 1 = leading zero blanking
000155  000359  //     : | |
000156  000360  //     : | |_____ sign bit (0 = signed, 1 = unsigned)
000157  000361  //     : |
000158  000362  //     : |______ 1 = space before unsigned number
000159  000363        
000160  000364        
000161  000365  func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only, not usable)
000162  000366        
000163  000367  func putstr("string"), 1;                       // print string to current output device
000164  000368  // Syntax: putstr(pointer);
000165  000369  // Usage : putstr("HELLO\n");
000166  000370  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000167  000371  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000168  000372  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000169  000373  //       : The output of putstr can be redirected to the communications port, the media, or memory
000170  000374  //       : using the to(...); function.
000171  000375  //       : A string constant is automatically terminated with a zero.
000172  000376  //       : A string in a data statement is not automatically terminated with a zero.
000173  000377  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000174  000378  //       : element packs 1 or 2 characters.
000175  000379        
000176  000380        
000177  000381  func strlen("varAddress"), 1;                   // return length of a var packed string in character units
000178  000382  // Syntax: strlen("varAddress);
000179  000383  // Usage : strlen("HELLO\n");
000180  000384  // Notes : gives the length of a string that is packed into regular var array
000181  000385  //       : Use str_Length(ptr)  for string pointer mode
000182  000386        
000183  000387        
000184  000388  //==============================================//
000185  000389  // Memory Access Function Prototypes            //
000186  000390  //==============================================//
000187  000391                                                  //
000188  000392  func peekW("address"), 1;                       // read a word from system memory
000189  000393  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000190  000394  // refer to address map of internal variables   //
000191  000395  //==============================================//
000192  000396  // Math Functions                               //
000193  000397  //==============================================//
000194  000398                                                  //
000195  000399  func ABS("value"), 1;                           // return a positive number
000196  000400  // Syntax: ABS(value);
000197  000401  // Usage : var := ABS(arg);
000198  000402  // Notes : Returns the absolute value of an argument
000199  000403        
000200  000404  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000201  000405  // Syntax: MIN(value1, value2);
000202  000406  // Usage : var := MIN(arg1, arg2);
000203  000407  // Notes : Returns the minimum of 2 arguments
000204  000408        
000205  000409  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000206  000410  // Syntax: MAX(value1, value2);
000207  000411  // Usage : var := MAX(arg1, arg2);
000208  000412  // Notes : Returns the maximum of 2 arguments
000209  000413        
000210  000414  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000211  000415  // Syntax: SWAP(&var1, &var2);
000212  000416  // Usage : SWAP(&var1, &var2);
000213  000417  // Notes : Swaps the contents of 2 variables or memory locations
000214  000418        
000215  000419  func SIN("angle"), 1;                           // return SIN of angle
000216  000420  // Syntax: SIN(angle);
000217  000421  // Usage : var := SIN(arg);
000218  000422  // Notes : Returns the sine in radians of an argument in degrees
000219  000423  //       : the returned value range is from 127 to -127. The real
000220  000424  //       : cosine values vary from 1.0 to -1.0 so appropriate
000221  000425  //       : scaling must be done in user code.
000222  000426        
000223  000427  func COS("angle"), 1;                           // return COS of angle
000224  000428  // Syntax: COS(angle);
000225  000429  // Usage : var := COS(arg);
000226  000430  // Notes : Returns the cosine in radians of an argument in degrees
000227  000431  //       : the returned value range is from 127 to -127. The real
000228  000432  //       : cosine values vary from 1.0 to -1.0 so appropriate
000229  000433  //       : scaling must be done in user code.
000230  000434        
000231  000435  func RAND(), 1;                                 // return a pseudo random number
000232  000436  // Syntax: RAND();
000233  000437  // Usage : var := RAND();
000234  000438  // Notes : Returns a random number between 0 and 0xFFFF.
000235  000439  //       : The random number generator must first be seeded
000236  000440  //       : by using the SEED(number) function.
000237  000441        
000238  000442  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000239  000443  // Syntax: SEED(number);
000240  000444  // Usage : SEED(arg);
000241  000445  // Notes : Seeds the random number generator.
000242  000446        
000243  000447  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000244  000448  // Syntax: OVF();
000245  000449  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000246  000450  //       : hiWord := OVF();
000247  000451  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000248  000452        
000249  000453  func SQRT("number"), 1;                         // return square root of a number
000250  000454  // Syntax: SQRT(number);
000251  000455  // Usage : SQRT(arg);
000252  000456  // Notes : Returns the integer square root of a number.
000253  000457  //------------------------------------------------------------------//
000254  000458  //          Text Related Function Prototypes
000255  000459  //------------------------------------------------------------------//
000256  000460        
000257  000461  func txt_MoveCursor("line", "column"), 0;
000258  000462  // Syntax: txt_SetCursor(line, column);
000259  000463  // Usage : txt_SetCursor(arg1, arg2);
000260  000464  // Notes : Moves the text Cursor to a new screen position set by
000261  000465  //       : line,column parameters.
000262  000466        
000263  000467  func txt_Set("mode", "value"), 0;
000264  000468  // Syntax: txt_Set(mode, value);
000265  000469  // Usage : txt_Set(arg1, arg2);
000266  000470  // Returns : Original value before the change
000267  000471  // Notes : Sets various text related parameters used by other functions
000268  000472  //       : This allows the features to be set programatically with a
000269  000473  //       : single function call.It is strongly recommended to use the
000270  000474  //       : pre-defined constants rather than the mode numbers.
000271  000475  //       : NB:- Although it is often required to be able to set text
000272  000476  //       : functions with a single function call for graphics engine
000273  000477  //       : related functions, there is a complete set of single parameter
000274  000478  //       : shortcut functions that have exactly the same function as
000275  000479  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000276  000480  //       :
000277  000481  //       : mode = TEXT_COLOUR (mode 0)
000278  000482  //       : txt_Set(TEXT_COLOUR, value);
000279  000483  //       : value = 0 to 0xFFFF, Black to White
000280  000484  //       : Sets the Text colour for the display
000281  000485  //       : Default = LIME.
000282  000486  //       :
000283  000487  //       : mode = TEXT_HIGHLIGHT (mode 1)
000284  000488  //       : txt_Set(TEXT_HIGHLIGHT, value);
000285  000489  //       : value = 0 to 0xFFFF, Black to White
000286  000490  //       : Sets the Text background colour for the display. Effective
000287  000491  //       : when text mode is Opaque.
000288  000492  //       : Default = BLACK.
000289  000493  //       :
000290  000494  //       : mode = FONT_ID (mode 2)
000291  000495  //       : txt_Set(FONT_ID, value);
000292  000496  //       : value = FONT1, FONT2 or FONT3 for internal fonts
000293  000497  //       : else this value is the name of a font included
000294  000498  //       : in a users program in a data statement.
000295  000499  //       : Default = FONT SIZE 3.
000296  000500  //       :
000297  000501  //       : mode = TEXT_WIDTH  (mode 3)
000298  000502  //       : txt_Set(TEXT_WIDTH, value);
000299  000503  //       : value = 1 to 16
000300  000504  //       : Sets the Text Width multiplier
000301  000505  //       : text will be printed magnified horizontally
000302  000506  //       : by this factor, Default = 1.
000303  000507  //       :
000304  000508  //       : mode = TEXT_HEIGHT  (mode 4)
000305  000509  //       : txt_Set(TEXT_HEIGHT, value);
000306  000510  //       : value = 1 to 16
000307  000511  //       : Sets the Text Height multiplier
000308  000512  //       : text will be printed magnified vertically
000309  000513  //       : by this factor, Default = 1.
000310  000514  //       :
000311  000515  //       : mode = TEXT_XGAP  (mode 5)
000312  000516  //       : txt_Set(TEXT_XGAP, value);
000313  000517  //       : value = 1 to 32
000314  000518  //       : Sets the horizontal gap between characters
000315  000519  //       : The gap is in pixel units, Default = 0
000316  000520  //       :
000317  000521  //       : mode = TEXT_YGAP  (mode 6)
000318  000522  //       : txt_Set(TEXT_YGAP, value);
000319  000523  //       : value = 1 to 32
000320  000524  //       : Sets the vertical gap below characters
000321  000525  //       : The gap is in pixel units, Default = 0
000322  000526  //       :
000323  000527  //       : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
000324  000528  //       : txt_Set(TEXT_PRINTDELAY, value);
000325  000529  //       : value = 0 to 255
000326  000530  //       : Sets the delay time (in ms) during character
000327  000531  //       : printing to give a 'teletype' like effect.
000328  000532  //       : Often used to attract attention to a string
000329  000533  //       : being printed which can often be missed if
000330  000534  //       : just suddenly appearing or changing.
000331  000535  //       : Default = 0 ms.
000332  000536  //       :
000333  000537  //       : mode = TEXT_OPACITY (mode 8)
000334  000538  //       : txt_Set(TEXT_OPACITY, value);
000335  000539  //       : value = TRANSPARENT (0) = Text Trasparent
000336  000540  //       : value = OPAQUE (1) = Text Opaque
000337  000541  //       : Sets the Opacity/Transparency of the text
000338  000542  //       : Default = 0 or TRANSPARENT
000339  000543  //       :
000340  000544  //       : mode = TEXT_BOLD (mode 9)
000341  000545  //       : txt_Set(TEXT_BOLD, value);
000342  000546  //       : value = dont care
000343  000547  //       : Sets Bold Text mode for the next string or char
000344  000548  //       : The feature automatically resets after printing
000345  000549  //       : using putstr or print has completed
000346  000550  //       :
000347  000551  //       : mode = TEXT_ITALIC (mode 10)
000348  000552  //       : txt_Set(TEXT_ITALIC, value);
000349  000553  //       : value = dont care
000350  000554  //       : Sets Italic Text mode for the next string or char
000351  000555  //       : The feature automatically resets after printing
000352  000556  //       : using putstr or print has completed
000353  000557        
000354  000558  //       : mode = TEXT_INVERSE (mode 11)
000355  000559  //       : txt_Set(TEXT_INVERSE, value);
000356  000560  //       : value = dont care
000357  000561  //       : Sets Inverse Text mode for the next string or char
000358  000562  //       : The feature automatically resets after printing
000359  000563  //       : using putstr or print has completed
000360  000564  //       :
000361  000565  //       : mode = TEXT_UNDERLINED (mode 12)
000362  000566  //       : txt_Set(TEXT_UNDERLINED, value);
000363  000567  //       : value = dont care
000364  000568  //       : Sets Underlined Text mode for the next string or char
000365  000569  //       : The feature automatically resets after printing
000366  000570  //       : using putstr or print has completed
000367  000571  //       :
000368  000572  //       : mode = TEXT_ATTRIBUTES (mode 13)
000369  000573  //       : txt_Set(TEXT_ATTRIBUTES, value);
000370  000574  //       : value = bits are defined as:
000371  000575  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000372  000576  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000373  000577  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000374  000578  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000375  000579  //       : Allows a combination of text attributes to be defined together
000376  000580  //       : by 'or'ing the bits together.
000377  000581  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000378  000582  //       : The feature automatically resets after printing
000379  000583  //       : using putstr or print has completed.
000380  000584  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000381  000585  //       :
000382  000586  //       : mode = TEXT_WRAP (mode 14)
000383  000587  //       : txt_Set(TEXT_WRAP , value);
000384  000588  //       : Sets the position where text wrap will occur
000385  000589  //       : The feature automatically resets when screen
000386  000590  //       : mode is changed. If the value is set to 0,
000387  000591  //       : text wrap is turned off.
000388  000592  //       : of the current screen. Default value is 0
000389  000593  // Notes : The value is in pixel units.
000390  000594  //       :
000391  000595        
000392  000596  //       : txt_Set mode 15 reserved for future use
000393  000597  //       :
000394  000598        
000395  000599        
000396  000600        
000397  000601  //=====================================================//
000398  000602  // Single parameter short-cuts                         //
000399  000603  // for the txt_Set functions                           //
000400  000604  // These functions return the existing value before    //
000401  000605  // the change is made.                                 //
000402  000606  //=====================================================//
000403  000607  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000404  000608  func txt_BGcolour("colour"), 1;             // 1  text background colour
000405  000609  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000406  000610  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000407  000611  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000408  000612  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000409  000613  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000410  000614  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000411  000615  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000412  000616  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000413  000617  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000414  000618  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000415  000619  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000416  000620  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000417  000621  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000418  000622  func _1F(), 0;                              // 15 text (reserved DO NOT REMOVE)
000419  000623        
000420  000624        
000421  000625  //------------------------------------------------------------------//
000422  000626  //                 Hardware Function Prototypes
000423  000627  //------------------------------------------------------------------//
000424  000628        
000425  000629  // I/O Pin reference:-
000426  000630  //
000427  000631  //    IO1_PIN           is pin 2 of J1
000428  000632  //    IO2_PIN           is pin 1 of J1
000429  000633  //    IO3_PIN           is pin 3 of J1
000430  000634  //    IO4_PIN           is pin 5 of J1 (also used for BUS_RD)
000431  000635  //    IO5_PIN           is pin 9 of J2 (also used for BUS_WR)
000432  000636  //    BUS_RD_PIN        is pin 5 of J1 (alias IO4_PIN)
000433  000637  //    BUS_WR_PIN        is pin 9 of J2 (alias IO5_PIN)
000434  000638  //    BUS_0             is pin 27 of J1
000435  000639  //    BUS_1             is pin 25 of J1
000436  000640  //    BUS_2             is pin 23 of J1
000437  000641  //    BUS_3             is pin 21 of J1
000438  000642  //    BUS_4             is pin 19 of J1
000439  000643  //    BUS_5             is pin 17 of J1
000440  000644  //    BUS_6             is pin 13 of J2
000441  000645  //    BUS_7             is pin 11 of J2
000442  000646  //    BACKLITE          is backlite control pin
000443  000647  //    AUDIO_ENABLE      is amplifier chip control pin
000444  000648        
000445  000649  func pin_Set("mode", "pin"), 1;            // set pin to required mode
000446  000650  // Syntax: pin_Set(mode, pin);
000447  000651  // Usage : pin_Set(arg1, arg2);
000448  000652  // Notes : Sets the appropriate pins to Inputs or Outputs
000449  000653  //       : returns true if the pin number is legal (usually ignored)
000450  000654  //       :
000451  000655  //       : mode = 0 : Set Pin to Output
000452  000656  //       : pin_Set(0, pin);
000453  000657  //       : pin_Set(OUTPUT, pin);
000454  000658  //       : pin = 1  : set IO1_PIN to output (pin 2 J1)
000455  000659  //       : pin = 2  : set IO2_PIN to output (pin 1 J1)
000456  000660  //       : pin = 3  : set IO3_PIN to output (pin 3 J1)
000457  000661  //       : pin = 4  : set IO4_PIN to output (pin 5 J1, also used for BUS_RD)
000458  000662  //       : pin = 5  : set IO5_PIN to output (pin 9 J2, also used for BUS_WR)
000459  000663  //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
000460  000664  //       : pin = 8  : set BUS_0   to output (pin 27 of J1)
000461  000665  //       : pin = 9  : set BUS_1   to output (pin 25 of J1)
000462  000666  //       : pin = 10 : set BUS_2   to output (pin 23 of J1)
000463  000667  //       : pin = 11 : set BUS_3   to output (pin 21 of J1)
000464  000668  //       : pin = 12 : set BUS_4   to output (pin 19 of J1)
000465  000669  //       : pin = 13 : set BUS_5   to output (pin 17 of J1)
000466  000670  //       : pin = 14 : set BUS_6   to output (pin 13 of J2)
000467  000671  //       : pin = 15 : set BUS_7   to output (pin 11 of J2)
000468  000672  //       : Sets the desired pin to be used as an Output.
000469  000673  //       :
000470  000674  //       : mode = 1 : Set Pin to Input
000471  000675  //       : pin_Set(1, pin);
000472  000676  //       : pin_Set(INPUT, pin);
000473  000677  //       : pin = 1  : set IO1_PIN to input (pin 2 J1)
000474  000678  //       : pin = 2  : set IO2_PIN to input (pin 1 J1)
000475  000679  //       : pin = 3  : set IO3_PIN to input (pin 3 J1)
000476  000680  //       : pin = 4  : set IO4_PIN to input (pin 5 J1, also used for BUS_RD)
000477  000681  //       : pin = 5  : set IO5_PIN to input (pin 9 J2, also used for BUS_WR)
000478  000682  //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
000479  000683  //       : pin = 8  : set BUS_0   to input (pin 27 of J1)
000480  000684  //       : pin = 9  : set BUS_1   to input (pin 25 of J1)
000481  000685  //       : pin = 10 : set BUS_2   to input (pin 23 of J1)
000482  000686  //       : pin = 11 : set BUS_3   to input (pin 21 of J1)
000483  000687  //       : pin = 12 : set BUS_4   to input (pin 19 of J1)
000484  000688  //       : pin = 13 : set BUS_5   to input (pin 17 of J1)
000485  000689  //       : pin = 14 : set BUS_6   to input (pin 13 of J2)
000486  000690  //       : pin = 15 : set BUS_7   to input (pin 11 of J2)
000487  000691  //       : Sets the desired pin to be used as an Input.
000488  000692        
000489  000693  func pin_HI("pin"), 1;                    // set pin to logic '1'
000490  000694  // Syntax: pin_HI(pin);
000491  000695  // Usage : pin_HI(arg);
000492  000696  // Notes : Outputs a logic "High" (3.3V) on the appropriate
000493  000697  //       : pin that was previously selected as an Output.
000494  000698  //       : returns true if the pin number is legal (usually ignored)
000495  000699  //       :
000496  000700  //       : pin = 1  : set IO1_PIN to "High" level (pin 2 of J1)
000497  000701  //       : pin = 2  : set IO2_PIN to "High" level (pin 1 of J1)
000498  000702  //       : pin = 3  : set IO3_PIN to "High" level (pin 3 of J1)
000499  000703  //       : pin = 4  : set IO4_PIN to "High" level (pin 5 of J1, also used for BUS_RD)
000500  000704  //       : pin = 5  : set IO5_PIN to "High" level (pin 9 of J2, also used for BUS_WR)
000501  000705  //       : pin = 6  : set DCENB pin to "High" level (BACKLITE ON)
000502  000706  //       : pin = 7  : set AUDIO_ENABL pin to "High" level (AMP OFF)
000503  000707  //       : pin = 8  : set BUS_0   to "High" level (pin 27 of J1)
000504  000708  //       : pin = 9  : set BUS_1   to "High" level (pin 25 of J1)
000505  000709  //       : pin = 10 : set BUS_2   to "High" level (pin 23 of J1)
000506  000710  //       : pin = 11 : set BUS_3   to "High" level (pin 21 of J1)
000507  000711  //       : pin = 12 : set BUS_4   to "High" level (pin 19 of J1)
000508  000712  //       : pin = 13 : set BUS_5   to "High" level (pin 17 of J1)
000509  000713  //       : pin = 14 : set BUS_6   to "High" level (pin 13 of J2)
000510  000714  //       : pin = 15 : set BUS_7   to "High" level (pin 11 of J2)
000511  000715        
000512  000716  func pin_LO("pin"), 1;                    // set pin to logic '0'
000513  000717  // Syntax: pin_LO(pin);
000514  000718  // Usage : pin_LO(arg);
000515  000719  // Notes : Outputs a logic "Low" (0V) on the appropriate
000516  000720  //       : pin that was previously selected as an Output.
000517  000721  //       : returns true if the pin number is legal (usually ignored)
000518  000722  //       :
000519  000723  //       : pin = 1 : set IO1_PIN to "Low" level (pin 2 of J1)
000520  000724  //       : pin = 2 : set IO2_PIN to "Low" level (pin 1 of J1)
000521  000725  //       : pin = 3 : set IO3_PIN to "Low" level (pin 3 of J1)
000522  000726  //       : pin = 4 : set IO4_PIN to "Low" level (pin 5 of J1, also used for BUS_RD)
000523  000727  //       : pin = 5 : set IO5_PIN to "Low" level (pin 9 of J2, also used for BUS_WR)
000524  000728  //       : pin = 6 : set DCENB pin to "Low" level (BACKLITE)
000525  000729  //       : pin = 7 : set AUDIO_ENABL pin to "Low" level (AMP ON)
000526  000730  //       : pin = 8  : set BUS_0  to "Low" level (pin 27 of J1)
000527  000731  //       : pin = 9  : set BUS_1  to "Low" level (pin 25 of J1)
000528  000732  //       : pin = 10 : set BUS_2  to "Low" level (pin 23 of J1)
000529  000733  //       : pin = 11 : set BUS_3  to "Low" level (pin 21 of J1)
000530  000734  //       : pin = 12 : set BUS_4  to "Low" level (pin 19 of J1)
000531  000735  //       : pin = 13 : set BUS_5  to "Low" level (pin 17 of J1)
000532  000736  //       : pin = 14 : set BUS_6  to "Low" level (pin 13 of J2)
000533  000737  //       : pin = 15 : set BUS_7  to "Low" level (pin 11 of J2)
000534  000738        
000535  000739  func pin_Read("pin"), 1;                // read pin, logic or analogue
000536  000740  // Syntax: pin_Read(pin);
000537  000741  // Usage : arg1 := pin_Read(arg2);
000538  000742  // Notes : Reads the logic state of the appropriate
000539  000743  //       : pin that was previously selected as an Input.
000540  000744  //       :
000541  000745  //       : pin = 1  : Read the state of IO1_PIN (pin 2 of J1)
000542  000746  //       : pin = 2  : Read the state of IO2_PIN (pin 1 of J1)
000543  000747  //       : pin = 3  : Read the state of IO3_PIN (pin 3 of J1)
000544  000748  //       : pin = 4  : Read the state of IO4_PIN (pin 5 of J1, also used for BUS_RD)
000545  000749  //       : pin = 5  : Read the state of IO5_PIN (pin 9 of J2, also used for BUS_WR)
000546  000750  //       : pin = 6  : Read the state of DCENB pin to "Low" level (BACKLITE)
000547  000751  //       : pin = 7  : Read the state of AUDIO_ENABL pin to "Low" level (AMP ON)
000548  000752  //       : pin = 8  : Read the state of BUS_0   (pin 27 of J1)
000549  000753  //       : pin = 9  : Read the state of BUS_1   (pin 25 of J1)
000550  000754  //       : pin = 10 : Read the state of BUS_2   (pin 23 of J1)
000551  000755  //       : pin = 11 : Read the state of BUS_3   (pin 21 of J1)
000552  000756  //       : pin = 12 : Read the state of BUS_4   (pin 19 of J1)
000553  000757  //       : pin = 13 : Read the state of BUS_5   (pin 17 of J1)
000554  000758  //       : pin = 14 : Read the state of BUS_6   (pin 13 of J2)
000555  000759  //       : pin = 15 : Read the state of BUS_7   (pin 11 of J2)
000556  000760  //       : Returns a 0 (logic low) or 1 (logic high).
000557  000761        
000558  000762        
000559  000763  //------------------------------------------------------------------//
000560  000764  //                 P1 module BUS I/O control
000561  000765  //------------------------------------------------------------------//
000562  000766        
000563  000767  func bus_In(), 1;
000564  000768  // Syntax: bus_In();
000565  000769  // Usage : arg1 := bus_In();
000566  000770  // Notes : Read the 8bit wide bus into the lower 8 bits of arg1.
000567  000771  //       : The upper 8 bits of arg1 are set to 0.
000568  000772  //       : the BUS_RD and BUS_WR pins are not affected.
000569  000773  //       :
000570  000774  //       : BUS_0 is pin 27 of J1
000571  000775  //       : BUS_1 is pin 25 of J1
000572  000776  //       : BUS_2 is pin 23 of J1
000573  000777  //       : BUS_3 is pin 21 of J1
000574  000778  //       : BUS_4 is pin 19 of J1
000575  000779  //       : BUS_5 is pin 17 of J1
000576  000780  //       : BUS_6 is pin 13 of J2
000577  000781  //       : BUS_7 is pin 11 of J2
000578  000782        
000579  000783  func bus_Out("var"), 0;
000580  000784  // Syntax: bus_Out(var);
000581  000785  // Usage : bus_Out(arg1);
000582  000786  // Notes : The lower 8 bits of arg1 are placed on the 8bit wide bus.
000583  000787  //       : The upper 8 bits of arg1 are ignored.
000584  000788  //       : the BUS_RD and BUS_WR pins are not affected.
000585  000789  //       : NB:- any BUS pins that are set to inputs are not affected.
000586  000790  //       :
000587  000791  //       : BUS_0 is pin 27 of J1
000588  000792  //       : BUS_1 is pin 25 of J1
000589  000793  //       : BUS_2 is pin 23 of J1
000590  000794  //       : BUS_3 is pin 21 of J1
000591  000795  //       : BUS_4 is pin 19 of J1
000592  000796  //       : BUS_5 is pin 17 of J1
000593  000797  //       : BUS_6 is pin 13 of J2
000594  000798  //       : BUS_7 is pin 11 of J2
000595  000799        
000596  000800  func bus_Set("var"), 0;
000597  000801  // Syntax: bus_Set(var);
000598  000802  // Usage : bus_Set(arg1);
000599  000803  // Notes : The lower 8 bits of arg1 are placed in the BUS direction register.
000600  000804  //       : a '1' sets a pin to be an input, a '0' sets a pin to be output.
000601  000805  //       : The upper 8 bits of arg1 are ignored.
000602  000806  //       : the BUS_RD and BUS_WR pins are not affected.
000603  000807  //       :
000604  000808  //       : BUS_0 is pin 27 of J1
000605  000809  //       : BUS_1 is pin 25 of J1
000606  000810  //       : BUS_2 is pin 23 of J1
000607  000811  //       : BUS_3 is pin 21 of J1
000608  000812  //       : BUS_4 is pin 19 of J1
000609  000813  //       : BUS_5 is pin 17 of J1
000610  000814  //       : BUS_6 is pin 13 of J2
000611  000815  //       : BUS_7 is pin 11 of J2
000612  000816        
000613  000817  func bus_Write("var"), 0;
000614  000818  // Syntax: bus_Write(var);
000615  000819  // Usage : bus_Write(arg1);
000616  000820  // Notes : The lower 8 bits of arg1 are placed on the BUS, then, after
000617  000821  //       : a settling delay of approx 50nsec, the BUS_WR pin is strobed
000618  000822  //       : LO for approx 50nsec then set back HI.
000619  000823  //       : The upper 8 bits of arg1 are ignored.
000620  000824  //       : NB:- the BUS_WR pin is automatically pre-set to an output to
000621  000825  //       : ensure BUS write integrity.
000622  000826  //       :
000623  000827  //       : BUS_0 is pin 27 of J1
000624  000828  //       : BUS_1 is pin 25 of J1
000625  000829  //       : BUS_2 is pin 23 of J1
000626  000830  //       : BUS_3 is pin 21 of J1
000627  000831  //       : BUS_4 is pin 19 of J1
000628  000832  //       : BUS_5 is pin 17 of J1
000629  000833  //       : BUS_6 is pin 13 of J2
000630  000834  //       : BUS_7 is pin 11 of J2
000631  000835        
000632  000836  func bus_Read(), 1;
000633  000837  // Syntax: bus_Read();
000634  000838  // Usage : arg1 := bus_Read();
000635  000839  // Notes : The BUS_RD pin set to LO, then, after a settling delay
000636  000840  //       : of approx 50nsec, the BUS is read into the lower 8 bits of arg
000637  000841  //       : (the upper 8 bits being set to 0)
000638  000842  //       : the BUS_RD pin is then set back to a HI level.
000639  000843  //       : NB:- the BUS_RD pin is automatically pre-set to an output to
000640  000844  //       : ensure BUS write integrity.
000641  000845  //       :
000642  000846  //       : BUS_0 is pin 27 of J1
000643  000847  //       : BUS_1 is pin 25 of J1
000644  000848  //       : BUS_2 is pin 23 of J1
000645  000849  //       : BUS_3 is pin 21 of J1
000646  000850  //       : BUS_4 is pin 19 of J1
000647  000851  //       : BUS_5 is pin 17 of J1
000648  000852  //       : BUS_6 is pin 13 of J2
000649  000853  //       : BUS_7 is pin 11 of J2
000650  000854        
000651  000855        
000652  000856  //------------------------------------------------------------------//
000653  000857  //   Graphics Functions
000654  000858  //------------------------------------------------------------------//
000655  000859  func gfx_Set("mode", "value"), 0;            // set various graphics functions
000656  000860  // Syntax: gfx_Set(mode, value);
000657  000861  // Usage : gfx_Set(arg1, arg2);
000658  000862  // Notes : Sets various graphics parameters used by other functions
000659  000863  //       : This allows the features to be set programatically with a
000660  000864  //       : single function call.It is strongly recommended to use the
000661  000865  //       : pre-defined constants rather than the mode numbers.
000662  000866  //       : NB:- Although it is often required to be able to set graphics
000663  000867  //       : functions with a single function call for graphics engine
000664  000868  //       : related functions, there is a complete set of single parameter
000665  000869  //       : shortcut functions that have exactly the same function as
000666  000870  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
000667  000871  //       :
000668  000872  //       : mode = PEN_SIZE (mode 16)
000669  000873  //       : gfx_Set(PEN_SIZE, value);
000670  000874  //       : value = SOLID (value 0) rectangle and circle objects are solid
000671  000875  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
000672  000876  //       : Sets the mode of the Pen used by most graphics objects
000673  000877  //       :
000674  000878  //       : mode = BACKGROUND_COLOUR (mode 17)
000675  000879  //       : gfx_Set(BACKGROUND_COLOUR, value);
000676  000880  //       : value = 0 to 0xFFFF, Black to White
000677  000881  //       : Sets the Background colour of the screen
000678  000882  //       :
000679  000883  //       : mode = OBJECT_COLOUR (mode 18)
000680  000884  //       : gfx_Set(OBJECT_COLOUR, value);
000681  000885  //       : value = 0 to 0xFFFF, Black to White
000682  000886  //       : Sets the Object colour used in various functions
000683  000887  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
000684  000888  //       :
000685  000889  //       : mode = CLIPPING (mode 19)
000686  000890  //       : gfx_Set(CLIPPING, value);
000687  000891  //       : value = OFF (value 0) Clipping disabled
000688  000892  //       : value = ON (value 1) Clipping enabled
000689  000893  //       : Enables/Disables the Clipping feature
000690  000894  //       :
000691  000895  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
000692  000896  //       : gfx_Set(TRANSPARENT_COLOUR, value);
000693  000897  //       : value = 0 to 0xFFFF Black to White
000694  000898  //       : Sets Bitmap, Image or Animation Transparency Colour.
000695  000899  //       : NB not implemented
000696  000900  //       :
000697  000901  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
000698  000902  //       : gfx_Set(5, value);
000699  000903  //       : value = OFF (value 0) Transparency disabled
000700  000904  //       : value = ON (value 1) Transparency enabled
000701  000905  //       : Enables/Disables the Transparency feature
000702  000906  //       : NB not implemented
000703  000907  //       :
000704  000908  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
000705  000909  //       : gfx_Set(FRAME_DELAY, value);
000706  000910  //       : value = 0 to 65535 ms
000707  000911  //       : Sets the Video/Animation clip inter-frame delay. This setting will
000708  000912  //       : over-ride the embedded frame delay of the clip. After the event,
000709  000913  //       : the setting will auto disable and if further inter-frame delays need
000710  000914  //       : overriding the setting must be re-issued.
000711  000915  //       :
000712  000916  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
000713  000917  //       : gfx_Set(SCREEN_MODE, value);
000714  000918  //       : value = LANDSCAPE   (value 0)
000715  000919  //       : value = LANDSCAPE_R (value 1)
000716  000920  //       : value = PORTRAIT    (value 2)
000717  000921  //       : value = PORTRAIT_R  (value 3)
000718  000922  //       :
000719  000923  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
000720  000924  //       : gfx_Set(OUTLINE_COLOUR, value);
000721  000925  //       : value = 1 to 0xFFFF, if 0, featre is OFF
000722  000926  //       : Sets the filled Rectangle or Circle objects outline colour
000723  000927  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
000724  000928  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
000725  000929  //       :
000726  000930  //       : Only supports variable contrast for uOLED Modules
000727  000931  //       : mode = CONTRAST (mode 25) : Contrast
000728  000932  //       : gfx_Set(CONTRAST, value);
000729  000933  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
000730  000934  //       : when contrast=0, display is placed in low power mode.
000731  000935  //       : This function should be called with contrast=0 when
000732  000936  //       : powering down the module.
000733  000937  //       :
000734  000938  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
000735  000939  //       : gfx_Set(LINE_PATTERN, value);
000736  000940  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
000737  000941  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
000738  000942  //       : a value of 0 turns the feature off
000739  000943  //       :
000740  000944  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
000741  000945  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
000742  000946  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
000743  000947  //       : NB not implemented, default is COLOUR16
000744  000948  //       :
000745  000949  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
000746  000950  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
000747  000951  //       : sets the button and slider objects bevel width
000748  000952  //       :
000749  000953  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
000750  000954  //       : gfx_Set(BEVEL_SHADOW , 5);
000751  000955  //       : sets the button and slider objects darken and lighten depth for the bevel colour
000752  000956  //       :
000753  000957  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
000754  000958  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
000755  000959  //       : sets the origin of drawn objects to a position other than 0,0
000756  000960  //       :
000757  000961  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
000758  000962  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
000759  000963  //       : sets the origin of drawn objects to a position other than 0,0
000760  000964        
000761  000965        
000762  000966  func gfx_Cls(), 0;                    // clear the screen
000763  000967  // Syntax: gfx_Cls();
000764  000968  // Usage : gfx_Cls();
000765  000969  // Notes : Clears the screen with current background colour
000766  000970        
000767  000971  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
000768  000972  // Syntax: gfx_MoveTo(x, y);
000769  000973  // Usage : gfx_MoveTo(arg1, arg2);
000770  000974  // Notes : Moves the origin to a new x,y position
000771  000975        
000772  000976  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
000773  000977  // Syntax: gfx_MoveRel(x, y);
000774  000978  // Usage : gfx_MoveRel(arg1, arg2);
000775  000979  // Notes : Moves the origin to a new x,y position
000776  000980  //       : relative to the current origing
000777  000981        
000778  000982  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
000779  000983  // Syntax: gfx_LineTo(x1, y1);
000780  000984  // Usage : gfx_LineTo(arg1, arg2);
000781  000985  // Notes : Draws a Line from the origin x,y to x1,y1.
000782  000986  //       : The new origin is then set to x1, y1. Line colour needs
000783  000987  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000784  000988        
000785  000989  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
000786  000990  // Syntax: gfx_LineRel(x1, y1);
000787  000991  // Usage : gfx_LineRel(arg1, arg2);
000788  000992  // Notes : Draws a Line from the origin x,y to x1,y1.
000789  000993  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
000790  000994  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
000791  000995        
000792  000996  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
000793  000997  // Syntax: gfx_Line(x1, x2, y2, colr);
000794  000998  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
000795  000999  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
000796  001000        
000797  001001  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
000798  001002  // Syntax: gfx_Line(x1, x2, y, colr);
000799  001003  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000800  001004  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
000801  001005        
000802  001006  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
000803  001007  // Syntax: gfx_Line(y1, y2, x, colr);
000804  001008  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000805  001009  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
000806  001010        
000807  001011  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
000808  001012  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
000809  001013  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000810  001014  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
000811  001015  //       : bottom corner (x2,y2) on the screen.
000812  001016        
000813  001017  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
000814  001018  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
000815  001019  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000816  001020  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
000817  001021  //       : bottom corner (x2,y2) on the screen.
000818  001022        
000819  001023  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
000820  001024  // Syntax: gfx_Circle(x, y, rad, colr);
000821  001025  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000822  001026  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
000823  001027        
000824  001028  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
000825  001029  // Syntax: gfx_Circle(x, y, rad, colr);
000826  001030  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000827  001031  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
000828  001032        
000829  001033  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
000830  001034  // Syntax: gfx_PutPixel(x, y, colr);
000831  001035  // Usage : gfx_PutPixel(arg1, arg2, arg3);
000832  001036  // Notes : Plots a coloured pixel on the screen at x,y location
000833  001037        
000834  001038  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
000835  001039  // Syntax: gfx_GetPixel(x, y);
000836  001040  // Usage : var := gfx_GetPixel(arg1, arg2);
000837  001041  // Notes : Reads and returns the colour value of a pixel at location x,y
000838  001042        
000839  001043  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
000840  001044  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
000841  001045  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000842  001046  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000843  001047  //       : Vertices must be specified in an anti-clockwise fashion
000844  001048        
000845  001049  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
000846  001050  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
000847  001051  // Usage : gfx_OrbitInit(&arg1, &arg2);
000848  001052  // Notes : Sets up the Orbit function parameters.
000849  001053  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
000850  001054  //       : variables that get updated after calling gfx_Orbit(,,) function.
000851  001055  //       : The coordiantaes are calculated relative to the origin
000852  001056  //       : obtained by using the gfx_MoveTo(x, y) function.
000853  001057        
000854  001058  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
000855  001059  // Syntax: gfx_Orbit(angle, distance);
000856  001060  // Usage : gfx_Orbit(arg1, arg2);
000857  001061  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
000858  001062  //       : only known parameters are the angle and the distance from the current origin.
000859  001063        
000860  001064  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
000861  001065  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
000862  001066  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
000863  001067  // Notes : This function is very similar to the Ploygon function
000864  001068  //       : with the exception of the 1st and the last vertices not joined.
000865  001069        
000866  001070  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
000867  001071  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
000868  001072  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
000869  001073  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000870  001074  //       : Vertices must be minimum of 3 and can be specified in any fashion
000871  001075        
000872  001076  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
000873  001077  // Syntax: gfx_Dot();
000874  001078  // Usage : gfx_Dot();
000875  001079  // Notes : Places a coloured dot at the origin
000876  001080        
000877  001081        
000878  001082  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
000879  001083  // Syntax: gfx_Bullet();
000880  001084  // Usage : gfx_Bullet();
000881  001085  // Notes : Places a coloured circle at the origin
000882  001086  //       : filled or unfilled state is controlled by PenSize
000883  001087        
000884  001088  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
000885  001089  // Syntax: gfx_IncX();
000886  001090  // Usage : var := gfx_IncX();
000887  001091  // Notes : Increments the x coordinate of the origin
000888  001092        
000889  001093  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
000890  001094  // Syntax: gfx_IncY();
000891  001095  // Usage : var := gfx_IncY();
000892  001096  // Notes : Increments the y coordinate of the origin
000893  001097        
000894  001098  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
000895  001099  // Syntax: gfx_BoxTo(x1, y1);
000896  001100  // Usage : gfx_BoxTo(arg1, arg2);
000897  001101  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
000898  001102  //       : The new origin is then set to x1,y1. Rectangle colour needs
000899  001103  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000900  001104  //       : and the PenSize setting determines if Box is solid or outline.
000901  001105        
000902  001106  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
000903  001107  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
000904  001108  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
000905  001109  // Notes : Specifies a clipping window region on the screen such that any objects
000906  001110  //       : and text placed onto the screen will be clipped and displayed only
000907  001111  //       : within that region. For the clipping window to take effect, "Clipping"
000908  001112  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
000909  001113        
000910  001114        
000911  001115  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
000912  001116  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
000913  001117  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
000914  001118  // *Notes:
000915  001119        
000916  001120  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
000917  001121  // Syntax: gfx_SetClipRegion();
000918  001122  // Usage : var := gfx_SetClipRegion();
000919  001123  // *Notes:
000920  001124        
000921  001125  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
000922  001126  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
000923  001127  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
000924  001128  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000925  001129  //       : with xradius = xrad and yradius = yrad.
000926  001130  //       : if PenSize = 0 Ellipse is Solid
000927  001131  //       : if PenSize = 1 Ellipse is Outline
000928  001132        
000929  001133        
000930  001134  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
000931  001135  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
000932  001136  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
000933  001137  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000934  001138  //       : with xradius = xrad and yradius = yrad.
000935  001139        
000936  001140  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 0;
000937  001141  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
000938  001142  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
000939  001143  // Notes : Draws a 3 dimensional Text Button at screen location defined by
000940  001144  //       : x,y arguments (top left corner). The size of the button depends on
000941  001145  //       : the font, width, height and length of the text.
000942  001146  //       : The button appearance will depend on the state parameter setting:
000943  001147  //       :         state = 0 : Button Pressed
000944  001148  //       :         state = 1 : Button Raised
000945  001149        
000946  001150  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
000947  001151  // Syntax: gfx_Panel("style", "x", "y", "width", "height", "colour"), 0;
000948  001152  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
000949  001153  // Notes : Draws a panel (groupbox) at screen location defined by
000950  001154  //       : x, y, width and height with colour "colour".
000951  001155  //       :         state = 0 : recessed
000952  001156  //       :         state = 1 : raised
000953  001157        
000954  001158  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
000955  001159  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
000956  001160  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
000957  001161  // Notes : Draws a 3 dimensional Slider Bar on the screen.
000958  001162  //       : Slider parameters are as follows:
000959  001163  //       :         mode = 0 : Slider recessed
000960  001164  //       :         mode = 1 : Slider raised
000961  001165  //       :         x1, y1 = top left corner
000962  001166  //       :         x2, y2 = bottom right corner
000963  001167  //       :         scale = n : sets the full scale range from 0 to n
000964  001168  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
000965  001169  //       : returns:-
000966  001170        
000967  001171        
000968  001172  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
000969  001173  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
000970  001174  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
000971  001175  // Notes : Copies an area of a screen from xs,ys of size given by width and height
000972  001176  //       : and pastes it to another location determined by xd, yd.
000973  001177        
000974  001178  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
000975  001179  // Syntax: gfx_RGBto565(red, green, blue);
000976  001180  // Usage : gfx_RGBto565(arg1, arg2, arg3);
000977  001181  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
000978  001182        
000979  001183  func gfx_332to565("COLOUR8BIT"), 1;
000980  001184  // Syntax: gfx_332to565(colour);
000981  001185  // Usage : gfx_332to565(arg);
000982  001186  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
000983  001187        
000984  001188  func gfx_Selection("index", "backcolor", "textcolor"), 0;
000985  001189  // Syntax: gfx_Selection("index", "backcolor", "textcolor"), 0;
000986  001190  // Usage : gfx_Selection(1, RED, YELLOW);
000987  001191  // Notes : Called prior to drawing a button, this function
000988  001192  //       : hilites the required text line on a multiline button.
000989  001193        
000990  001194  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
000991  001195  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
000992  001196  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000993  001197  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000994  001198  //       : Vertices must be specified in an anti-clockwise fashion
000995  001199        
000996  001200        
000997  001201  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
000998  001202  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
000999  001203  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
001000  001204  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
001001  001205  //       : Vertices must be minimum of 3 and can be specified in any fashion
001002  001206        
001003  001207        
001004  001208  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
001005  001209  // Syntax: gfx_Offset(x, y);
001006  001210  // Usage : gfx_Offset(arg1, arg2);
001007  001211  // Notes : Set the screen offset
001008  001212        
001009  001213        
001010  001214        
001011  001215  func gfx_Get("mode"), 1;
001012  001216  // Syntax: gfx_Get(mode);
001013  001217  // Usage : arg1 := gfx_Get(arg);
001014  001218  // Notes : Returns various parameters to caller
001015  001219  //       :
001016  001220  //       : mode = X_MAX (mode 0) : current orientations maximum X value
001017  001221  //       : var := gfx_Get(X_MAX);
001018  001222  //       : Returns the maximum horizontal value of the display
001019  001223  //       :
001020  001224  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
001021  001225  //       : var := gfx_Get(Y_MAX);
001022  001226  //       : Returns the maximum vertical value of the display
001023  001227  //       :
001024  001228  //       : mode = LEFT_POS (mode 2) : Left location of last Object
001025  001229  //       : var := gfx_Get(LEFT_POS);
001026  001230  //       : Returns the left location of the last drawn object
001027  001231  //       : such as a slider or button or an image/video
001028  001232  //       :
001029  001233  //       : mode = TOP_POS (mode 3) : Top location of Object
001030  001234  //       : var := gfx_Get(TOP_POS);
001031  001235  //       : Returns the top location of the last drawn object
001032  001236  //       : such as a slider or button or an image/video
001033  001237  //       :
001034  001238  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
001035  001239  //       : var := gfx_Get(RIGHT_POS);
001036  001240  //       : Returns the right location of the last drawn object
001037  001241  //       : such as a slider or button or an image/video
001038  001242  //       :
001039  001243  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
001040  001244  //       : var := gfx_Get(BOTTOM_POS );
001041  001245  //       : Returns the bottom location of the last drawn object
001042  001246  //       : such as a slider or button or an image/video
001043  001247  //       :
001044  001248        
001045  001249        
001046  001250  //==================================================//
001047  001251  // Single parameter short-cuts                      //
001048  001252  // for the gfx_Set functions                        //
001049  001253  // These functions return the existing value before //
001050  001254  // the change is made.                              //
001051  001255  //==================================================//
001052  001256  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
001053  001257  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
001054  001258  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
001055  001259  func gfx_Clipping("mode"), 0;                       // 3  graphics clipping ON/OFF
001056  001260  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
001057  001261  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
001058  001262  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
001059  001263  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
001060  001264  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
001061  001265  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
001062  001266  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
001063  001267  func gfx_ColourMode("mode"), 1;                     // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
001064  001268  func gfx_BevelWidth("mode"), 1;                     // 12 graphics button bevel width
001065  001269  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
001066  001270  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
001067  001271  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
001068  001272        
001069  001273        
001070  001274  //==================================================//
001071  001275  // uSD/FLASH Function Prototypes                    //
001072  001276  //==================================================//
001073  001277  func media_Video("x", "y"), 0;                      // display movie at position x y
001074  001278  // Syntax: media_Video(x, y);
001075  001279  // Usage : media_Video(arg1, arg2);
001076  001280  // Notes : Play a Video/Animation clip from the uSD card at screen location
001077  001281  //       : specified by x,y (top left corner). The location of the clip in the
001078  001282  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
001079  001283        
001080  001284  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
001081  001285  // Syntax: media_VideoFrame(Frame_number);
001082  001286  // Usage : arg1 := media_VideoFrame();
001083  001287  // Notes : After a pointer to a valid video has been set with media_SetSector,
001084  001288  //       : calling this function shows each fram sequentially, returning
001085  001289  //       : the number of frames remaining. The position of the image is
001086  001290  //     : at the current origin as set with gfx_MoveTo(...);
001087  001291        
001088  001292  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
001089  001293  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
001090  001294  // Usage : media_SetAdd(arg1, arg2);
001091  001295  // Notes : Set uSD internal Address pointer for bytewise access
001092  001296        
001093  001297  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
001094  001298  // Syntax: media_SetSector(SectHiWord, SectLoWord);
001095  001299  // Usage : media_SetSector(arg1, arg2);
001096  001300  // Notes : Set uSD internal Sector pointer for sector block access
001097  001301        
001098  001302  func media_RdSector("*destination"), 1;
001099  001303  // Syntax: media_RdSector(*destination);
001100  001304  // Usage : media_RdSector(rdblock);
001101  001305  // Notes : Reads and Returns 512 bytes (256 words) into a destination
001102  001306  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
001103  001307  //       : After the read the Sector pointer is automatically incremented by 1.
001104  001308  //       : Returns TRUE if uSD response was TRUE
001105  001309        
001106  001310  func media_WrSector("*source"), 1;
001107  001311  // Syntax: media_WrSector(*source);
001108  001312  // Usage : media_WrSector(wrblock);
001109  001313  // Notes : Writes 512 bytes (256 words) from a source memory block
001110  001314  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
001111  001315  //       : pointer is automatically incremented by 1.
001112  001316  //       : Returns TRUE if uSD response was TRUE
001113  001317        
001114  001318  func media_ReadByte(), 1;                // read a byte at the current stream position
001115  001319  // Syntax: media_RdByte();
001116  001320  // Usage : var := media_RdByte();
001117  001321  // Notes : Reads and Returns a single byte of data from the
001118  001322  //       : uSD card pointed to by the internal Address pointer.
001119  001323  //       : After the read the Address pointer is automatically
001120  001324  //       : incremented by 1.
001121  001325        
001122  001326  func media_ReadWord(), 1;                // read a word at the current stream position
001123  001327  // Syntax: media_ReadWord();
001124  001328  // Usage : var := media_ReadWord();
001125  001329  // *Notes : Reads and Returns a single word of data from the
001126  001330  //       : uSD card pointed to by the internal Address pointer.
001127  001331  //       : After the read the Address pointer is automatically
001128  001332  //       : incremented by 2.
001129  001333        
001130  001334  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
001131  001335  // Syntax: media_WriteByte(arg1);
001132  001336  // Usage : var := media_WriteByte(arg1);
001133  001337  // *Notes : Writes and Returns xxxxx
001134  001338  //       : After the write the Address pointer is automatically
001135  001339  //       : incremented by 1.
001136  001340        
001137  001341  func media_WriteWord("word"), 1;            // write a word to the current stream position
001138  001342  // Syntax: media_WriteWord(arg1);
001139  001343  // Usage : var := media_WriteWord(arg1);
001140  001344  // *Notes : Writes and Returns xxxxx
001141  001345  //       : After the write the Address pointer is automatically
001142  001346  //       : incremented by 2.
001143  001347        
001144  001348  func media_Image("x", "y"), 0;            // display image at position x y
001145  001349  // Syntax: media_Image(x, y);
001146  001350  // Usage : media_Image(arg1, arg2);
001147  001351  // Notes : Display an image from the uSD card at screen location
001148  001352  //       : specified by x,y (top left corner). The location of the
001149  001353  //       : Image in the uSD card must be specified by
001150  001354  //       : media_setSector(Image_Sector_Add) function.
001151  001355        
001152  001356  func media_Flush(), 1;                    // after writing to media, flush the sector and write
001153  001357  // Syntax: media_Flush();
001154  001358  // Usage : var := media_Flush();
001155  001359  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
001156  001360  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
001157  001361        
001158  001362  func media_Init(), 1;                    // initialize uSD card
001159  001363  // Usage : media_Init();
001160  001364  // Notes : Initialise uSD CARD
001161  001365  //       : Response: 0 = No Card
001162  001366  //       :           1 = Card Initialised
001163  001367        
001164  001368        
001165  001369  //==============================================//
001166  001370  // Communications Function Prototypes           //
001167  001371  //==============================================//
001168  001372  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
001169  001373  // Syntax: com_Init(buffer, bufsize, qualifier);
001170  001374  // Usage1: com_Init(mybuf, 20, 0);
001171  001375  // Usage2: com_Init(mybuf, 20, ':');
001172  001376  // Notes : initialize a serial capture buffer for the comms input
001173  001377  //       : The program must declare a var array as a circular buffer.
001174  001378  //       : Usage1 declares a circular buffer which will continually
001175  001379  //       : buffer characters.
001176  001380  //       : Usage2 must receive ':' before any characters will
001177  001381  //       : accumulate in the buffer.
001178  001382        
001179  001383  func com_Reset(), 0;                 // reset the comms receiver
001180  001384  // Syntax: com_Reset();
001181  001385  // Usage : com_Reset();
001182  001386  // Notes : reset comms to default polled mode
001183  001387        
001184  001388  func com_Count(), 1;                // return count of characters in receive buffer
001185  001389  // Syntax: com_Count();
001186  001390  // Usage : arg := com_Count();
001187  001391  // Notes : return count of buffered characters in buffer attachment
001188  001392        
001189  001393  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
001190  001394  // Syntax: com_Full();
001191  001395  // Usage : if (com_Full() ,,,, go read buffer;
001192  001396  // Notes : return true if buffer full (not necessarily an error if
001193  001397  //       : buffer is sized to a packet size)
001194  001398        
001195  001399  func com_Error(), 1;                // return comms errors comms error occurred
001196  001400  // Syntax: com_Error();
001197  001401  // Usage : if (com_Error() ) ...... take recovery action;
001198  001402  // Notes : return non zero if any errors low level comms errors occured
001199  001403  // returns :
001200  001404  // bit0 = Receiver Overflow Error
001201  001405  // bit1 = Receiver Framing Error
001202  001406  // bit2 = Transmit Buffer Overflow
001203  001407        
001204  001408  func com_Sync(), 1;                // returns TRUE if qualifier has been received
001205  001409  // Syntax: com_Sync();
001206  001410  // Usage : com_Sync();
001207  001411  // return true if sync character has been received in com_Init("...") mode
001208  001412        
001209  001413        
001210  001414  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001211  001415  // Syntax: com_TXbuffer("buf", "bufsize", "pin");
001212  001416  // Usage : com_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001213  001417  // Usage : com_TXbuffer(0, 0, 0);              // revert to non buffered service
001214  001418  // Notes : initialize a serial buffer for the COM0 output.
001215  001419  //       : The program must declare a var array as a circular buffer.
001216  001420  //       : When a TX buffer is declared for comms, the transmission
001217  001421  //       : of characters becomes non blocking. The only time
001218  001422  //       : blocking will occur is if the buffer has insufficient space
001219  001423  //       : to accept the next character, in which case the function
001220  001424  //       : will wait for buffer space to become available. If the
001221  001425  //       : TX buffer is no longer required, just set the buffer pointer
001222  001426  //       : to zero, the size in this case doesnt matter and is ignored.
001223  001427  //       : The function can resize or reallocated to another buffer at
001224  001428  //       : any time. The buffer is flushed before any changes are made.
001225  001429  //       : "pin" designates an IO pin to control a bi-directional 
001226  001430  //       : control device for half duplex mode. "pin" will go HI at the
001227  001431  //       : start of a transmission, and will return low after the final
001228  001432  //       : byte is transmitted. If not required, just set "pin" to zero.
001229  001433        
001230  001434        
001231  001435  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
001232  001436  // Syntax: com_TXcount();
001233  001437  // Usage : arg := com_Count();
001234  001438  // Notes : return count of characters remaining in COM0 transmit buffer
001235  001439  //       : that was previously allocated with com_TXbuffer(...);
001236  001440        
001237  001441        
001238  001442  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
001239  001443  // Syntax: com_TXemptyEvent(function);
001240  001444  // Usage : arg := com_TXemptyEvent();
001241  001445  // Notes : If a comms TX buffer that was previously allocated with
001242  001446  //       : com_TXbuffer(...);, this function can be used to set up
001243  001447  //       : a function to be called when the COM0 TX buffer is empty.
001244  001448  //       : This is useful for either reloading the TX buffer, setting
001245  001449  //       : or clearing a pin to change the direction of eg a RS485
001246  001450  //       : line driver, or any other form of traffic control.
001247  001451  //       : The event function must not have any parameters.
001248  001452  //       : To disable the event, simply call com_TXemptyEvent(0).
001249  001453  //       : com_TXbuffer(...); also resets any active event.
001250  001454  //       : com_TXemptyEvent returns any previous event function
001251  001455  //       : address, or zero if there was no previous function.
001252  001456        
001253  001457        
001254  001458  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
001255  001459  // Usage : arg := com_TXbufferHold(ON);  // hold the buffer while we fill it
001256  001460  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
001257  001461  // Notes : Expecting that a comms TX buffer that was previously allocated with
001258  001462  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
001259  001463  //       : the buffer being sent wile it is being loaded. Mormally, when
001260  001464  //       : using buffered comms, the transmit process will begin
001261  001465  //       : immediately. This is often undesirable for 2 reasons,
001262  001466  //       : 1] you may wish to build a packet then send it later
001263  001467  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001264  001468  //       : as the FIFO buffer is constantly trying to empty while
001265  001469  //       : you are busy tring to fill it.
001266  001470  // return -1 if function is called illegally when TX comms is not buffered.
001267  001471  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
001268  001472  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
001269  001473        
001270  001474        
001271  001475  //=============================================================//
001272  001476  // Auxilliary Communications Function Prototypes
001273  001477  //=============================================================//
001274  001478  func com1_Init("buffer", "bufsize", "qualifier"), 0;
001275  001479  // Syntax: com_Init(buffer, bufsize, qualifier);
001276  001480  // Usage1: com_Init(mybuf, 20, 0);
001277  001481  // Usage2: com_Init(mybuf, 20, ':');
001278  001482  // Notes : initialize a serial capture buffer for the comms input
001279  001483  //       : The program must declare a var array as a circular buffer.
001280  001484  //       : Usage1 declares a circular buffer which will continually
001281  001485  //       : buffer characters.
001282  001486  //       : Usage2 must receive ':' before any characters will
001283  001487  //       : accumulate in the buffer.
001284  001488        
001285  001489  func com1_Reset(), 0;
001286  001490  // Syntax: com_Reset();
001287  001491  // Usage : com_Reset();
001288  001492  // Notes : reset comms receiver to default polled mode
001289  001493        
001290  001494  func com1_Count(), 1;
001291  001495  // Syntax: com_Count();
001292  001496  // Usage : arg := com_Count();
001293  001497  // Notes : return count of characters in receive buffer
001294  001498        
001295  001499  func com1_Full(), 1;
001296  001500  // Syntax: com_Full();
001297  001501  // Usage : if (com_Full() ,,,, go read buffer;
001298  001502  // Notes : return true if receive buffer full
001299  001503        
001300  001504  func com1_Error(), 1;
001301  001505  // Syntax: com_Error();
001302  001506  // Usage : if (com_Error() ) ...... take recovery action;
001303  001507  // Notes : return non zero if any level comms errors occured
001304  001508  // returns :
001305  001509  // bit0 = Receiver Overflow Error
001306  001510  // bit1 = Receiver Framing Error
001307  001511  // bit2 = Transmit Buffer Overflow
001308  001512        
001309  001513  func com1_Sync(), 1;
001310  001514  // Syntax: com_Sync();
001311  001515  // Usage : com_Sync();
001312  001516  // Notes : return true if sync character has been received in com_Init("...") mode
001313  001517        
001314  001518        
001315  001519  func com1_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001316  001520  // Syntax: com1_TXbuffer("buf", "bufsize", "pin");
001317  001521  // Usage : com1_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001318  001522  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
001319  001523  // Notes : initialize a serial buffer for the COM1 output.
001320  001524  //       : The program must declare a var array as a circular buffer.
001321  001525  //       : When a TX buffer is declared for comms, the transmission
001322  001526  //       : of characters becomes non blocking. The only time
001323  001527  //       : blocking will occur is if the buffer has insufficient space
001324  001528  //       : to accept the next character, in which case the function
001325  001529  //       : will wait for buffer space to become available. If the
001326  001530  //       : TX buffer is no longer required, just set the buffer pointer
001327  001531  //       : to zero, the size in this case doesnt matter and is ignored.
001328  001532  //       : The function can resize or reallocated to another buffer at
001329  001533  //       : any time. The buffer is flushed before any changes are made.
001330  001534  //       : "pin" designates an IO pin to control a bi-directional 
001331  001535  //       : control device for half duplex mode. "pin" will go HI at the
001332  001536  //       : start of a transmission, and will return low after the final
001333  001537  //       : byte is transmitted. If not required, just set "pin" to zero.
001334  001538        
001335  001539        
001336  001540  func com1_TXcount(), 1;                // return count of characters in COM1 TX buffer
001337  001541  // Syntax: com1_TXcount();
001338  001542  // Usage : arg := com1_Count();
001339  001543  // Notes : return count of characters remaining in COM1 transmit buffer
001340  001544  //       : that was previously allocated with com1_TXbuffer(...);
001341  001545        
001342  001546        
001343  001547  func com1_TXemptyEvent("function"), 1;  // sets a function to be called when COM1 TX buffer empty
001344  001548  // Syntax: com1_TXemptyEvent(function);
001345  001549  // Usage : arg := com1_TXemptyEvent();
001346  001550  // Notes : If a comms TX buffer that was previously allocated with
001347  001551  //       : com1_TXbuffer(...);, this function can be used to set up
001348  001552  //       : a function to be called when the COM1 TX buffer is empty.
001349  001553  //       : This is useful for either reloading the TX buffer, setting
001350  001554  //       : or clearing a pin to change the direction of eg a RS485
001351  001555  //       : line driver, or any other form of traffic control.
001352  001556  //       : The event function must not have any parameters.
001353  001557  //       : To disable the event, simply call com1_TXemptyEvent(0).
001354  001558  //       : com1_TXbuffer(...); also resets any active event.
001355  001559  //       : com1_TXemptyEvent returns any previous event function
001356  001560  //       : address, or zero if there was no previous function.
001357  001561        
001358  001562        
001359  001563  func com1_TXbufferHold("state"), 1; // hold or release a com1_TXbuffer
001360  001564  // Usage : arg := com1_TXbufferHold(ON);  // hold the buffer while we fill it
001361  001565  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
001362  001566  // Notes : Expecting that a comms TX buffer that was previously allocated with
001363  001567  //       : com1_TXbuffer(...);, com1_TXbufferHold(ON) can be used to stop
001364  001568  //       : the buffer being sent wile it is being loaded. Mormally, when
001365  001569  //       : using buffered comms, the transmit process will begin
001366  001570  //       : immediately. This is often undesirable for 2 reasons,
001367  001571  //       : 1] you may wish to build a packet then send it later
001368  001572  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001369  001573  //       : as the FIFO buffer is constantly trying to empty while
001370  001574  //       : you are busy tring to fill it.
001371  001575  // return -1 if function is called illegally when TX comms is not buffered.
001372  001576  // return buffer count when called with argument of 1, eg com1_TXbufferHold(ON)
001373  001577  // return 0 when argument is zero, eg com1_TXbufferHold(OFF)
001374  001578        
001375  001579  func serin1(), 1;
001376  001580  // Syntax: serin1();
001377  001581  // Usage : char := serin1();
001378  001582  // Notes : return the next available character from COM1
001379  001583        
001380  001584  func serout1("char"), 0;
001381  001585  // Syntax: serout1("char");
001382  001586  // Usage : serout1(ch);
001383  001587  // Notes : send character to COM1
001384  001588        
001385  001589  func com_SetBaud("comport","baudrate/10"), 1;
001386  001590  // Syntax: com_SetBaud("comport","baudrate/10");
001387  001591  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
001388  001592  // Notes : sets to any viable baud rate from 160 to 655350
001389  001593  // return true if baud rate was acceptable
001390  001594        
001391  001595        
001392  001596        
001393  001597  //==============================================//
001394  001598  // Display Access                               //
001395  001599  //==============================================//
001396  001600  func disp_Init(), 0;                            // initialize display with required tables
001397  001601  // Syntax: disp_Init();
001398  001602  // Usage : disp_Init();
001399  001603  // Notes : Initialises or reinitialises the display.
001400  001604  //       : Normally used after restoration of peripheral power
001401  001605  //       : and after DeepSleep.
001402  001606        
001403  001607  func disp_SetReg("register", "data"), 0;
001404  001608  // Syntax: display_SetReg(register, data);
001405  001609  // Usage : display_SetReg(arg1, arg2);
001406  001610  // Notes : Sets uLCD specific display driver registers. Refer
001407  001611  //       : to appropriate display driver data sheet.
001408  001612        
001409  001613  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
001410  001614  // Syntax: disp_setGRAM(x1, y1, x2, y2);
001411  001615  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
001412  001616  // Notes : Prepares the GRAM area for user access.
001413  001617  //       : Data can now be written with disp_GRAM.
001414  001618  //       : GRAM will be set accordingly for the correct screen mode.
001415  001619  //       : the LO word of the 32 bit pixel count is returned. This is
001416  001620  //       : usually all that is needed unlse GRAM area exceeds 256^2
001417  001621  //       : A copy of the 32bit value can be found in
001418  001622  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
001419  001623        
001420  001624  func disp_WrGRAM("colour"), 0;
001421  001625  // Syntax: display_WrGRAM(colour);
001422  001626  // Usage : display_WrGRAM(arg);
001423  001627  // Notes : Data can be written to the GRAM consecutively using
001424  001628  //       : this function once the GRAM access window has been setup.
001425  001629        
001426  001630  func disp_WriteControl("value"), 0;             // write a control byte to the display
001427  001631  func disp_WriteWord("value"), 0;                // write a word to the display
001428  001632        
001429  001633        
001430  001634  func disp_ReadWord(), 1;                        // read a word from the display
001431  001635  // Syntax: disp_ReadWord();
001432  001636  // Usage : x:=disp_ReadWord();
001433  001637  // Notes : Read a word from the controller
001434  001638  // Eg:   : disp_WriteControl(0);         // select Ilitek ID register
001435  001639  //       : print(disp_ReadWord());        // print ID
001436  001640  //       : (Many displays are write only)
001437  001641        
001438  001642                                                  //
001439  001643  //==============================================//
001440  001644  // unadorned SPI functions                      //
001441  001645  //==============================================//
001442  001646  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
001443  001647  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
001444  001648  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
001445  001649  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
001446  001650                                                  //
001447  001651  //==============================================//
001448  001652  // flash device specific functions              //
001449  001653  //==============================================//
001450  001654  func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
001451  001655  func flash_ID(), 1;                             // read ID code from FLASH device
001452  001656  func flash_BulkErase(), 0;                      // erase the entire FLASH device
001453  001657  func flash_BlockErase("block"), 1;              // erase the required 64k flash block
001454  001658                                                  //
001455  001659                                                  //
001456  001660  //==============================================//
001457  001661  // string and character size function           //
001458  001662  //==============================================//
001459  001663  func charwidth("char"), 1;                      // return width of a character in pixel units
001460  001664  func charheight("char"), 1;                     // return height of a character in pixel units
001461  001665  func strwidth("pointer"), 1;                    // return width of a string in pixel units
001462  001666  func strheight(), 1;                            // return height of a string in pixel units
001463  001667        
001464  001668        
001465  001669  //------------------------------------------------------------------//
001466  001670  //        I2C Function Prototypes
001467  001671  //------------------------------------------------------------------//
001468  001672  func I2C_Open("speed"), 0;
001469  001673  // Syntax: I2C_Open(speed),
001470  001674  // Usage : I2C_Open(I2C_MED);
001471  001675  // Notes : configures the I2C module
001472  001676  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
001473  001677        
001474  001678  func I2C_Close(), 0;
001475  001679  // Syntax: I2C_Close();
001476  001680  // Usage : I2C_Close();
001477  001681  // Notes : disables the I2C1 module.
001478  001682        
001479  001683  func I2C_Start(), 1;
001480  001684  // Syntax: I2C_Start();
001481  001685  // Usage : I2C_Start();
001482  001686  // Notes : generates a Start condition.
001483  001687  //       : returns true if successful (usually ignored)
001484  001688        
001485  001689  func I2C_Stop(), 1;
001486  001690  // Syntax: I2C_Stop();
001487  001691  // Usage : I2C_Stop();
001488  001692  // Notes : generates a Stop condition.
001489  001693  //       : returns true if successful (usually ignored)
001490  001694        
001491  001695  func I2C_Restart(), 1;
001492  001696  // Syntax: I2C_Restart();
001493  001697  // Usage : I2C_Restart();
001494  001698  // Notes : generates a Restart condition.
001495  001699  //       : returns true if successful (usually ignored)
001496  001700        
001497  001701  func I2C_Read(), 1;
001498  001702  // Syntax: I2C_Read();
001499  001703  // Usage : ch := I2C_Read();
001500  001704  // Notes : reads a single byte from the I2C Bus.
001501  001705        
001502  001706  func I2C_Write("byte"), 1;
001503  001707  // Syntax: I2C_Write(byte);
001504  001708  // Usage : r := I2C_Write(ch);
001505  001709  // Notes : is used to write a byte to the I2C bus.
001506  001710  //       : Returns 0 if failed, 1 if no ack, 2 if ack
001507  001711        
001508  001712  func I2C_Ack(), 0;
001509  001713  // Syntax: I2C_Ack();
001510  001714  // Usage : I2C_Ack();
001511  001715  // Notes : generates the acknowledge condition.
001512  001716        
001513  001717  func I2C_Nack(), 0;
001514  001718  // Syntax: I2C_Nack();
001515  001719  // Usage : I2C_Nack();
001516  001720  // Notes : generates the negative acknowledge condition.
001517  001721        
001518  001722  func I2C_AckStatus(), 0;
001519  001723  // Syntax: I2C_AckStatus();
001520  001724  // Usage : r := I2C_AckStatus();
001521  001725  // Notes : returns the ACK status from the device.
001522  001726        
001523  001727  func I2C_AckPoll("control"), 1;
001524  001728  // Syntax: I2C_AckPoll();
001525  001729  // Usage : r := I2C_AckPoll(0xA0);
001526  001730  // Notes : waits for a device to return from ACK polling.
001527  001731        
001528  001732  func I2C_Idle(), 0;
001529  001733  // Syntax: I2C_Idle();
001530  001734  // Usage : I2C_Idle();
001531  001735  // Notes : waits until the I2C Bus is Inactive.
001532  001736        
001533  001737  func I2C_Gets("buffer", "size"), 1;
001534  001738  // Syntax: I2C_Gets("buffer", "size");
001535  001739  // Usage : r := I2C_Gets(mybuf, 16);
001536  001740  // Notes : only reads up to "size" characters into "buffer"
001537  001741  //       : Reads up to asciiz terminator including terminator
001538  001742        
001539  001743  func I2C_Getn("buffer", "size"), 1;
001540  001744  // Syntax: I2C_Gets("buffer", "size");
001541  001745  // Usage : r := I2C_Gets(mybuf, 16);
001542  001746  // Notes : reads "size" bytes into "buffer"
001543  001747  //       :
001544  001748        
001545  001749  func I2C_Puts("buffer"), 1;
001546  001750  // Syntax: I2C_Puts("buffer");
001547  001751  // Usage : r := I2C_Puts(mybuf);
001548  001752  // Notes : writes an asciiz string to the I2C device
001549  001753  //       : returns count of characters written
001550  001754        
001551  001755  func I2C_Putn("buffer", "count"), 1;
001552  001756  // Syntax: I2C_Putn("buffer","count");
001553  001757  // Usage : r := I2C_Puts(mybuf,10);
001554  001758  // Notes : writes up to "size" bytes to the I2C device
001555  001759  //       : returns number of bytes written
001556  001760        
001557  001761        
001558  001762  //------------------------------------------------------------------//
001559  001763  //        Image Control Function Prototypes
001560  001764  //------------------------------------------------------------------//
001561  001765  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
001562  001766  // Syntax: img_SetPosition(handle, index, xpos, ypos);
001563  001767  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
001564  001768  // Notes : set the position where the image will be displayed
001565  001769  //       : returns true if index was ok and function was successful.
001566  001770  //       : you may turn off an image so when img_Refresh is called,
001567  001771  //       : the image will not be shown
001568  001772        
001569  001773  func img_Enable("handle", "index"), 1;
001570  001774  // Syntax: img_Enable(handle, index);
001571  001775  // Usage : r := img_Enable(hImageList, imagenum);
001572  001776  // Notes : enable image in a image list
001573  001777  //       : returns true if index was ok and function was successful.
001574  001778  //       : this is the default state so when img_Refresh is called,
001575  001779  //       : all the images in the list will be shown
001576  001780  //       : if index is set to -1, all of the images are enabled
001577  001781        
001578  001782  func img_Disable("handle", "index"), 1;
001579  001783  // Syntax: img_Disable(handle, index);
001580  001784  // Usage : r := img_Disable(hImageList, imagenum);
001581  001785  // Notes : disable image in a image list
001582  001786  //       : returns true if index was ok and function was successful.
001583  001787  //       : you must turn off an image so when img_Refresh is called,
001584  001788  //       : the image will not be shown.
001585  001789  //       : if index is set to -1, all of the images are disabled
001586  001790        
001587  001791        
001588  001792  func img_Darken("handle", "index"), 1;
001589  001793  // Syntax: img_Darken(handle, index);
001590  001794  // Usage : r := img_Darken(hImageList, imagenum);
001591  001795  // Notes : darken image in a image list
001592  001796  //       : returns true if index was ok and function was successful.
001593  001797  //       : if index is set to -1, all of the images are darkened
001594  001798  //       : NB:- this feature will only work for the next refresh, then
001595  001799  //       : the image reverts back to normal when displayed again.
001596  001800        
001597  001801        
001598  001802  func img_Lighten("handle", "index"), 1;
001599  001803  // Syntax: img_Lighten(handle, index);
001600  001804  // Usage : r := img_Lighten(hImageList, imagenum);
001601  001805  // Notes : lighten image in a image list
001602  001806  //       : returns true if index was ok and function was successful.
001603  001807  //       : if index is set to -1, all of the images are lightened
001604  001808  //       : NB:- this feature will only work for the next refresh, then
001605  001809  //       : the image reverts back to normal when displayed again.
001606  001810        
001607  001811  func img_SetWord("handle", "index", "offset", "word"), 1;
001608  001812  // Syntax: img_SetWord(handle, index, offset, word);
001609  001813  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
001610  001814  // Notes : set specified word (0-7) in a image entry
001611  001815  //       : returns TRUE if successful, return value usually ignored.
001612  001816        
001613  001817  func img_GetWord("handle", "index", "offset"), 1;
001614  001818  // Syntax: myvar := img_GetWord("handle", "index", "offset");
001615  001819  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
001616  001820  // Notes : returns specified word (0-14) from an image entry
001617  001821  //       : refer to image control entry offsets.
001618  001822        
001619  001823  func img_Show("handle", "index"), 1;
001620  001824  // Syntax: img_Show(handle, index);
001621  001825  // Usage : display image entry (regardless of enable/disable)
001622  001826  //       : returns TRUE if successful, return value usually ignored.
001623  001827        
001624  001828  func img_SetAttributes("handle", "index","value"), 1;
001625  001829  // Syntax: img_SetAttributes("handle", "index","offset");
001626  001830  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
001627  001831  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
001628  001832  //       : of an image control entry. "value" refers to various bits in
001629  001833  //       : the image control entry (see image attribute flags).
001630  001834  //       : A '1' bit in the "value" field SETS the respective bit
001631  001835  //       : in the IMAGE_FLAGS field of the image control entry.
001632  001836  //       : returns TRUE if successful, return value usually ignored.
001633  001837        
001634  001838  func img_ClearAttributes("handle", "index","value"), 1;
001635  001839  // Syntax: img_ClearAttributes("handle", "index","offset");
001636  001840  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
001637  001841  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
001638  001842  //       : of an image control entry. "value" refers to various bits in
001639  001843  //       : the image control entry (see image attribute flags)
001640  001844  //       : a '1' bit in the "value" field CLEARS the respective bit
001641  001845  //       : in the IMAGE_FLAGS field of the image control entry.
001642  001846  //       : returns TRUE if successful, return value usually ignored.
001643  001847        
001644  001848  func img_Touched("handle", "index"), 1;
001645  001849  // Syntax: r := img_Touched(handle, index);
001646  001850  // Usage : img_Touched(hndl, 17);
001647  001851  //       : returns -1 if image not touched, or returns index
001648  001852  // Notes : if index is passed as -1, function tests all images,
001649  001853  //       : and returns -1 if image not touched, or returns index.
001650  001854        
001651  001855        
001652  001856        
001653  001857        
001654  001858  //------------------------------------------------------------------//
001655  001859  //        Timer Function Prototypes
001656  001860  //------------------------------------------------------------------//
001657  001861  func sys_T(), 1;
001658  001862  // Syntax: sys_T();
001659  001863  // Usage : t := sys_T();
001660  001864  // Notes : return the current value of the rolling system timer (1msec) LO word
001661  001865        
001662  001866  func sys_T_HI(), 1;
001663  001867  // Syntax: sys_T_HI();
001664  001868  // Usage : t := sys_T_HI();
001665  001869  // Notes : return the current value of the rolling system timer (1msec) HI word
001666  001870        
001667  001871  func sys_SetTimer("timernum","value"), 0;
001668  001872  // Syntax: sys_SetTimer("timernum", "value");
001669  001873  // Usage : sys_SetTimer(TIMER5, 10000);
001670  001874  // Notes : set a countdown on the selected timer, or 'top up' if required.
001671  001875  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001672  001876  //       : Maximum timeout period is 65.535 seconds
001673  001877  //       : A timer can be read with the sys_GetTimer("timernum") function
001674  001878        
001675  001879  func sys_GetTimer("timernum"), 1;
001676  001880  // Syntax: t := sys_GetTimer("timernum");
001677  001881  // Usage : t := sys_GetTimer(TIMER3);
001678  001882  // Notes : returns 0 if timer has expired, or the current countdown value.
001679  001883  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001680  001884  //       : Maximum timeout period is 65.535 seconds
001681  001885  //       : A timer must be set with the sys_SetTimer("timernum","value") function
001682  001886        
001683  001887  func sys_SetTimerEvent("timernum","function"), 1;
001684  001888  // Syntax: sys_SetTimerFunction("timernum", "function");
001685  001889  // Usage : sys_SetTimer(TIMER5, myfunc);
001686  001890  // Notes : set a function to be called for selected timer.
001687  001891  //       : When the timer reaches zero, the function is called.
001688  001892  //       : The called function must not have any parameters
001689  001893  //       : sys_SetTimerEvent returns any previous event function
001690  001894  //       : address, or zero if there was no previous function.
001691  001895        
001692  001896  func sys_EventQueue(), 1;
001693  001897  // Syntax: sys_EventQueue();
001694  001898  // Usage : tasks := sys_EventQueue();
001695  001899  // Notes : returns the max number of events that were pending
001696  001900  //       : in the timer queue since the last call to this function.
001697  001901  //       : This can be used to assess timer event overhead burden,
001698  001902  //       : especially after or during a sys_EventsPostpone action.
001699  001903        
001700  001904  func sys_EventsPostpone(), 0;
001701  001905  // Syntax: sys_EventPostpone();
001702  001906  // Usage : sys_EventPostpone();   // postpone the event queue
001703  001907  // Notes : postpone any events until the sys_EventResume function is executed
001704  001908  //       : The timer event queue will continue to queue events, but no action
001705  001909  //       : will take place untill a sys_EventResume function is encountered.
001706  001910  //       : The queue will continue to receive up to 32 events before discarding
001707  001911  //       : any further events. This function is required to allow a sequence of
001708  001912  //       : instructions or functions to occur that would otherwise be corrupted
001709  001913  //       : by an event occuring during the sequence of instructions or functions.
001710  001914  //       : A good example of this is when you set a position to print, if there
001711  001915  //       : was no way of locking the current sequence, an event may occur which
001712  001916  //       : does a similar thing, and a contention would occur - printing to
001713  001917  //       : the wrong position. This function should be used wisely, if any action
001714  001918  //       : that is required would take considerable time, it is better to disable
001715  001919  //       : any conflicting event functions with a bypass flag, then restart the
001716  001920  //       : conflicting event by re-issuing a timer value.
001717  001921        
001718  001922  func sys_EventsResume(), 0;
001719  001923  // Syntax: sys_EventsResume();
001720  001924  // Usage : sys_EventsResume();   // resume the event queue
001721  001925  // Notes : resume any postponed events. The queue will try to execute any timer
001722  001926  //       : events that were incurred during the postponed period.
001723  001927        
001724  001928        
001725  001929  func sys_Sleep("units"), 1;
001726  001930  // Syntax: t := sys_Sleep("units");
001727  001931  // Usage : t := sys_Sleep(10);
001728  001932  // Notes : sets the display into low power mode for a period of time.
001729  001933  //       : Touching the touch screen will also wake from sleep.
001730  001934  //       : Returns remaining sleep units.
001731  001935        
001732  001936  func iterator("offset"), 0;
001733  001937  // Syntax: t :=  iterator("offset");
001734  001938  // Usage : t :=  iterator(10);
001735  001939  // Notes : set the iterator size for ++/--
001736  001940  //       : The next postinc,postdec,preinc of predec will alter
001737  001941  //       : by the specified value.
001738  001942  //       : The offset will return to 1 after the next operation.
001739  001943        
001740  001944        
001741  001945        
001742  001946        
001743  001947  //------------------------------------------------------------------//
001744  001948  //         Touch Screen Function Prototypes
001745  001949  //------------------------------------------------------------------//
001746  001950        
001747  001951  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
001748  001952  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
001749  001953  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
001750  001954  // Notes : Specifies a new touch detect region on the screen
001751  001955  //       : such that only touch activity in that region will
001752  001956  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
001753  001957        
001754  001958  func touch_Set("mode"), 0;
001755  001959  // Syntax: touch_Set(mode);
001756  001960  // Usage : touch_Set(arg);
001757  001961  // Notes : Sets various Touch Screen related parameters
001758  001962  //       :
001759  001963  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
001760  001964  //       : touch_Set(TOUCH_ENABLE);
001761  001965  //       : Enables and initialises Touch Screen hardware
001762  001966  //       :
001763  001967  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
001764  001968  //       : touch_Set(TOUCH_DISABLE );
001765  001969  //       : Disables the Touch Screen
001766  001970  //       : Note: Touch Screen runs in the background and disabling
001767  001971  //       : it when not in use will free up extra resources
001768  001972  //       : such as 4DVM CPU cycles.
001769  001973  //       :
001770  001974  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
001771  001975  //       : touch_Set(TOUCH_REGIONDEFAULT);
001772  001976  //       : This will reset the current active region to default
001773  001977  //       : to the full screen without the application having to
001774  001978  //       : set a new active region for the full screen.
001775  001979  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
001776  001980  //       : that requre to be interfaced with an external pointing
001777  001981  //       : device, values that are poked into TOUCH_DRIVE will be
001778  001982  //       : read with the touch_Get() function)
001779  001983        
001780  001984        
001781  001985  func touch_Get("mode"), 1;
001782  001986  // Syntax: touch_Get(mode);
001783  001987  // Usage : arg1 := touch_Get(arg);
001784  001988  // Notes : Returns various Touch Screen parameters to caller
001785  001989  //       :
001786  001990  //       : mode = TOUCH_STATUS  (mode 0)
001787  001991  //       : var := touch_Get(TOUCH_STATUS);
001788  001992  //       : Returns the various states of the touch screen
001789  001993  //       : 0 = NOTOUCH
001790  001994  //       : 1 = TOUCH_PRESSED
001791  001995  //       : 2 = TOUCH_RELEASED
001792  001996  //       : 3 = TOUCH_MOVING
001793  001997  //       :
001794  001998  //       : mode = TOUCH_GETX   (mode 1)
001795  001999  //       : var := touch_Get(TOUCH_GETX);
001796  002000  //       : Returns the X coordinates of the touch
001797  002001  //       :
001798  002002  //       : mode = TOUCH_GETY   (mode 2)
001799  002003  //       : var := touch_Get(TOUCH_GETY);
001800  002004  //       : Returns the Y coordinates of the touch
001801  002005        
001802  002006  //------------------------------------------------------------------//
001803  002007  //        CTYPE Function Prototypes
001804  002008  //------------------------------------------------------------------//
001805  002009        
001806  002010  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
001807  002011  // Syntax: isdigit("char");
001808  002012  // Usage : Var := isdigit(ch);
001809  002013  // Notes : char specifies the ascii character for the test
001810  002014  //     : 0 : char is not an ascii digit.
001811  002015  //     : 1 : char is an ascii digit..
001812  002016  //     : Valid range is "0123456789"
001813  002017        
001814  002018  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
001815  002019  // Syntax: isxdigit("char");
001816  002020  // Usage : Var := isxdigit(ch);
001817  002021  // Notes : char specifies the ascii character for the test
001818  002022  //     : 0 : char is not an ascii hexadecimal digit.
001819  002023  //     : 1 : char is an ascii hexadecimal digit..
001820  002024  //     : Valid range is "0123456789ABCDEF"
001821  002025        
001822  002026  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
001823  002027  // Syntax: isupper("char");
001824  002028  // Usage : Var := isupper(ch);
001825  002029  // Notes : char specifies the ascii character for the test
001826  002030  //     : 0 : char is not an ascii upper-case letter.
001827  002031  //     : 1 : char is an ascii upper-case letter.
001828  002032  //     : Valid range is "ABCD....WXYZ"
001829  002033        
001830  002034  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
001831  002035  // Syntax: islower("char");
001832  002036  // Usage : Var := islower(ch);
001833  002037  // Notes : char specifies the ascii character for the test
001834  002038  //     : 0 : char is not an ascii lower-case letter.
001835  002039  //     : 1 : char is an ascii lower-case letter.
001836  002040  //     : Valid range is "abcd....wxyz"
001837  002041        
001838  002042  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
001839  002043  // Syntax: isalpha("char");
001840  002044  // Usage : Var := isalpha(ch);
001841  002045  // Notes : char specifies the ascii character for the test
001842  002046  //     : 0 : char is not an ascii lower or upper case letter.
001843  002047  //     : 1 : char is an ascii lower or upper case letter.
001844  002048  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
001845  002049        
001846  002050  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
001847  002051  // Syntax: isalnum("char");
001848  002052  // Usage : Var := isalnum(ch);
001849  002053  // Notes : char specifies the ascii character for the test
001850  002054  //     : 0 : char is not an ascii alphanumeric character.
001851  002055  //     : 1 : char is an ascii alphanumeric character.
001852  002056  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
001853  002057        
001854  002058  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
001855  002059  // Syntax: isprint("char");
001856  002060  // Usage : Var := isprint(ch);
001857  002061  // Notes : char specifies the ascii character for the test
001858  002062  //     : 0 : char is not a printable ascii character.
001859  002063  //     : 1 : char is a printable ascii character.
001860  002064  //     : Valid range is "0x20...0x7F"
001861  002065        
001862  002066  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
001863  002067  // Syntax: isspace("char");
001864  002068  // Usage : Var := isspace(ch);
001865  002069  // Notes : char specifies the ascii character for the test
001866  002070  //     : 0 : char is not a space type character.
001867  002071  //     : 1 : char is a space type character.
001868  002072  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
001869  002073        
001870  002074  //unformatted
001871  002075  func iswhite("char"), 1;    //
001872  002076  // Syntax: iswhite("char");
001873  002077  // Usage : Var := iswhite(ch);
001874  002078  // Notes : char specifies the ascii character for the test
001875  002079  //     : 0 : char is not a space or tab character.
001876  002080  //     : 1 : char is not a space or tab character.
001877  002081  //     : Valid range is space or tab
001878  002082        
001879  002083  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
001880  002084  // Syntax: toupper("char");
001881  002085  // Usage : Var := toupper(ch);
001882  002086  // Notes : char specifies the ascii character for the test
001883  002087  //     : "ABCD....XYZ" : if character is a lower case letter.
001884  002088  //     : char : if character is not a lower case letter.
001885  002089  //     : Valid range is "abcd....wxyz"
001886  002090        
001887  002091  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
001888  002092  // Syntax: tolower("char");
001889  002093  // Usage : Var := tolower(ch);
001890  002094  // Notes : char specifies the ascii character for the test
001891  002095  //     : "abcd....xyz" : if character is an upper case letter.
001892  002096  //     : char : if character is not an upper case letter.
001893  002097  //     : Valid range is "ABCD....WXYZ"
001894  002098        
001895  002099  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
001896  002100  // Syntax: LObyte(var);
001897  002101  // Usage : myVar := LObyte(myvar2);
001898  002102  // Notes : var specifies the user variable
001899  002103  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
001900  002104        
001901  002105  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
001902  002106  // Syntax: HIbyte(var);
001903  002107  // Usage : myVar := HIbyte(myvar2);
001904  002108  // Notes : var specifies the user variable
001905  002109  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
001906  002110        
001907  002111        
001908  002112  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
001909  002113  // Syntax: ByteSwap(var);
001910  002114  // Usage : myVar := ByteSwap(myvar2);
001911  002115  // Notes : var specifies the user variable
001912  002116  //     : Returns the endian swapped value of a 16 bit variable
001913  002117        
001914  002118        
001915  002119  //------------------------------------------------------------------//
001916  002120  //        Memory Allocation Function Prototypes
001917  002121  //------------------------------------------------------------------//
001918  002122        
001919  002123  func mem_Alloc("size"), 1;
001920  002124  // Syntax: mem_Alloc(bytesize);
001921  002125  // Usage : myvar := mem_Alloc(100);
001922  002126  // Notes : Allocate a block of memory to pointer myvar
001923  002127  //       : The allocated memory contains garbage but is a fast allocation.
001924  002128  //       : The block must later be released with mem_Free();
001925  002129  //       : returns 0 if function fails
001926  002130        
001927  002131  func mem_AllocV("size"), 1;
001928  002132  // Syntax: mem_AllocV(bytesize);
001929  002133  // Usage : myvar := mem_AllocV(100);
001930  002134  // Notes : Allocate a block of memory to pointer myvar
001931  002135  //       : The block of memory is filled with signature values
001932  002136  //       : the block starts with A5,5A then fills with incrementing
001933  002137  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
001934  002138  //       : This can be helpful when debugging
001935  002139  //       : The block must later be released with mem_Free();
001936  002140  //       : returns 0 if function fails
001937  002141        
001938  002142  func mem_AllocZ("size"), 1;
001939  002143  // Syntax: mem_AllocZ(bytesize);
001940  002144  // Usage : myvar := mem_AllocC(100);
001941  002145  // Notes : Allocate a zeroed block of memory to pointer myvar
001942  002146  //       : The block of memory is filled with zeroes
001943  002147  //       : The block must later be released with mem_Free();
001944  002148  //       : returns 0 if function fails
001945  002149        
001946  002150  func mem_Realloc("ptr", "size"), 1;
001947  002151  // Syntax: myvar := mem_Realloc("ptr", "size");
001948  002152  // Usage : myvar := mem_Realloc(ptr, size);
001949  002153  // Notes : The function may move the memory block to a new location,
001950  002154  //       : in which case the new location is returned.
001951  002155  //       : The content of the memory block is preserved up to the lesser
001952  002156  //       : of the new and old sizes, even if the block is moved.
001953  002157  //       : If the new size is larger, the value of the newly allocated
001954  002158  //       : portion is indeterminate. In case that ptr is NULL,
001955  002159  //       : the function behaves exactly as mem_Alloc, assigning a new block
001956  002160  //       : of size bytes and returning a pointer to the beginning of it.
001957  002161  //       : In case that the size is 0, the memory previously allocated in
001958  002162  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
001959  002163  //       : pointer is returned.
001960  002164        
001961  002165  func mem_Free("allocation"), 1;
001962  002166  // Syntax: myvar := mem_Free(allocation);
001963  002167  // Usage : myvar := mem_Free(myvar);
001964  002168  // Notes : De-allocate a block of memory previously created with
001965  002169  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
001966  002170  //       : returns 0 if function fails
001967  002171        
001968  002172  func mem_Heap(), 1;
001969  002173  // Syntax: myvar := mem_Heap();
001970  002174  // Usage : myvar := mem_Heap();
001971  002175  // Notes : returns bytecount available in heap
001972  002176  //       :
001973  002177        
001974  002178  func mem_Set("ptr","char","size"), 1;
001975  002179  // Syntax: mem_Set(ptr,char,bytesize);
001976  002180  // Usage : mem_Set(p, 'A', 100);
001977  002181  // Notes : fill a block of memory with a byte value
001978  002182  //       : returns ptr
001979  002183        
001980  002184  func mem_Copy("src", "dest", "bytecount"), 1;
001981  002185  // Syntax: myvar := mem_Copy(src, dest, bytesize);
001982  002186  // Usage : myvar := mem_Copy(p1, p2, 100);
001983  002187  // Notes : copy a word aligned block of memory from src to dest
001984  002188  //       : Note that count is a byte count, this facilitates
001985  002189  //       : copying word aligned byte arrays when using word
001986  002190  //       : aliggned packed strings.
001987  002191  //       : returns src
001988  002192        
001989  002193  func mem_Compare("ptr1","ptr2","count"), 1;
001990  002194  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
001991  002195  // Usage : myvar := mem_Compare(p1, p2, 100);
001992  002196  // Notes : compare blocks of memory at src, dest
001993  002197  //       : returns 0 if we have a match
001994  002198        
001995  002199  //------------------------------------------------------------------//
001996  002200  //        FAT16 Function Prototypes
001997  002201  //------------------------------------------------------------------//
001998  002202        
001999  002203  func file_Error(), 1;
002000  002204  // Syntax: myvar := file_Error();
002001  002205  // Usage : e := file_Error();
002002  002206  // Notes : return the most recent file error.
002003  002207  //       :
002004  002208        
002005  002209  func file_Count("filename"), 1;
002006  002210  // Syntax: count := file_Count("filename");
002007  002211  // Usage : count := file_Count("*.4dg");
002008  002212  // Notes : returns number of files found that match the criteria
002009  002213        
002010  002214  func file_Dir("filename"), 1;
002011  002215  // Syntax: count := file_Dir("filename");
002012  002216  // Usage : count := file_Dir("*.4dg");
002013  002217  // Notes : streams a string of filenames that agree with the search key
002014  002218  //       : returns number of files found that match the criteria
002015  002219        
002016  002220  func file_FindFirst("fname"), 1;
002017  002221  // Syntax: res := file_FindFirst("fname");
002018  002222  // Usage : if (file_FindFirst("*.4xe") ....
002019  002223  // Notes : returns true if at least 1 file exists
002020  002224  //       : that satisfies the file argument.
002021  002225  //       : Wildcards are usually used so if
002022  002226  //       : file_FindFirst returns true, further
002023  002227  //       : tests can be made using file_FindNext();
002024  002228  //       : to find all the files that match the
002025  002229  //       : wildcard class. Note that the stream behaviour
002026  002230  //       : is the same as file_Dir.
002027  002231  //       :
002028  002232        
002029  002233  func file_FindNext(), 1;
002030  002234  // Syntax: res := file_FindNext();
002031  002235  // Usage : while ((file_FindNext()) ....
002032  002236  // Notes : returns true if more file exists
002033  002237  //       : that satisfies the file argument
002034  002238  //       : that was given for  file_FindFirst.
002035  002239  //       : Wildcards must be used for
002036  002240  //       : file_FindFirst, else this function will
002037  002241  //       : always return zero as the only occurence
002038  002242  //       : will have already been found.
002039  002243  //       : Note that the stream behaviour
002040  002244  //       : is the same as file_Dir.
002041  002245  //       :
002042  002246        
002043  002247  func file_Exists("fname"), 1;
002044  002248  // Syntax: res := file_Exists("fname"),
002045  002249  // Usage : if(file_Exists("myfile") ....
002046  002250  // Notes : returns true if file exists
002047  002251  //       :
002048  002252        
002049  002253  func file_Open("fname", "mode"), 1;
002050  002254  // Syntax: handle := file_Open("fname","mode"),
002051  002255  // Usage : handle := file_Open("myfile.txt", 'r');
002052  002256  // Notes : returns handle if file exists
002053  002257  //       :
002054  002258        
002055  002259  func file_Close("handle"), 1;
002056  002260  // Syntax: res := file_Close("handle");
002057  002261  // Usage : res := file_Close(hnd1);
002058  002262  // Notes : returns true if file closed ok
002059  002263  //       :
002060  002264        
002061  002265  func file_Read("*dest", "size", "handle"), 1;
002062  002266  // Syntax: res := file_Read("*dest", "size", "handle"),
002063  002267  // Usage : res := file_Read(memblock,20,hnd1);
002064  002268  // Notes : returns number of characters read
002065  002269  //       : if "dest" is zero, data is read direct to GRAM window
002066  002270  //       :
002067  002271        
002068  002272        
002069  002273  func file_Seek("handle", "HiWord", "LoWord"), 1;
002070  002274  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
002071  002275  // Usage : res := file_Seek(hSource, 0, 0x1234);
002072  002276  // Notes : set file position to 0x00001234 (byte position 4660)
002073  002277  //       : for the file handle so subsequent data may be read
002074  002278  //       : from that position onwards with file_GetC(...),
002075  002279  //       : file_GetW(...) or file_GetS(...), or an image
002076  002280  //       : can be displayed with file_Image(...)
002077  002281  // Notes : returns true if ok, usually ignored
002078  002282        
002079  002283  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
002080  002284  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
002081  002285  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
002082  002286  // Notes : set file seek position to 123000
002083  002287  //       : for the file handle so subsequent data may be read
002084  002288  //       : from that record position onwards with file_GetC(...),
002085  002289  //       : file_GetW(...) or file_GetS(...), or an image
002086  002290  //       : can be displayed with file_Image(...)
002087  002291  // Notes : returns true if ok, usually ignored
002088  002292        
002089  002293  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
002090  002294  // Syntax: file_Tell("handle", &HiWord, &LoWord);
002091  002295  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
002092  002296  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
002093  002297  //       : returns true if function succeeded
002094  002298        
002095  002299  func file_Write("*source", "size", "handle"), 1;
002096  002300  // Syntax: res := fwrite("*source", "size", "handle"),
002097  002301  // Usage : res := fwrite(memblock, 20, hnd1);
002098  002302  // Notes : returns number of bytes written
002099  002303  //       :
002100  002304        
002101  002305  func file_Size("handle", "&HiWord", "&LoWord"), 1;
002102  002306  // Syntax: file_Size("handle", &HiWord, &LoWord);
002103  002307  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
002104  002308  // Notes : Reads the 32 bit file size and stores it into 2 variables.
002105  002309  //       : returns true if function succeeded
002106  002310        
002107  002311  func file_Image("x", "y", "handle"), 1;
002108  002312  // Syntax: file_Image(x, y, handle);
002109  002313  // Usage : file_Image(10, 10, hnd1);
002110  002314  // Notes : Display an image from a file at the current file position.
002111  002315  //       : The image is displayed at x,y (with respect to top left corner).
002112  002316  //       : If there is more than 1 image in the file, it can be
002113  002317  //       : accessed with file_Seek(...)
002114  002318        
002115  002319  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
002116  002320  // Syntax: file_ScreenCapture(x, y, w, h, handle);
002117  002321  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
002118  002322  // Notes : Save a image from screen to file at the current file position.
002119  002323  //       : The image can later be displayed with file_Image(...);
002120  002324  //       : The file may be opened in append mode to accumulate multiple
002121  002325  //       : images. Later, the images can be accessed with file_Seek(...);
002122  002326  //       : Note that the image will be sector aligned.
002123  002327  //       : All image headers must start on a sector boundary.
002124  002328  //       : The image is saved from x, y (with respect to top left corner)
002125  002329  //       : and the capture area is determined by "width" and "height".
002126  002330  //       : returns 0 if function succeeded
002127  002331        
002128  002332  func file_PutC("char","handle"), 1;
002129  002333  // Syntax: file_PutC("char", "handle");
002130  002334  // Usage : file_PutC('x', hndl);
002131  002335  // Notes : returns true if function succeeded
002132  002336        
002133  002337  func file_GetC("handle"), 1;
002134  002338  // Syntax: file_GetC("handle");
002135  002339  // Usage : mychar := fgetC("handle");
002136  002340  // Notes : returns next char from file
002137  002341        
002138  002342  func file_PutW("word","handle"), 1;
002139  002343  // Syntax: file_PutW("word","handle");
002140  002344  // Usage : file_PutW(0x1234, hndl);
002141  002345  // Notes : returns true if function succeeded
002142  002346        
002143  002347  func file_GetW("handle"), 1;
002144  002348  // Syntax: file_GetW("handle");
002145  002349  // Usage : myword := fgetW("handle");
002146  002350  // Notes : returns next word in file
002147  002351        
002148  002352  func file_PutS("*source", "handle"), 1;
002149  002353  // Syntax: res := file_Puts("*source", "handle"),
002150  002354  // Usage : res := file_Puts(mystring, hnd1);
002151  002355  // Notes : returns number of characters written
002152  002356  //       :
002153  002357        
002154  002358  func file_GetS("*string", "size", "handle"), 1;
002155  002359  // Syntax: res := file_Gets("*string", "size", "handle");
002156  002360  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
002157  002361  // Notes : get a string from a file
002158  002362  //       : returns pointer to string or null if failed.
002159  002363  //       : file_GetS(...) automatically appends a null-terminator to the data read.
002160  002364  //       : NB:- only reads up to "size-1" characters into "string"
002161  002365  //       : file_GetS(...) will stop reading when any of the following conditions are true:
002162  002366  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
002163  002367  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
002164  002368  //       : C] It reaches the end of file
002165  002369  //       : D] A read error occurs.
002166  002370        
002167  002371        
002168  002372  func file_Erase("fname"), 1;
002169  002373  // Syntax: res := file_Erase("fname");
002170  002374  // Usage : res := file_Erase("myfile.txt");
002171  002375  // Notes : returns true if successful
002172  002376  //       :
002173  002377        
002174  002378  func file_Rewind("handle"), 1;
002175  002379  // Syntax: res := file_Rewind("handle");
002176  002380  // Usage : res := file_Rewind(hnd1);
002177  002381  // Notes : returns true if file rewound ok (usually ignored)
002178  002382  //       : resets the file pointer the the beginning of the open file.
002179  002383        
002180  002384  func file_LoadFunction("fname.4xe"), 1;
002181  002385  // Syntax: res := file_LoadFunction("fname.4fn");
002182  002386  // Usage : myfunc := file_LoadFunction(myfuncname);
002183  002387  // Notes : Load a function or program from disk and
002184  002388  //       : return a function pointer to the allocation.
002185  002389  //       : The function can then be invoked just like any other
002186  002390  //       : function would be called via a function pointer.
002187  002391  //       : Parameters may be passed to it in a conventional way.
002188  002392  //       : The function may be discarded at any time when no
002189  002393  //       : longer required, thus freeing its memory resources.
002190  002394  //       : The loaded function can be discarded with mem_Free(..)
002191  002395  //       : eg:
002192  002396  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
002193  002397  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
002194  002398  //       : then elsewhere in your program:-
002195  002399  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
002196  002400  //       : if(res == QUIT_APPLICATION) goto exitApp;
002197  002401  //       : Later in your program, when popupWindow is no longer
002198  002402  //       : required for the application:-
002199  002403  //       : res := mem_Free(popupWindow);
002200  002404  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
002201  002405  //       : The callers stack is shared by the loaded function,
002202  002406  //       : however any global variables in the loaded function
002203  002407  //       : are private to that function.
002204  002408  //
002205  002409        
002206  002410  func file_Run("fname.4xe", "arglistptr"), 1;
002207  002411  // Syntax: res := file_Run("fname.4xe","arglistptr");
002208  002412  // Usage : res := file_Run(fname, argptr);
002209  002413  // Notes : current program releases any allocated memory but
002210  002414  //       : retains the stack and global memory.
002211  002415  //       : If arglistptr is 0, no arguments are passed, else
002212  002416  //       : arglist points to an array, the first element being
002213  002417  //       : the number of elements in the array.
002214  002418  //       : func 'main' in the called program accepts
002215  002419  //       : the arguments, if any. THe arguments can only
002216  002420  //       : be passed by value, no pointers or references can be
002217  002421  //       : used as all memory is cleared before the file
002218  002422  //       : is loaded. Refer to file_Exec and file_LoadFunction
002219  002423  //       : for functions that can pass by reference.
002220  002424        
002221  002425  func file_Exec("fname.4xe", "arglistptr"), 1;
002222  002426  // Syntax: res := file_Exec("fname.4xe","arglistptr");
002223  002427  // Usage : res := file_Exec("fname.4xe","arglistptr");
002224  002428  // Notes : returns like a function, current program
002225  002429  //       : calling program is kept active and control returns to it.
002226  002430  //       : If arglistptr is 0, no arguments are passed, else
002227  002431  //       : arglist points to an array, the first element being
002228  002432  //       : the number of elements in the array.
002229  002433  //       : func 'main' in the called program accepts the arguments.
002230  002434  //       : This function is similar to file_LoadFunction(...), however,
002231  002435  //       : the function argument list is passed by pointer, and
002232  002436  //       : the memory consumed by the function is released as
002233  002437  //       : soon as the function completes.
002234  002438        
002235  002439  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
002236  002440  // Syntax: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
002237  002441  // Usage : hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
002238  002442  // Notes : Reads a control file to create an image list.
002239  002443  //       : Returns NULL if function fails.
002240  002444  //       : Returns a handle (pointer to the memory allocation) to the
002241  002445  //       : image control list that has been created.
002242  002446  //       : "fname1" is the control list filename "*.dat"
002243  002447  //       : "fname2" is the image filename "*.gci"
002244  002448        
002245  002449  // Notes : This function Calculates the size of a chunk of memory required for
002246  002450  //       : a image list and populates it from the image control file ("*.dat")
002247  002451  //       : therefore, when imagelist is no longer required, you must de-allocate
002248  002452  //       : the image list memory by using eg:- mem_Free(hImagelist);
002249  002453  //       : to restore the heap.
002250  002454  //       :
002251  002455  //       : mode 0:- it is assumed that there is a graphics file with the
002252  002456  //       : file extension "fname2.gci". In this case, the images have been stored
002253  002457  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
002254  002458  //       : "fname1.dat" file are saved in the image control so that the image control
002255  002459  //       : can open the file (*.gci) and us file_Seek to get to the position of the
002256  002460  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
002257  002461  //       : mode 0 builds the image control quickly as it only scans the *.dat file
002258  002462  //       : for the file offsets and save them in the relevant entries in the image control.
002259  002463  //       : The penalty is that images take longer to find when displayed due to file_Seek
002260  002464  //       : overheads.
002261  002465  //
002262  002466  //       : mode 1:- it is assumed that there is a graphics file with the
002263  002467  //       : file extension "fname2.gci". In this case, the images have been stored
002264  002468  //       : in a FAT16 file concurrently, and the offset of the images are saved
002265  002469  //       : in the image control so that image file (*.gci) can be mapped to directly.
002266  002470  //       : The absolute cluster/sector is mapped so file seek does not need to be called
002267  002471  //       : internally. This means that there is no seek time penalty, however, the
002268  002472  //       : image list takes a lot longer to build, as all the seeking is done at control
002269  002473  //       : build time.
002270  002474        
002271  002475  //       : mode 2:- the graphics file with the is placed in a partitioned area
002272  002476  //       : In this case, the images have been stored in a in a known raw area of the FAT16
002273  002477  //       : disk, and the absolute address of the images are saved in the DAT file
002274  002478  //       : This is the fastest operation of the image control as there is no seeking
002275  002479  //       : or other disk activity taking place.
002276  002480        
002277  002481  func file_Mount(), 1;
002278  002482  // Syntax: r := file_Mount();
002279  002483  // Usage : r := file_Mount();
002280  002484  // Notes : Create a control block for FAT16 and mount the File System
002281  002485        
002282  002486  func file_Unmount(), 0;
002283  002487  // Syntax: file_Unmount();
002284  002488  // Usage : file_Unmount();
002285  002489  // Notes : release any control block and buffers for FAT16
002286  002490  //       : and unmount the File System
002287  002491        
002288  002492  func file_PlayWAV("fname1"), 1;
002289  002493  // Syntax: file_PlayWAV("fname1");
002290  002494  // Usage : file_PlayWAV("ding.wav");
002291  002495  // Notes : Play a wave file with filename "fname1"
002292  002496  //       : This function automatically grabs a chunk
002293  002497  //       : of memory for a file buffer, and a wave
002294  002498  //       : buffer. The minimum memory requirement is
002295  002499  //       : about 580 bytes for the disk io service and
002296  002500  //       : a minimum wave buffer size of 1024. The siz
002297  002501  //       : of the wave buffer allocation
002298  002502  //       : can be increased by the snd_BufSize function.
002299  002503  //       : The default size 1024 bytes.
002300  002504  //       : NB the memory is only required during the
002301  002505  //       : duration of play, and is automatically
002302  002506  //       : released while not in use.
002303  002507  //       : See the Sound Class services for other associated controls.
002304  002508  //       : If there are no errors, returns number of blocks to play (1 to 32767)
002305  002509  //       : If errors occured, the folling is returned
002306  002510  //       : -7  : Insufficient memory available for WAV buffer and file
002307  002511  //       : -6  : cant play this rate
002308  002512  //       : -5  : no data chunk found in first rsector
002309  002513  //       : -4  : no format data
002310  002514  //       : -3  : no wave chunk signature
002311  002515  //       : -2  : bad wave file format
002312  002516  //       : -1  : file not found
002313  002517        
002314  002518        
002315  002519        
002316  002520  //------------------------------------------------------------------//
002317  002521  //        Sound Class Services
002318  002522  //------------------------------------------------------------------//
002319  002523        
002320  002524  func snd_Volume("var"), 0;
002321  002525  // Syntax: snd_Volume("var");
002322  002526  // Usage : snd_Volume(30);
002323  002527  // Notes : set sound playback volume.  Var must
002324  002528  //       : be in the range from 8 (min volume)
002325  002529  //       : to 127 (max volume). If var is less
002326  002530  //       : than 8 volume is set to 8, and if
002327  002531  //       : var > 127 it is set to 127.
002328  002532        
002329  002533  func snd_Pitch("pitch"), 1;
002330  002534  // func snd_Pitch("freq"), 1;
002331  002535  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
002332  002536  // Notes : sets the samples playback rate to a different frequency
002333  002537  //       : The minimum value is 4khz
002334  002538  //       : Setting the pitch to zero restores the original sample rate
002335  002539  //       : Return value is the samples original sample rate.
002336  002540        
002337  002541  func snd_BufSize("var"), 0;
002338  002542  // Syntax: snd_BufSize("var");
002339  002543  // Usage : snd_BufSize(2);
002340  002544  // Notes : specify the a memory chunk size for the wavefile buffer.
002341  002545  //       : default size 1024 bytes.
002342  002546  //       : 0 = 1024 bytes (default)
002343  002547  //       : 1 = 2048 bytes
002344  002548  //       : 2 = 4096 bytes
002345  002549  //       : 3 = 8192 bytes
002346  002550        
002347  002551  func snd_Stop(), 0;
002348  002552  // Syntax: snd_Stop();
002349  002553  // Usage : snd_Stop();
002350  002554  // Notes : stop any sound that is playing, releasing
002351  002555  //       : buffers and closes any open wav file.
002352  002556        
002353  002557  func snd_Pause(), 0;
002354  002558  // Syntax: snd_Pause();
002355  002559  // Usage : snd_Pause();
002356  002560  // Notes : pauses any sound that is playing, does nothing
002357  002561  //       : until sound is resumed with snd_Continue().
002358  002562  //       : The sample cam be terminated with snd_Stop.
002359  002563  //       : buffers and closes any open wav file.
002360  002564        
002361  002565  func snd_Continue(), 0;
002362  002566  // Syntax: snd_Continue();
002363  002567  // Usage : snd_Continue();
002364  002568  // Notes : resume any sound that is paused by snd_Pause.
002365  002569        
002366  002570  func snd_Playing(), 1;
002367  002571  // Syntax: snd_Playing();
002368  002572  // Usage : r := snd_Playing();
002369  002573  // Notes : returns 0 if sound has finished playing,
002370  002574  //       : else return number of 512 byte blocks to go.
002371  002575        
002372  002576        
002373  002577        
002374  002578  //------------------------------------------------------------------//
002375  002579  //        String Class Services
002376  002580  //------------------------------------------------------------------//
002377  002581        
002378  002582  func str_Ptr("&var"), 1;
002379  002583  // Syntax: str_Ptr(&var);
002380  002584  // Usage : p := str_Ptr(&var);
002381  002585  // Notes : return a byte pointer to a word region
002382  002586        
002383  002587  func str_GetD("&ptr", "&var"), 1;
002384  002588  // Syntax: str_GetD(&ptr, &var);
002385  002589  // Usage : ok := str_GetD(&ptr, &var);
002386  002590  // Notes : convert number in a string to DWORD ( myvar[2] )
002387  002591  //       : returns true if function succeeds, advancing ptr
002388  002592        
002389  002593  func str_GetW("&ptr", "&var"), 1;
002390  002594  // Syntax: str_GetW(&ptr, &var);
002391  002595  // Usage : ok := str_GetW(&ptr, &var);
002392  002596  // Notes : convert number in a string to WORD ( myvar )
002393  002597  //       : returns true if function succeeds, advancing ptr
002394  002598        
002395  002599  func str_GetHexW("&ptr", "&var"), 1;
002396  002600  // Syntax: str_GetHexW(&ptr, &var);
002397  002601  // Usage : ok := str_GetHexW(&ptr, &var);
002398  002602  // Notes : convert HEX number in a string to WORD ( myvar )
002399  002603  //       : returns true if function succeeds, advancing ptr
002400  002604        
002401  002605  func str_GetC("&ptr", "&var"), 1;
002402  002606  // Syntax: str_GetC(&ptr, &var);
002403  002607  // Usage : ok := str_GetC(&ptr, &var);
002404  002608  // Notes : get a valid ascii char in a string to WORD ( myvar )
002405  002609  //       : returns true if function succeeds, advancing ptr
002406  002610        
002407  002611  func str_GetByte("ptr"), 1;
002408  002612  // Syntax: str_GetByte(ptr);
002409  002613  // Usage : myvar := str_GetByte(ptr);
002410  002614  // Notes : get a byte to myvar
002411  002615  //       : returns value
002412  002616        
002413  002617  func str_GetWord("ptr"), 1;
002414  002618  // Syntax: GetWord(ptr);
002415  002619  // Usage : GetWord(ptr);
002416  002620  // Notes : get a word to myvar
002417  002621  //       : returns value
002418  002622        
002419  002623  func str_PutByte("ptr","val"), 0;
002420  002624  // Syntax: str_PutByte(ptr);
002421  002625  // Usage : myvar := str_PutByte(ptr);
002422  002626  // Notes : put a byte at ptr
002423  002627  //       : returns value
002424  002628        
002425  002629  func str_PutWord("ptr","val"), 0;
002426  002630  // Syntax: str_PutWord("ptr","val");
002427  002631  // Usage : str_PutWord(p,100);
002428  002632  // Notes : put word 100 at current pointer location
002429  002633  //       : returns value
002430  002634        
002431  002635  func str_Match("&ptr", "*str"), 1;
002432  002636  // Syntax: str_Match(&ptr, *str);
002433  002637  // Usage : r := str_Match(&p, "hello");
002434  002638  // Notes : Case sensitive match
002435  002639  //       : returns true if function succeded, andvancing pointer to position past
002436  002640  //       : the matched item. Note that any whitespace characters are skipped
002437  002641  //       : in the source string prior to the test.
002438  002642        
002439  002643  func str_MatchI("&ptr", "*str"), 1;
002440  002644  // Syntax: str_MatchI(&ptr, *str);
002441  002645  // Usage : r := str_MatchI(&p, "hello");
002442  002646  // Notes : Case insensitive match
002443  002647  //       : returns true if function succeded, andvancing pointer to position past
002444  002648  //       : the matched item. Note that any whitespace characters are skipped
002445  002649  //       : in the source string prior to the test.
002446  002650        
002447  002651  func str_Find("&ptr", "*str"), 1;
002448  002652  // Syntax: str_Find(&ptr, *str);
002449  002653  // Usage : n := str_Find(&p, "hello");
002450  002654  // Notes : given the address of a pointer to a source string as the
002451  002655  //       : first argument, and a pointer to a test string as the second
002452  002656  //       : argument, attempt to find the position of the matching string
002453  002657  //       : in the source string. The test is performed with case sensitivity.
002454  002658  //       : return 0 if not found, else returns the address of the first
002455  002659  //       : character of the match. NB:- The source pointer is not altered.
002456  002660        
002457  002661  func str_FindI("&ptr", "*str"), 1;
002458  002662  // Syntax: str_Find(&ptr, *str);
002459  002663  // Usage : n := str_Find(&p, "hello");
002460  002664  // Notes : given the address of a pointer to a source string as the
002461  002665  //       : first argument, and a pointer to a test string as the second
002462  002666  //       : argument, attempt to find the position of the matching string
002463  002667  //       : in the source string. The test is performed with no case
002464  002668  //       : sensitivity, eg upper and lower case chars are accepted.
002465  002669  //       : return 0 if not found, else returns the address of the first
002466  002670  //       : character of the match. NB:- The source pointer is not altered.
002467  002671        
002468  002672  func str_Length("ptr"), 1;
002469  002673  // Syntax: str_Length(ptr);
002470  002674  // Usage : len := str_Ptr(mystring);
002471  002675  // Notes : return the length of a byte aligned string excluding terminator
002472  002676        
002473  002677  func str_Printf("&ptr", "*format"), 1;
002474  002678  // Syntax: str_Printf("&ptr", "*format");
002475  002679  // Usage : r := str_Printf(&p, "hello");
002476  002680  // Notes : refer to documentation
002477  002681  //       :
002478  002682        
002479  002683  func str_Cat("dest","src"), 1;
002480  002684  // Syntax: str_Append("&dest","&src");
002481  002685  // Usage : str_Append(&buf,"Hello");
002482  002686  // Notes : Appends a copy of the source string to the destination string.
002483  002687  //       : The terminating null character in destination is overwritten by
002484  002688  //       : the first character of source, and a new null-character is appended
002485  002689  //       : at the end of the new string formed by the concatenation of both in destination.
002486  002690  //       : returns destination.
002487  002691        
002488  002692  func str_CatN("dest","src","count"), 1;
002489  002693  // Syntax: str_Append("&dest","&src","count");
002490  002694  // Usage : str_Append(&buf,"Monday",3);
002491  002695  // Notes : Appends a copy of the source string to the destination string.
002492  002696  //       : The number of characters copied is limited by "count".
002493  002697  //       : The terminating null character in destination is overwritten by
002494  002698  //       : the first character of source, and a new null-character is appended
002495  002699  //       : at the end of the new string formed by the concatenation of both in destination.
002496  002700  //       : returns destination.
002497  002701        
002498  002702        
002499  002703  func sys_StoreTouchCalibration(), 1;
002500  002704  // Syntax: sys_StoreTouchCalibration();
002501  002705  // Usage : r := sys_StoreTouchCalibration();
002502  002706  // Notes : Store the touch calibration values in non-volatile memory.
002503  002707  //       : Returns true if the values have been accepted and stored,
002504  002708  //       : else returns false if write could not be performed, or
002505  002709  //       : touch calibration values are improbable.
002506  002710  //       : The values that are stored are obtained from:-
002507  002711  //     : TOUCH_XMINCAL             78  // touch calibration value
002508  002712  //     : TOUCH_YMINCAL             79  // touch calibration value
002509  002713  //       : TOUCH_XMAXCAL             80  // touch calibration value
002510  002714  //       : TOUCH_YMAXCAL             81  // touch calibration value
002511  002715  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
002512  002716  //       : This function is not supported on uVGA, Capicitive touch
002513  002717  //       : and 4.3" resistive touch modules.
002514  002718        
002515  002719        
002516  002720  func unicode_page("charbeg","charend","charoffset"), 1;
002517  002721  // Syntax: unicode_page("charbeg","charend","charoffset");
002518  002722  // Usage : eg:  F_Traditional_0x20_0xFF
002519  002723  // Notes : After selecting a unicode image control with txt_FontID,
002520  002724  //       : this function is called to set the required font within the
002521  002725  //       : unicode set. The file "Unicode.inc" contains wrappers for
002522  002726  //       : this function, and it is not normally called directly.
002523  002727  //       : Returns count of characters in the set.
002524  002728  //       : Refer to "Unicode.inc" for further information.
002525  002729        
002526  002730        
002527  002731  func EVE_SP(), 1;
002528  002732  // Syntax: EVE_SP();
002529  002733  // Usage : eg:  print(EVE_SP());
002530  002734  // Notes : Used for debugging to assess the current stack level,
002531  002735  //       : mainly for checking stack leaks
002532  002736        
002533  002737  func EVE_SSIZE(), 1;
002534  002738  // Syntax: EVE_SSIZE();
002535  002739  // Usage : eg:  print(EVE_SSIZE());
002536  002740  // Notes : Used to get the stack size,
002537  002741  //       : mainly for debugging purposes
002538  002742        
002539  002743        
002540  002744  // uVGAII extended functions
002541  002745  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
002542  002746  // Syntax: disp_Sync(line);
002543  002747  // Usage : disp_Sync(480);
002544  002748  // Notes : Waits till the hardware gets to a certain line.
002545  002749  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
002546  002750  //       : Some experimentation may be needed to find an optimum line for disp_Sync
002547  002751  //       : depending on the graphics operation. The higher the value, the slower
002548  002752  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
002549  002753  //       : within the vertical retrace period) where it will just 'hang up' stopping the
002550  002754  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
002551  002755  //       : be slowest (as its actually right at the end of the blanking period) and 508
002552  002756  //       : will cause a hangup situation as it is above the highes scanline value.
002553  002757  //       : Currently, this function is only supported on displays with SSD1963 driver.
002554  002758        
002555  002759        
002556  002760  // New functions added to PmmC v2.8
002557  002761  //================================================================
002558  002762  func CY(), 1;
002559  002763  // Syntax: CY();
002560  002764  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
002561  002765  //       : print(myvar," "CY(),"\n");           // carry = 1
002562  002766  // Notes : This function returns the carry status of an
002563  002767  // unsigned overflow from any 16 or 32bit additions or sutractions.
002564  002768  //================================================================
002565  002769        
002566  002770        
002567  002771  //================================================================
002568  002772  func str_ByteMove("src", "dest", "count"), 1;
002569  002773  // func str_ByteMove("src", "dest", "count"), 1;
002570  002774  // Syntax   : str_ByteMove(src, dest, bytecount);
002571  002775  // Input    : STR *source points to byte aligned source.
002572  002776  //          : STR *dest   points to byte aligned destination.
002573  002777  //          : VAR count   number of bytes to transfer.
002574  002778  // Usage    : nextpos := str_ByteMove(s, d, 100);
002575  002779  // Notes    : copy bytes from "src" to "dest", stopping only
002576  002780  //          : when "count" is exhausted.
002577  002781  //          : No terminator is appended, it is purely a
002578  002782  //          : byte copy, and any zeroes encountered will
002579  002783  //          : also be copied.
002580  002784  // Returns  : returns a pointer to the end of the destination
002581  002785  //          : (which is "dest" + "count")
002582  002786  //================================================================
002583  002787        
002584  002788        
002585  002789  //================================================================
002586  002790  func str_Copy("dest", "src"), 1;
002587  002791  // Syntax   : str_Copy(dest, src);
002588  002792  // Input    : STR *dest   points to byte aligned destination.
002589  002793  //          : STR *source points to byte aligned source.
002590  002794  // Usage    : nextplace := str_Copy(d, s);
002591  002795  // Notes    : copy a string from "src" to "dest", stopping only
002592  002796  //          : when the end of source string "src" is encountered
002593  002797  //          : (0x00 terminator).
002594  002798  //          : The terminator is always appended, even if "src" is
002595  002799  //          : an empty string.
002596  002800  // Returns  : returns a pointer to the 0x00 string terminator at
002597  002801  //          : end of "dest" (which is "dest" + str_Length(src); )
002598  002802  //================================================================
002599  002803        
002600  002804  //================================================================
002601  002805  func str_CopyN("dest", "src", "count"), 1;
002602  002806  // Syntax   : str_CopyN(dest, src, bytecount);
002603  002807  // Input    : STR *dest   points to byte aligned destination.
002604  002808  //          : STR *source points to byte aligned source.
002605  002809  //          : VAR count   max number of chars to copy.
002606  002810  // Usage    : nextplace := str_CopyN(d, s, 100);
002607  002811  // Notes    : copy a string from "src" to "dest", stopping only
002608  002812  //          : when "count" is exhausted, or end of source
002609  002813  //          : string "str" is encountered (0x00 string terminator).
002610  002814  //          : The terminator is always appended, even if
002611  002815  //          : "count" is zero, or "src" is a null string.
002612  002816  // Returns  : returns a pointer to the 0x00 string terminator
002613  002817  //          : (which is "dest" + whatever was copied)
002614  002818  //================================================================
002615  002819        
002616  002820  //================================================================
002617  002821  func umul_1616("&res32", "val1", "val2"), 1;
002618  002822  // Syntax   : umul_1616(&res32, varA, varB);
002619  002823  // Input    : DWORD *result   points to 32bit result register.
002620  002824  //          : VAR   val1  16bit register or constant
002621  002825  //          : VAR   val2  16bit register or constant
002622  002826  // Usage    : var res32[2];
002623  002827  //          : umul_1616(&res32, myvar, 50000);
002624  002828  // Notes    : performs an unsigned multiply of 2 x 16bit values
002625  002829  //          : placing the 32bit result in a 2 word array.
002626  002830  // Returns  : the pointer to the 32bit result.
002627  002831  //          : carry and overflow are not affected.
002628  002832  //================================================================
002629  002833        
002630  002834  //================================================================
002631  002835  func uadd_3232("&res32", "&val1", "&val2"), 1;
002632  002836  // Syntax   : cmp_3232(&res32, &varA, &varB);
002633  002837  // Input    : DWORD *res32 points to optional result (or zero for compare)
002634  002838  //          : DWORD *val1 points to 32bit augend
002635  002839  //          : DWORD *val2 points to 32bit addend
002636  002840  // Usage    : var res32[2];
002637  002841  //          : res := cmp_3232(res32, val1, val2);
002638  002842  // Notes    : performs an unsigned addition of 2 x 32bit values
002639  002843  //          : placing the 32bit result in a 2 word array.
002640  002844  // Returns  : returns 1 on 32bit unsigned overflow (carry).
002641  002845  //          ; carry flag is also set on 32bit unsigned overflow
002642  002846  //          ; and can be read with the CY() function.
002643  002847  //================================================================
002644  002848        
002645  002849  //================================================================
002646  002850  func usub_3232("&res32", "&val1", "&val2"), 1;
002647  002851  // Syntax   : cmp_3232(&res32, &varA, &varB);
002648  002852  // Input    : DWORD *res32 points to optional result (or zero for compare)
002649  002853  //          : DWORD *val1 points to first 32bit minuend
002650  002854  //          : DWORD *val2 points to 32bit subtrahend
002651  002855  // Usage    : var res32[2];
002652  002856  //          : res := cmp_3232(res32, val1, val2);
002653  002857  // Notes    : performs an unsigned subtraction of 2 x 32bit values
002654  002858  //          : placing the 32bit result in a 2 word array.
002655  002859  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
002656  002860  //          ; carry flag is also set on 32bit unsigned underflow
002657  002861  //          ; and can be read with the CY() function.
002658  002862  //================================================================
002659  002863        
002660  002864  //================================================================
002661  002865  func ucmp_3232("&val1", "&val2"), 1;
002662  002866  // Syntax   : cmp_3232(&varA, &varB);
002663  002867  // Input    : DWORD *val1 points to 32bit minuend
002664  002868  //          : DWORD *val2 points to 32bit sutrahend
002665  002869  // Usage    : res := cmp_3232(val1, val2);
002666  002870  // Notes    : performs an unsigned comparison of 2 x 32bit values.
002667  002871  //          : The result of the subtraction is returned.
002668  002872  // Returns  : 0  if equal
002669  002873  //          : 1  if val1 > val2
002670  002874  //          : -1 if val1 < val2
002671  002875  //          : This function does not affect the carry flag.
002672  002876  //================================================================
002673  002877        
002674  002878  func disp_Disconnect(), 0;                     // Disconnect display to ensure reduced power after disabling peripheral power. New in v3.8
002675  002879  // Syntax: disp_Disconnect();                  New in v3.8
002676  002880  // Usage : disp_Disconnect();
002677  002881  // Notes : Disconnects the display driver pins and/or reconfigures it to achieve
002678  002882  //       : its lowest possible power consumption. Use after disabling peripheral power
002679  002883  //       : to ensure the minimal power usage by the display.
002680  002884  //       : disp_Init() should be used to reinitialise the display.
002681  002885        
002682  002886  func reserved(), 0;                            
002683  002887        
002684  002888  func sys_DeepSleep("units"), 1;
002685  002889  // Syntax: t := sys_DeepSleep("units");       New in v3.8
002686  002890  // Usage : t := sys_DeepSleep(10);
002687  002891  // Notes : sets the display and processor into lowest power mode for a period of time.
002688  002892  //       : When returning from DeepSleep the display should be reinitialised
002689  002893  //       : with disp_Init().
002690  002894  //       : Touching the touch screen will also wake from sleep.
002691  002895  //       : Returns remaining sleep units.
002692  002896        
002693  002897  //------------------------------------------------------------------//
002694  002898  // CONSTANTS
002695  002899  //------------------------------------------------------------------//
002696  002900        
002697  002901  // generic constants
002698  002902  #CONST
002699  002911  #END
002700  002912        
002701  002913  //------------------------------------------------------------------------------
002702  002914  // Pin related constants
002703  002915  //------------------------------------------------------------------------------
002704  002916  #CONST
002705  002934  #END
002706  002935        
002707  002936  //------------------------------------------------------------------------------
002708  002937  //gfx_Set() related constants
002709  002938  //------------------------------------------------------------------------------
002710  002939  #CONST
002711  002956  #END
002712  002957        
002713  002958        
002714  002959  //gfx_Get() related constants
002715  002960  #CONST
002716  002969  #END
002717  002970        
002718  002971        
002719  002972        
002720  002973        
002721  002974  #CONST
002722  002987  #END
002723  002988        
002724  002989        
002725  002990  #CONST
002726  003013  #END
002727  003014        
002728  003015  //------------------------------------------------------------------------------
002729  003016  //txt_Set() related constants
002730  003017  //------------------------------------------------------------------------------
002731  003018  #CONST
002732  003037  #END
002733  003038        
002734  003039        
002735  003040        
002736  003041  //------------------------------------------------------------------------------
002737  003042  //txt_Set() related arguments
002738  003043  // NB:- FONT4 must be inherited if required,
002739  003044  // eg #inherit "FONT4.fnt"
002740  003045  //------------------------------------------------------------------------------
002741  003046  #CONST
002742  003058  #END
002743  003059        
002744  003060        
002745  003061        
002746  003062  //touch_Set() related constants
002747  003063  #CONST
002748  003067  #END
002749  003068        
002750  003069  //touch_Get() related constants
002751  003070  #CONST
002752  003078  #END
002753  003079        
002754  003080  // image control offset related constants
002755  003081  #CONST
002756  003088  #END
002757  003089        
002758  003090  // image attribute flags
002759  003091  // for img_SetAttributes(...) and img_ClearAttributes(...)
002760  003092  #CONST
002761  003106  #END
002762  003107        
002763  003108        
002764  003109  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
002765  003109  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
002766  003110        
002767  003111  // image control entry offsets
002768  003112  #CONST
002769  003127  #END
002770  003128        
002771  003129  #CONST
002772  003147  #END
002773  003148        
002774  003149        
002775  003150        
002776  003151        
002777  003152  #CONST
002778  003172  #END
002779  003173        
002780  003174        
002781  003175        
002782  003176  // timer control  related constants
002783  003177  #CONST
002784  003186  #END
002785  003187        
002786  003188  // I2C timing related constants
002787  003189  #CONST
002788  003193  #END
002789  003194        
002790  003195        
002791  003196  // spi_Init(...)  mode arguments
002792  003197  #CONST
002793  003207  #END
002794  003208        
002795  003209  //------------------------------------------------------------------------------
002796  003210  // system WORD variables accesible with peekW and pokeW or pointer access
002797  003211  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
002798  003212  // can also be accessed with peekW and pokeW
002799  003213  //------------------------------------------------------------------------------
002800  003214        
002801  003215  #CONST
002802  003309  #END
002803  003310        
002804  003311  //------------------------------------------------------------------------------
002805  003312  // FILEIO Error Code Constants
002806  003313  //------------------------------------------------------------------------------
002807  003314  #CONST
002808  003340  #END
002809  003341        
002810  003342  //==================================================================================================
002811  003343        
002812  003344        
002813  003345        
002814  000013      #ENDIF
002815  000014        
002816  000015        
002817  000016         #CONST
002818  000102      #END
002819  000103        
002820  000104  #constant TOUCH_DRIVE 78      // external pointing device control for gfx_Set(TOUCH_DRIVE, command);
002821  000104  #constant TOUCH_DRIVE 78      // external pointing device control for gfx_Set(TOUCH_DRIVE, command);
002822  000105        
002823  000106        
002824  000107        
002825  000108        
002826  000109        
002827  000110  //===========================================================================================
002828  000111        
002829  000112        
002830  000002        
002831  000003  // generated 4/14/2014 3:51:20 PM
002832  000004        
002833  000005  #MODE RUNFLASH
002834  000006        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

002835  000007  #inherit "4DGL_16bitColours.fnc"
002836  000007  #inherit "4DGL_16bitColours.fnc"
002837  000004  */
002838  000005        
002839  000006        
002840  000007        
002841  000008  #CONST
002842  000149  #END
002843  000150        
002844  000008        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

002845  000009  #inherit "VisualConst.inc"
002846  000009  #inherit "VisualConst.inc"
002847  000001  // Line Patterns
002848  000002  #constant  LPCOARSE    0xF0F0
002849  000002  #constant  LPCOARSE    0xF0F0
002850  000003  #constant  LPMEDIUM    0x3333
002851  000003  #constant  LPMEDIUM    0x3333
002852  000004  #constant  LPFINE      0xAAAA
002853  000004  #constant  LPFINE      0xAAAA
002854  000005  #constant  LPDASHDOT   0x03CF
002855  000005  #constant  LPDASHDOT   0x03CF
002856  000006  #constant  LPDASHDOTDOT 0x0333
002857  000006  #constant  LPDASHDOTDOT 0x0333
002858  000007  #constant  LPSOLID     0x0000
002859  000007  #constant  LPSOLID     0x0000
002860  000010        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\XYposToDegree.inc

002861  000011  #inherit "XYposToDegree.inc"
002862  000011  #inherit "XYposToDegree.inc"
002863  000001  //
002864  000002  // Routine to convert X/Y (Relative to 0,0) position into Degrees
002865  000003  // 0 Degrees is straight down to suit rotary objects
002866  000004  //
002867  000005        
002868  000017  #END
2869  006B
2870  006C
2871  006D
2872  006E
2873  006F
2874  0070
2875  0071
2876  0072
2877  0073
2878  0074
2879  0075
2880  0076
2881  0077
2882  0078
2883  0079
2884  007A
2885  007B
2886  007C
2887  007D
2888  007E
2889  007F
2890  0080
2891  0081
2892  0082
2893  0083
2894  0084
2895  0085
2896  0086
2897  0087
2898  0088
2899  0089
2900  008A
2901  008B
2902  008C
2903  008D
2904  008E
2905  008F
2906  0090
2907  0091
2908  0092
2909  0093
2910  0094
2911  0095
2912  0096
2913  0097
2914  0098
2915  0099
2916  009A
2917  009B
2918  009C
2919  009D
2920  009E
2921  009F
2922  00A0
2923  00A1
2924  00A2
2925  00A3
2926  00A4
2927  00A5
2928  00A6
2929  00A7
2930  00A8
2931  00A9
2932  00AA
2933  00AB
2934  00AC
2935  00AD
2936  00AE
2937  00AF
2938  00B0
2939  00B1
2940  00B2
2941  00B3
2942  00B4
2943  00B5
2944  00B6
2945  00B7
2946  00B8
2947  00B9
2948  00BA
2949  00BB
2950  00BC
2951  00BD
2952  00BE
2953  00BF
2954  00C0
2955  00C1
2956  00C2
2957  00C3
2958  00C4
2959  00C5
2960  00C6
2961  00C7
2962  00C8
2963  00C9
2964  00CA
2965  00CB
2966  00CC
2967  00CD
2968  00CE
2969  00CF
002970  000018        
002971  000019  func XYposToDegree(var curX, var curY)
002972  000020      var delta, deg, adj ;
002973  000021      if (curY < 0)
002974  000022          if (curX < 0)
002975  000023              adj := 1 ;
002976  000024              deg := 90 ;
002977  000025          else
002978  000026              adj := 2 ;
002979  000027              deg := 180 ;
002980  000028          endif
002981  000029      else
002982  000030          if (curX < 0)
002983  000031              deg := 0 ;
002984  000032              adj := 2 ;
002985  000033          else
002986  000034              deg := 270 ;
002987  000035              adj := 1 ;
002988  000036          endif
002989  000037      endif
002990  000038        
002991  000039      curX := ABS(curX) ;
002992  000040      curY := ABS(curY) ;
002993  000041      if (curX < curY)
002994  000042          adj &= 1 ;
002995  000043      else
002996  000044          adj &= 2 ;
002997  000045          SWAP(&curX, &curY) ;
002998  000046      endif
002999  000047      delta := arctan[(curX * 100) / curY] ;
003000  000048      if (adj)
003001  000049          deg += 90 - delta ;
003002  000050      else
003003  000051          deg += delta ;
003004  000052      endif
003005  000053        
003006  000054      return deg ;
003007  000055  endfunc
003008  000056        
003009  000012        
file C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2Const.inc

003010  000013  #inherit "MCTRL_REV2Const.inc"
003011  000013  #inherit "MCTRL_REV2Const.inc"
003012  000001  // File generated 4/14/2014 3:48:30 PM
003013  000002  // Warning! This is a generated file, any manual changes will be
003014  000003  // lost during the next generation.
003015  000004        
003016  000005  #constant  Strings2Count    1
003017  000005  #constant  Strings2Count    1
003018  000006  #constant  Strings2Size     35
003019  000006  #constant  Strings2Size     35
003020  000007  #constant  Strings1Count    1
003021  000007  #constant  Strings1Count    1
003022  000008  #constant  Strings1Size     30
003023  000008  #constant  Strings1Size     30
003024  000009  #constant  Strings0Count    1
003025  000009  #constant  Strings0Count    1
003026  000010  #constant  Strings0Size     11
003027  000010  #constant  Strings0Size     11
003028  000011  #constant  Strings7Count    1
003029  000011  #constant  Strings7Count    1
003030  000012  #constant  Strings7Size     12
003031  000012  #constant  Strings7Size     12
003032  000013  #constant  Strings9Count    1
003033  000013  #constant  Strings9Count    1
003034  000014  #constant  Strings9Size     11
003035  000014  #constant  Strings9Size     11
003036  000015  #constant  Strings6Count    1
003037  000015  #constant  Strings6Count    1
003038  000016  #constant  Strings6Size     17
003039  000016  #constant  Strings6Size     17
003040  000017  #constant  Strings3Count    1
003041  000017  #constant  Strings3Count    1
003042  000018  #constant  Strings3Size     22
003043  000018  #constant  Strings3Size     22
003044  000019  #constant  Strings4Count    1
003045  000019  #constant  Strings4Count    1
003046  000020  #constant  Strings4Size     24
003047  000020  #constant  Strings4Size     24
003048  000021  #constant  Strings5Count    1
003049  000021  #constant  Strings5Count    1
003050  000022  #constant  Strings5Size     20
003051  000022  #constant  Strings5Size     20
003052  000023  #constant  Strings8Count    1
003053  000023  #constant  Strings8Count    1
003054  000024  #constant  Strings8Size     13
003055  000024  #constant  Strings8Size     13
003056  000025  // object indexes into ImageControl
003057  000026  #CONST
003058  000156  #END
003059  000157        
003060  000158  #constant  Strings2StartH   0x0
003061  000158  #constant  Strings2StartH   0x0
003062  000159  #constant  Strings2StartL   0x0
003063  000159  #constant  Strings2StartL   0x0
003064  000160  #constant  Strings1StartH   0x0
003065  000160  #constant  Strings1StartH   0x0
003066  000161  #constant  Strings1StartL   0x200
003067  000161  #constant  Strings1StartL   0x200
003068  000162  #constant  Strings0StartH   0x0
003069  000162  #constant  Strings0StartH   0x0
003070  000163  #constant  Strings0StartL   0x400
003071  000163  #constant  Strings0StartL   0x400
003072  000164  #constant  Strings7StartH   0x0
003073  000164  #constant  Strings7StartH   0x0
003074  000165  #constant  Strings7StartL   0x600
003075  000165  #constant  Strings7StartL   0x600
003076  000166  #constant  Strings9StartH   0x0
003077  000166  #constant  Strings9StartH   0x0
003078  000167  #constant  Strings9StartL   0x800
003079  000167  #constant  Strings9StartL   0x800
003080  000168  #constant  Strings6StartH   0x0
003081  000168  #constant  Strings6StartH   0x0
003082  000169  #constant  Strings6StartL   0xA00
003083  000169  #constant  Strings6StartL   0xA00
003084  000170  #constant  Strings3StartH   0x0
003085  000170  #constant  Strings3StartH   0x0
003086  000171  #constant  Strings3StartL   0xC00
003087  000171  #constant  Strings3StartL   0xC00
003088  000172  #constant  Strings4StartH   0x0
003089  000172  #constant  Strings4StartH   0x0
003090  000173  #constant  Strings4StartL   0xE00
003091  000173  #constant  Strings4StartL   0xE00
003092  000174  #constant  Strings5StartH   0x0
003093  000174  #constant  Strings5StartH   0x0
003094  000175  #constant  Strings5StartL   0x1000
003095  000175  #constant  Strings5StartL   0x1000
003096  000176  #constant  Strings8StartH   0x0
003097  000176  #constant  Strings8StartH   0x0
003098  000177  #constant  Strings8StartL   0x1200
003099  000177  #constant  Strings8StartL   0x1200
003100  000178  var disk, hndl ;
003101  000014        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\CLPrintStrings.inc

003102  000015  #inherit "CLPrintStrings.inc"
003103  000015  #inherit "CLPrintStrings.inc"
003104  000001  func PrintStrings(var ID, var *msgid, var String)
003105  000002      var StringID, i, ch, offs32[2], res32[2];
003106  000003      StringID := oStringss[1+ID] ;
003107  000004      if (String)
003108  000005          stringsCV[ID] := -1 ;
003109  000006      else
003110  000007          stringsCV[ID] := msgid ;
003111  000008      endif
003112  000009      if ((StringID == -1) || (*(StringID + STForm) != curform)) return ;
003113  000010      txt_FontID(hFonts[ID]) ;
003114  000011      txt_Attributes(*(StringID + STFontAttribs)) ; // >> 4 fix for r25,6,7,8 PmmC
003115  000012  //    txt_Opacity(*(StringID + STTransparent)) ;
003116  000013        
003117  000014      if (*(StringID + STTransparent))
003118  000015          gfx_RectangleFilled(*(StringID + STx1), *(StringID + STy1), *(StringID + STx2), *(StringID + STy2), *(StringID + STBGColor));
003119  000016      else if (formBGcol[curform] != BGIMAGE)
003120  000017          gfx_RectangleFilled(*(StringID + STx1), *(StringID + STy1), *(StringID + STx2), *(StringID + STy2), formBGcol[curform]);
003121  000018      else
003122  000019          gfx_ClipWindow(*(StringID + STx1), *(StringID + STy1), *(StringID + STx2), *(StringID + STy2)) ;
003123  000020          gfx_Clipping(ON) ;
003124  000021          img_Show(hndl,formstidx[curform]) ;
003125  000022          gfx_Clipping(OFF) ;
003126  000023        
003127  000024      endif
003128  000025        
003129  000026      txt_FGcolour(*(StringID + STFGColor)) ;
003130  000027      txt_BGcolour(*(StringID + STBGColor)) ;
003131  000028      txt_Opacity(TRANSPARENT);                // 8  text OPAQUE or TRANSPARENT
003132  000029        
003133  000030      gfx_MoveTo(*(StringID + STx1) , *(StringID + STy1)) ;
003134  000031        
003135  000032      if (String)
003136  000033          i := 0 ;
003137  000034          ch := msgid[i++] ;
003138  000035          while (ch != 0)
003139  000036              putch(ch) ;
003140  000037              ch := msgid[i++] ;
003141  000038          wend
003142  000039      else
003143  000040          umul_1616(offs32, *(StringID + STSize), msgid);
003144  000041          res32[1] := *(StringID + STStartH) ;
003145  000042          res32[0] := *(StringID + STStartL) ;
003146  000043          uadd_3232(res32,res32,offs32) ;
003147  000044          file_Seek(hstrings, res32[1], res32[0]);
003148  000045          repeat
003149  000046              if (*(StringID + STAnsi))
003150  000047                  ch := file_GetC(hstrings) ;
003151  000048              else
003152  000049                  ch := file_GetW(hstrings) ;
003153  000050              endif
003154  000051              putch(ch) ;
003155  000052          until (ch == 0) ;
003156  000053      endif
003157  000054        
003158  000055  endfunc
003159  000056        
003160  000016        
003161  000017  #constant IPDatasize 22
003162  000017  #constant IPDatasize 22
003163  000018        
003164  000019  #CONST
003165  000021  #END
003166  000022        
003167  000023  #CONST
003168  000123  #END
003169  000124        
003170  000317  #END
3171  0F9D
3172  0F9E
3173  0F9F
3174  0FA0
3175  0FA1
3176  0FA2
3177  0FA3
3178  0FA4
3179  0FA5
3180  0FA6
3181  0FA7
3182  0FA8
3183  0FA9
3184  0FAA
3185  0FAB
3186  0FAC
3187  0FAD
3188  0FAE
3189  0FAF
3190  0FB0
3191  0FB1
3192  0FB2
3193  0FB3
3194  0FB4
3195  0FB5
3196  0FB6
3197  0FB7
3198  0FB8
3199  0FB9
3200  0FBA
3201  0FBB
3202  0FBC
3203  0FBD
3204  0FBE
3205  0FBF
3206  0FC0
3207  0FC1
3208  0FC2
3209  0FC3
3210  0FC4
3211  0FC5
3212  0FC6
3213  0FC7
3214  0FC8
3215  0FC9
3216  0FCA
3217  0FCB
3218  0FCC
3219  0FCD
3220  0FCE
3221  0FCF
3222  0FD0
3223  0FD1
3224  0FD2
3225  0FD3
3226  0FD4
3227  0FD5
3228  0FD6
3229  0FD7
3230  0FD8
3231  0FD9
3232  0FDA
3233  0FDB
3234  0FDC
3235  0FDD
3236  0FDE
3237  0FDF
3238  0FE0
3239  0FE1
3240  0FE2
3241  0FE3
3242  0FE4
3243  0FE5
3244  0FE6
3245  0FE7
3246  0FE8
3247  0FE9
3248  0FEA
3249  0FEB
3250  0FEC
3251  0FED
3252  0FEE
3253  0FEF
3254  0FF0
3255  0FF1
3256  0FF2
3257  0FF3
3258  0FF4
3259  0FF5
3260  0FF6
3261  0FF7
3262  0FF8
3263  0FF9
3264  0FFA
3265  0FFB
3266  0FFC
3267  0FFD
3268  0FFE
3269  0FFF
3270  1000
3271  1001
3272  1002
3273  1003
3274  1004
3275  1005
3276  1006
3277  1007
3278  1008
3279  1009
3280  100A
3281  100B
3282  100C
3283  100D
3284  100E
3285  100F
3286  1010
3287  1011
3288  1012
3289  1013
3290  1014
3291  1015
3292  1016
3293  1017
3294  1018
3295  1019
3296  101A
3297  101B
3298  101C
3299  101D
3300  101E
3301  101F
3302  1020
3303  1021
3304  1022
3305  1023
3306  1024
3307  1025
3308  1026
3309  1027
3310  1028
3311  1029
3312  102A
3313  102B
3314  102C
3315  102D
3316  102E
3317  102F
3318  1030
3319  1031
3320  1032
3321  1033
3322  1034
3323  1035
3324  1036
3325  1037
3326  1038
3327  1039
3328  103A
3329  103B
3330  103C
3331  103D
3332  103E
3333  103F
3334  1040
3335  1041
3336  1042
3337  1043
3338  1044
3339  1045
3340  1046
3341  1047
3342  1048
3343  1049
3344  104A
3345  104B
3346  104C
3347  104D
3348  104E
3349  104F
3350  1050
3351  1051
3352  1052
3353  1053
3354  1054
3355  1055
3356  1056
3357  1057
3358  1058
3359  1059
3360  105A
3361  105B
3362  105C
3363  105D
3364  105E
3365  105F
3366  1060
3367  1061
3368  1062
3369  1063
3370  1064
3371  1065
3372  1066
3373  1067
3374  1068
3375  1069
3376  106A
3377  106B
3378  106C
3379  106D
3380  106E
3381  106F
3382  1070
3383  1071
3384  1072
3385  1073
3386  1074
3387  1075
3388  1076
3389  1077
3390  1078
3391  1079
3392  107A
3393  107B
3394  107C
3395  107D
3396  107E
3397  107F
3398  1080
3399  1081
3400  1082
3401  1083
3402  1084
3403  1085
3404  1086
3405  1087
3406  1088
3407  1089
3408  108A
3409  108B
3410  108C
3411  108D
3412  108E
3413  108F
3414  1090
3415  1091
3416  1092
3417  1093
3418  1094
3419  1095
3420  1096
3421  1097
3422  1098
3423  1099
3424  109A
3425  109B
3426  109C
3427  109D
3428  109E
3429  109F
3430  10A0
3431  10A1
3432  10A2
3433  10A3
3434  10A4
3435  10A5
3436  10A6
3437  10A7
3438  10A8
3439  10A9
3440  10AA
3441  10AB
3442  10AC
3443  10AD
3444  10AE
3445  10AF
3446  10B0
3447  10B1
3448  10B2
3449  10B3
3450  10B4
3451  10B5
3452  10B6
3453  10B7
3454  10B8
3455  10B9
3456  10BA
3457  10BB
3458  10BC
3459  10BD
3460  10BE
3461  10BF
3462  10C0
3463  10C1
3464  10C2
3465  10C3
3466  10C4
3467  10C5
3468  10C6
3469  10C7
3470  10C8
3471  10C9
3472  10CA
3473  10CB
3474  10CC
3475  10CD
3476  10CE
3477  10CF
3478  10D0
3479  10D1
3480  10D2
3481  10D3
3482  10D4
3483  10D5
3484  10D6
3485  10D7
3486  10D8
3487  10D9
3488  10DA
3489  10DB
3490  10DC
3491  10DD
3492  10DE
3493  10DF
3494  10E0
3495  10E1
3496  10E2
3497  10E3
3498  10E4
3499  10E5
3500  10E6
3501  10E7
3502  10E8
3503  10E9
3504  10EA
3505  10EB
3506  10EC
3507  10ED
3508  10EE
3509  10EF
3510  10F0
3511  10F1
3512  10F2
3513  10F3
3514  10F4
3515  10F5
3516  10F6
3517  10F7
3518  10F8
3519  10F9
3520  10FA
3521  10FB
3522  10FC
3523  10FD
3524  10FE
3525  10FF
3526  1100
3527  1101
3528  1102
3529  1103
3530  1104
3531  1105
3532  1106
3533  1107
3534  1108
3535  1109
3536  110A
3537  110B
3538  110C
3539  110D
3540  110E
3541  110F
3542  1110
3543  1111
3544  1112
3545  1113
3546  1114
3547  1115
3548  1116
3549  1117
3550  1118
3551  1119
3552  111A
3553  111B
3554  111C
3555  111D
3556  111E
3557  111F
3558  1120
3559  1121
3560  1122
3561  1123
3562  1124
3563  1125
3564  1126
3565  1127
3566  1128
3567  1129
3568  112A
3569  112B
3570  112C
3571  112D
3572  112E
3573  112F
3574  1130
3575  1131
3576  1132
3577  1133
3578  1134
3579  1135
3580  1136
3581  1137
3582  1138
3583  1139
3584  113A
3585  113B
3586  113C
3587  113D
3588  113E
3589  113F
3590  1140
3591  1141
3592  1142
3593  1143
3594  1144
3595  1145
3596  1146
3597  1147
3598  1148
3599  1149
3600  114A
3601  114B
3602  114C
3603  114D
3604  114E
3605  114F
3606  1150
3607  1151
3608  1152
3609  1153
3610  1154
3611  1155
3612  1156
3613  1157
3614  1158
3615  1159
3616  115A
3617  115B
3618  115C
3619  115D
3620  115E
3621  115F
3622  1160
3623  1161
3624  1162
3625  1163
3626  1164
3627  1165
3628  1166
3629  1167
3630  1168
3631  1169
3632  116A
3633  116B
3634  116C
3635  116D
3636  116E
3637  116F
3638  1170
3639  1171
3640  1172
3641  1173
3642  1174
3643  1175
3644  1176
3645  1177
3646  1178
3647  1179
3648  117A
3649  117B
3650  117C
3651  117D
3652  117E
3653  117F
3654  1180
3655  1181
3656  1182
3657  1183
3658  1184
3659  1185
3660  1186
3661  1187
3662  1188
3663  1189
3664  118A
3665  118B
3666  118C
3667  118D
3668  118E
3669  118F
3670  1190
3671  1191
3672  1192
3673  1193
3674  1194
3675  1195
3676  1196
3677  1197
3678  1198
3679  1199
3680  119A
3681  119B
3682  119C
3683  119D
3684  119E
3685  119F
3686  11A0
3687  11A1
3688  11A2
3689  11A3
3690  11A4
3691  11A5
3692  11A6
3693  11A7
3694  11A8
3695  11A9
3696  11AA
3697  11AB
3698  11AC
3699  11AD
3700  11AE
3701  11AF
3702  11B0
3703  11B1
3704  11B2
3705  11B3
3706  11B4
3707  11B5
3708  11B6
3709  11B7
3710  11B8
3711  11B9
3712  11BA
3713  11BB
3714  11BC
3715  11BD
3716  11BE
3717  11BF
3718  11C0
3719  11C1
3720  11C2
3721  11C3
3722  11C4
3723  11C5
3724  11C6
3725  11C7
3726  11C8
3727  11C9
3728  11CA
3729  11CB
3730  11CC
3731  11CD
3732  11CE
3733  11CF
3734  11D0
3735  11D1
3736  11D2
3737  11D3
3738  11D4
3739  11D5
3740  11D6
3741  11D7
3742  11D8
3743  11D9
3744  11DA
3745  11DB
3746  11DC
3747  11DD
3748  11DE
3749  11DF
3750  11E0
3751  11E1
3752  11E2
3753  11E3
3754  11E4
3755  11E5
3756  11E6
3757  11E7
3758  11E8
3759  11E9
3760  11EA
3761  11EB
3762  11EC
3763  11ED
3764  11EE
3765  11EF
3766  11F0
3767  11F1
3768  11F2
3769  11F3
3770  11F4
3771  11F5
3772  11F6
3773  11F7
3774  11F8
3775  11F9
3776  11FA
3777  11FB
3778  11FC
3779  11FD
3780  11FE
3781  11FF
3782  1200
3783  1201
3784  1202
3785  1203
3786  1204
3787  1205
3788  1206
3789  1207
3790  1208
3791  1209
3792  120A
3793  120B
3794  120C
3795  120D
3796  120E
3797  120F
3798  1210
3799  1211
3800  1212
3801  1213
3802  1214
3803  1215
3804  1216
3805  1217
3806  1218
3807  1219
3808  121A
3809  121B
3810  121C
3811  121D
3812  121E
3813  121F
3814  1220
3815  1221
3816  1222
3817  1223
3818  1224
3819  1225
3820  1226
3821  1227
3822  1228
3823  1229
3824  122A
3825  122B
3826  122C
3827  122D
3828  122E
3829  122F
3830  1230
3831  1231
3832  1232
3833  1233
3834  1234
3835  1235
3836  1236
3837  1237
3838  1238
3839  1239
3840  123A
3841  123B
3842  123C
3843  123D
3844  123E
3845  123F
3846  1240
3847  1241
3848  1242
3849  1243
3850  1244
3851  1245
3852  1246
3853  1247
3854  1248
3855  1249
3856  124A
3857  124B
3858  124C
3859  124D
3860  124E
3861  124F
3862  1250
3863  1251
3864  1252
3865  1253
3866  1254
3867  1255
3868  1256
3869  1257
3870  1258
3871  1259
3872  125A
3873  125B
3874  125C
3875  125D
3876  125E
3877  125F
3878  1260
3879  1261
3880  1262
3881  1263
3882  1264
3883  1265
3884  1266
3885  1267
3886  1268
3887  1269
3888  126A
3889  126B
3890  126C
3891  126D
3892  126E
3893  126F
3894  1270
3895  1271
3896  1272
3897  1273
3898  1274
3899  1275
3900  1276
3901  1277
3902  1278
3903  1279
3904  127A
3905  127B
3906  127C
3907  127D
3908  127E
3909  127F
3910  1280
3911  1281
3912  1282
3913  1283
3914  1284
3915  1285
3916  1286
3917  1287
3918  1288
3919  1289
3920  128A
3921  128B
3922  128C
3923  128D
3924  128E
3925  128F
3926  1290
3927  1291
3928  1292
3929  1293
3930  1294
3931  1295
3932  1296
3933  1297
3934  1298
3935  1299
3936  129A
3937  129B
3938  129C
3939  129D
3940  129E
3941  129F
3942  12A0
3943  12A1
3944  12A2
3945  12A3
3946  12A4
3947  12A5
3948  12A6
3949  12A7
3950  12A8
3951  12A9
3952  12AA
3953  12AB
3954  12AC
3955  12AD
3956  12AE
3957  12AF
3958  12B0
3959  12B1
3960  12B2
3961  12B3
3962  12B4
3963  12B5
3964  12B6
3965  12B7
3966  12B8
3967  12B9
3968  12BA
3969  12BB
3970  12BC
3971  12BD
3972  12BE
3973  12BF
3974  12C0
3975  12C1
3976  12C2
3977  12C3
3978  12C4
3979  12C5
3980  12C6
3981  12C7
3982  12C8
3983  12C9
3984  12CA
3985  12CB
3986  12CC
3987  12CD
3988  12CE
3989  12CF
3990  12D0
3991  12D1
3992  12D2
3993  12D3
3994  12D4
3995  12D5
3996  12D6
3997  12D7
3998  12D8
3999  12D9
4000  12DA
4001  12DB
4002  12DC
4003  12DD
4004  12DE
4005  12DF
4006  12E0
4007  12E1
4008  12E2
4009  12E3
4010  12E4
4011  12E5
4012  12E6
4013  12E7
4014  12E8
4015  12E9
4016  12EA
4017  12EB
4018  12EC
4019  12ED
4020  12EE
4021  12EF
4022  12F0
4023  12F1
4024  12F2
4025  12F3
4026  12F4
4027  12F5
4028  12F6
4029  12F7
4030  12F8
4031  12F9
4032  12FA
4033  12FB
4034  12FC
4035  12FD
4036  12FE
4037  12FF
4038  1300
4039  1301
4040  1302
4041  1303
4042  1304
4043  1305
4044  1306
4045  1307
4046  1308
4047  1309
4048  130A
4049  130B
4050  130C
4051  130D
4052  130E
4053  130F
4054  1310
4055  1311
4056  1312
4057  1313
4058  1314
4059  1315
4060  1316
4061  1317
4062  1318
4063  1319
4064  131A
4065  131B
4066  131C
4067  131D
4068  131E
4069  131F
4070  1320
4071  1321
4072  1322
4073  1323
4074  1324
4075  1325
4076  1326
4077  1327
4078  1328
4079  1329
4080  132A
4081  132B
4082  132C
4083  132D
4084  132E
4085  132F
4086  1330
4087  1331
4088  1332
4089  1333
4090  1334
4091  1335
4092  1336
4093  1337
4094  1338
4095  1339
4096  133A
4097  133B
4098  133C
4099  133D
4100  133E
4101  133F
4102  1340
4103  1341
4104  1342
4105  1343
4106  1344
4107  1345
4108  1346
4109  1347
4110  1348
4111  1349
4112  134A
4113  134B
4114  134C
4115  134D
4116  134E
4117  134F
4118  1350
4119  1351
4120  1352
4121  1353
4122  1354
4123  1355
4124  1356
4125  1357
4126  1358
4127  1359
4128  135A
4129  135B
4130  135C
4131  135D
4132  135E
4133  135F
4134  1360
4135  1361
4136  1362
4137  1363
4138  1364
4139  1365
4140  1366
4141  1367
4142  1368
4143  1369
4144  136A
4145  136B
4146  136C
4147  136D
4148  136E
4149  136F
4150  1370
4151  1371
4152  1372
4153  1373
4154  1374
4155  1375
4156  1376
4157  1377
4158  1378
4159  1379
4160  137A
4161  137B
4162  137C
4163  137D
4164  137E
4165  137F
4166  1380
4167  1381
4168  1382
4169  1383
4170  1384
4171  1385
4172  1386
4173  1387
4174  1388
4175  1389
4176  138A
4177  138B
4178  138C
4179  138D
4180  138E
4181  138F
4182  1390
4183  1391
4184  1392
4185  1393
4186  1394
4187  1395
4188  1396
4189  1397
4190  1398
4191  1399
4192  139A
4193  139B
4194  139C
4195  139D
4196  139E
4197  139F
4198  13A0
4199  13A1
4200  13A2
4201  13A3
4202  13A4
4203  13A5
4204  13A6
4205  13A7
4206  13A8
4207  13A9
4208  13AA
4209  13AB
4210  13AC
4211  13AD
4212  13AE
4213  13AF
4214  13B0
4215  13B1
4216  13B2
4217  13B3
4218  13B4
4219  13B5
4220  13B6
4221  13B7
4222  13B8
4223  13B9
4224  13BA
4225  13BB
4226  13BC
4227  13BD
4228  13BE
4229  13BF
4230  13C0
4231  13C1
4232  13C2
4233  13C3
4234  13C4
4235  13C5
4236  13C6
4237  13C7
4238  13C8
4239  13C9
4240  13CA
4241  13CB
4242  13CC
4243  13CD
4244  13CE
4245  13CF
4246  13D0
4247  13D1
4248  13D2
4249  13D3
4250  13D4
4251  13D5
4252  13D6
4253  13D7
4254  13D8
4255  13D9
4256  13DA
4257  13DB
4258  13DC
4259  13DD
4260  13DE
4261  13DF
4262  13E0
4263  13E1
4264  13E2
4265  13E3
4266  13E4
4267  13E5
4268  13E6
4269  13E7
4270  13E8
4271  13E9
4272  13EA
4273  13EB
4274  13EC
4275  13ED
4276  13EE
4277  13EF
4278  13F0
4279  13F1
4280  13F2
4281  13F3
4282  13F4
4283  13F5
4284  13F6
4285  13F7
4286  13F8
4287  13F9
4288  13FA
4289  13FB
4290  13FC
4291  13FD
4292  13FE
4293  13FF
4294  1400
4295  1401
4296  1402
4297  1403
4298  1404
4299  1405
4300  1406
4301  1407
4302  1408
4303  1409
4304  140A
4305  140B
4306  140C
4307  140D
4308  140E
4309  140F
4310  1410
4311  1411
4312  1412
4313  1413
4314  1414
4315  1415
4316  1416
4317  1417
4318  1418
4319  1419
4320  141A
4321  141B
4322  141C
4323  141D
4324  141E
4325  141F
4326  1420
4327  1421
4328  1422
4329  1423
4330  1424
4331  1425
4332  1426
4333  1427
4334  1428
4335  1429
4336  142A
4337  142B
4338  142C
4339  142D
4340  142E
4341  142F
4342  1430
4343  1431
4344  1432
4345  1433
4346  1434
4347  1435
4348  1436
4349  1437
4350  1438
4351  1439
4352  143A
4353  143B
4354  143C
4355  143D
4356  143E
4357  143F
4358  1440
4359  1441
4360  1442
4361  1443
4362  1444
4363  1445
4364  1446
4365  1447
4366  1448
4367  1449
4368  144A
4369  144B
4370  144C
4371  144D
4372  144E
4373  144F
4374  1450
4375  1451
4376  1452
4377  1453
4378  1454
4379  1455
4380  1456
4381  1457
4382  1458
4383  1459
4384  145A
4385  145B
4386  145C
4387  145D
4388  145E
4389  145F
4390  1460
4391  1461
4392  1462
4393  1463
4394  1464
4395  1465
4396  1466
4397  1467
4398  1468
4399  1469
4400  146A
4401  146B
4402  146C
4403  146D
4404  146E
4405  146F
4406  1470
4407  1471
4408  1472
4409  1473
4410  1474
4411  1475
4412  1476
4413  1477
4414  1478
4415  1479
4416  147A
4417  147B
4418  147C
4419  147D
4420  147E
4421  147F
4422  1480
4423  1481
4424  1482
4425  1483
4426  1484
4427  1485
4428  1486
4429  1487
4430  1488
4431  1489
4432  148A
4433  148B
4434  148C
4435  148D
4436  148E
4437  148F
4438  1490
4439  1491
4440  1492
4441  1493
4442  1494
4443  1495
4444  1496
4445  1497
4446  1498
4447  1499
4448  149A
4449  149B
4450  149C
4451  149D
4452  149E
4453  149F
4454  14A0
4455  14A1
4456  14A2
4457  14A3
4458  14A4
4459  14A5
4460  14A6
4461  14A7
4462  14A8
4463  14A9
4464  14AA
4465  14AB
4466  14AC
4467  14AD
4468  14AE
4469  14AF
4470  14B0
4471  14B1
4472  14B2
4473  14B3
4474  14B4
4475  14B5
4476  14B6
4477  14B7
4478  14B8
4479  14B9
4480  14BA
4481  14BB
4482  14BC
4483  14BD
4484  14BE
4485  14BF
4486  14C0
4487  14C1
4488  14C2
4489  14C3
4490  14C4
4491  14C5
4492  14C6
4493  14C7
4494  14C8
4495  14C9
4496  14CA
4497  14CB
4498  14CC
4499  14CD
4500  14CE
4501  14CF
4502  14D0
4503  14D1
4504  14D2
4505  14D3
4506  14D4
4507  14D5
4508  14D6
4509  14D7
4510  14D8
4511  14D9
4512  14DA
4513  14DB
4514  14DC
4515  14DD
4516  14DE
4517  14DF
4518  14E0
4519  14E1
4520  14E2
4521  14E3
4522  14E4
4523  14E5
4524  14E6
4525  14E7
4526  14E8
4527  14E9
4528  14EA
4529  14EB
4530  14EC
4531  14ED
4532  14EE
4533  14EF
4534  14F0
4535  14F1
4536  14F2
4537  14F3
4538  14F4
4539  14F5
4540  14F6
4541  14F7
4542  14F8
4543  14F9
4544  14FA
4545  14FB
4546  14FC
4547  14FD
4548  14FE
4549  14FF
4550  1500
4551  1501
4552  1502
4553  1503
4554  1504
4555  1505
4556  1506
4557  1507
4558  1508
4559  1509
4560  150A
4561  150B
4562  150C
4563  150D
4564  150E
4565  150F
4566  1510
4567  1511
4568  1512
4569  1513
4570  1514
4571  1515
4572  1516
4573  1517
4574  1518
4575  1519
4576  151A
4577  151B
4578  151C
4579  151D
4580  151E
4581  151F
4582  1520
4583  1521
4584  1522
4585  1523
4586  1524
4587  1525
4588  1526
4589  1527
4590  1528
4591  1529
4592  152A
4593  152B
4594  152C
4595  152D
4596  152E
4597  152F
4598  1530
4599  1531
4600  1532
4601  1533
4602  1534
4603  1535
4604  1536
4605  1537
4606  1538
4607  1539
4608  153A
4609  153B
4610  153C
4611  153D
4612  153E
4613  153F
4614  1540
4615  1541
4616  1542
4617  1543
4618  1544
4619  1545
4620  1546
4621  1547
4622  1548
4623  1549
4624  154A
4625  154B
4626  154C
4627  154D
4628  154E
4629  154F
4630  1550
4631  1551
4632  1552
4633  1553
4634  1554
4635  1555
4636  1556
4637  1557
4638  1558
4639  1559
4640  155A
4641  155B
4642  155C
4643  155D
4644  155E
4645  155F
4646  1560
4647  1561
4648  1562
4649  1563
4650  1564
4651  1565
4652  1566
4653  1567
4654  1568
4655  1569
4656  156A
4657  156B
4658  156C
4659  156D
4660  156E
4661  156F
4662  1570
4663  1571
4664  1572
4665  1573
4666  1574
4667  1575
4668  1576
4669  1577
4670  1578
4671  1579
4672  157A
4673  157B
4674  157C
4675  157D
4676  157E
4677  157F
4678  1580
4679  1581
4680  1582
4681  1583
4682  1584
4683  1585
4684  1586
4685  1587
4686  1588
4687  1589
4688  158A
4689  158B
4690  158C
4691  158D
4692  158E
4693  158F
4694  1590
4695  1591
4696  1592
4697  1593
4698  1594
4699  1595
4700  1596
4701  1597
4702  1598
4703  1599
4704  159A
4705  159B
4706  159C
4707  159D
4708  159E
4709  159F
4710  15A0
4711  15A1
4712  15A2
4713  15A3
4714  15A4
4715  15A5
4716  15A6
4717  15A7
4718  15A8
4719  15A9
4720  15AA
4721  15AB
4722  15AC
4723  15AD
4724  15AE
4725  15AF
4726  15B0
4727  15B1
4728  15B2
4729  15B3
4730  15B4
4731  15B5
4732  15B6
4733  15B7
4734  15B8
4735  15B9
4736  15BA
4737  15BB
4738  15BC
4739  15BD
4740  15BE
4741  15BF
4742  15C0
4743  15C1
4744  15C2
4745  15C3
4746  15C4
4747  15C5
4748  15C6
4749  15C7
4750  15C8
4751  15C9
4752  15CA
4753  15CB
4754  15CC
4755  15CD
4756  15CE
4757  15CF
4758  15D0
4759  15D1
4760  15D2
4761  15D3
4762  15D4
4763  15D5
4764  15D6
4765  15D7
4766  15D8
4767  15D9
4768  15DA
4769  15DB
4770  15DC
4771  15DD
4772  15DE
4773  15DF
4774  15E0
4775  15E1
4776  15E2
4777  15E3
4778  15E4
4779  15E5
4780  15E6
4781  15E7
4782  15E8
4783  15E9
4784  15EA
4785  15EB
4786  15EC
4787  15ED
4788  15EE
4789  15EF
4790  15F0
4791  15F1
4792  15F2
4793  15F3
4794  15F4
4795  15F5
4796  15F6
4797  15F7
4798  15F8
4799  15F9
4800  15FA
4801  15FB
4802  15FC
4803  15FD
4804  15FE
4805  15FF
4806  1600
4807  1601
4808  1602
4809  1603
4810  1604
4811  1605
4812  1606
4813  1607
4814  1608
4815  1609
4816  160A
4817  160B
4818  160C
4819  160D
4820  160E
4821  160F
4822  1610
4823  1611
4824  1612
4825  1613
4826  1614
4827  1615
4828  1616
4829  1617
4830  1618
4831  1619
4832  161A
4833  161B
4834  161C
4835  161D
4836  161E
4837  161F
4838  1620
4839  1621
4840  1622
4841  1623
4842  1624
4843  1625
4844  1626
4845  1627
4846  1628
4847  1629
4848  162A
4849  162B
4850  162C
4851  162D
4852  162E
4853  162F
4854  1630
4855  1631
4856  1632
4857  1633
4858  1634
4859  1635
4860  1636
4861  1637
4862  1638
4863  1639
4864  163A
4865  163B
4866  163C
4867  163D
4868  163E
4869  163F
4870  1640
4871  1641
4872  1642
4873  1643
4874  1644
4875  1645
4876  1646
4877  1647
4878  1648
4879  1649
4880  164A
4881  164B
4882  164C
4883  164D
4884  164E
4885  164F
4886  1650
4887  1651
4888  1652
4889  1653
4890  1654
4891  1655
4892  1656
4893  1657
4894  1658
4895  1659
4896  165A
4897  165B
4898  165C
4899  165D
4900  165E
4901  165F
4902  1660
4903  1661
4904  1662
4905  1663
4906  1664
4907  1665
4908  1666
4909  1667
4910  1668
4911  1669
4912  166A
4913  166B
4914  166C
4915  166D
4916  166E
4917  166F
4918  1670
4919  1671
4920  1672
4921  1673
4922  1674
4923  1675
4924  1676
4925  1677
4926  1678
4927  1679
4928  167A
4929  167B
4930  167C
4931  167D
4932  167E
4933  167F
4934  1680
4935  1681
4936  1682
4937  1683
4938  1684
4939  1685
4940  1686
4941  1687
4942  1688
4943  1689
4944  168A
4945  168B
4946  168C
4947  168D
4948  168E
4949  168F
4950  1690
4951  1691
4952  1692
4953  1693
4954  1694
4955  1695
4956  1696
4957  1697
4958  1698
4959  1699
4960  169A
4961  169B
4962  169C
4963  169D
4964  169E
4965  169F
4966  16A0
4967  16A1
4968  16A2
4969  16A3
4970  16A4
4971  16A5
4972  16A6
4973  16A7
4974  16A8
4975  16A9
4976  16AA
4977  16AB
4978  16AC
4979  16AD
4980  16AE
4981  16AF
4982  16B0
4983  16B1
4984  16B2
4985  16B3
4986  16B4
4987  16B5
4988  16B6
4989  16B7
4990  16B8
4991  16B9
4992  16BA
4993  16BB
4994  16BC
4995  16BD
4996  16BE
4997  16BF
4998  16C0
4999  16C1
5000  16C2
5001  16C3
5002  16C4
5003  16C5
5004  16C6
5005  16C7
5006  16C8
5007  16C9
5008  16CA
5009  16CB
5010  16CC
5011  16CD
5012  16CE
5013  16CF
5014  16D0
5015  16D1
5016  16D2
5017  16D3
5018  16D4
5019  16D5
5020  16D6
5021  16D7
5022  16D8
5023  16D9
5024  16DA
5025  16DB
5026  16DC
5027  16DD
5028  16DE
5029  16DF
5030  16E0
5031  16E1
5032  16E2
5033  16E3
5034  16E4
5035  16E5
5036  16E6
5037  16E7
5038  16E8
5039  16E9
5040  16EA
5041  16EB
5042  16EC
5043  16ED
5044  16EE
5045  16EF
5046  16F0
5047  16F1
5048  16F2
5049  16F3
5050  16F4
5051  16F5
5052  16F6
5053  16F7
5054  16F8
5055  16F9
5056  16FA
5057  16FB
5058  16FC
5059  16FD
5060  16FE
5061  16FF
5062  1700
5063  1701
5064  1702
5065  1703
5066  1704
5067  1705
5068  1706
5069  1707
5070  1708
5071  1709
5072  170A
5073  170B
5074  170C
5075  170D
5076  170E
5077  170F
5078  1710
5079  1711
5080  1712
5081  1713
5082  1714
5083  1715
5084  1716
5085  1717
5086  1718
5087  1719
5088  171A
5089  171B
5090  171C
5091  171D
5092  171E
5093  171F
5094  1720
5095  1721
5096  1722
5097  1723
5098  1724
5099  1725
5100  1726
5101  1727
5102  1728
5103  1729
5104  172A
5105  172B
5106  172C
5107  172D
5108  172E
5109  172F
5110  1730
5111  1731
5112  1732
5113  1733
5114  1734
5115  1735
5116  1736
5117  1737
5118  1738
5119  1739
5120  173A
5121  173B
5122  173C
5123  173D
5124  173E
5125  173F
5126  1740
5127  1741
5128  1742
5129  1743
5130  1744
5131  1745
5132  1746
5133  1747
5134  1748
5135  1749
5136  174A
5137  174B
5138  174C
5139  174D
5140  174E
5141  174F
5142  1750
5143  1751
5144  1752
5145  1753
5146  1754
5147  1755
5148  1756
5149  1757
5150  1758
5151  1759
5152  175A
5153  175B
5154  175C
5155  175D
5156  175E
5157  175F
5158  1760
5159  1761
5160  1762
5161  1763
5162  1764
5163  1765
5164  1766
5165  1767
5166  1768
5167  1769
5168  176A
5169  176B
5170  176C
5171  176D
5172  176E
5173  176F
5174  1770
5175  1771
5176  1772
5177  1773
5178  1774
5179  1775
5180  1776
5181  1777
5182  1778
5183  1779
5184  177A
5185  177B
5186  177C
5187  177D
5188  177E
5189  177F
5190  1780
5191  1781
5192  1782
5193  1783
5194  1784
5195  1785
5196  1786
5197  1787
5198  1788
5199  1789
5200  178A
5201  178B
5202  178C
5203  178D
5204  178E
5205  178F
5206  1790
5207  1791
5208  1792
5209  1793
5210  1794
5211  1795
5212  1796
5213  1797
5214  1798
5215  1799
5216  179A
5217  179B
5218  179C
5219  179D
5220  179E
5221  179F
5222  17A0
5223  17A1
5224  17A2
5225  17A3
5226  17A4
5227  17A5
5228  17A6
5229  17A7
5230  17A8
5231  17A9
5232  17AA
5233  17AB
5234  17AC
5235  17AD
5236  17AE
5237  17AF
5238  17B0
5239  17B1
5240  17B2
5241  17B3
5242  17B4
5243  17B5
5244  17B6
5245  17B7
5246  17B8
5247  17B9
5248  17BA
5249  17BB
5250  17BC
5251  17BD
5252  17BE
5253  17BF
5254  17C0
5255  17C1
5256  17C2
5257  17C3
5258  17C4
5259  17C5
5260  17C6
5261  17C7
5262  17C8
5263  17C9
5264  17CA
5265  17CB
5266  17CC
5267  17CD
5268  17CE
5269  17CF
5270  17D0
5271  17D1
5272  17D2
5273  17D3
5274  17D4
5275  17D5
5276  17D6
5277  17D7
5278  17D8
5279  17D9
5280  17DA
5281  17DB
5282  17DC
5283  17DD
5284  17DE
5285  17DF
5286  17E0
5287  17E1
5288  17E2
5289  17E3
5290  17E4
5291  17E5
5292  17E6
5293  17E7
5294  17E8
5295  17E9
5296  17EA
5297  17EB
5298  17EC
5299  17ED
5300  17EE
5301  17EF
5302  17F0
5303  17F1
5304  17F2
5305  17F3
5306  17F4
5307  17F5
5308  17F6
5309  17F7
5310  17F8
5311  17F9
5312  17FA
5313  17FB
5314  17FC
5315  17FD
5316  17FE
5317  17FF
5318  1800
5319  1801
5320  1802
5321  1803
5322  1804
5323  1805
5324  1806
5325  1807
5326  1808
5327  1809
5328  180A
5329  180B
5330  180C
5331  180D
5332  180E
5333  180F
5334  1810
5335  1811
5336  1812
5337  1813
5338  1814
5339  1815
5340  1816
5341  1817
5342  1818
5343  1819
5344  181A
5345  181B
5346  181C
5347  181D
5348  181E
5349  181F
5350  1820
5351  1821
5352  1822
5353  1823
5354  1824
5355  1825
5356  1826
5357  1827
5358  1828
5359  1829
5360  182A
5361  182B
5362  182C
5363  182D
5364  182E
5365  182F
5366  1830
5367  1831
5368  1832
5369  1833
5370  1834
5371  1835
5372  1836
5373  1837
5374  1838
5375  1839
5376  183A
5377  183B
5378  183C
5379  183D
5380  183E
5381  183F
5382  1840
5383  1841
5384  1842
5385  1843
5386  1844
5387  1845
5388  1846
5389  1847
5390  1848
5391  1849
5392  184A
5393  184B
5394  184C
5395  184D
5396  184E
5397  184F
5398  1850
5399  1851
5400  1852
5401  1853
5402  1854
5403  1855
5404  1856
5405  1857
5406  1858
5407  1859
5408  185A
5409  185B
5410  185C
5411  185D
5412  185E
5413  185F
5414  1860
5415  1861
5416  1862
5417  1863
5418  1864
5419  1865
5420  1866
5421  1867
5422  1868
5423  1869
5424  186A
5425  186B
5426  186C
5427  186D
5428  186E
5429  186F
5430  1870
5431  1871
5432  1872
5433  1873
5434  1874
5435  1875
5436  1876
5437  1877
5438  1878
5439  1879
5440  187A
5441  187B
5442  187C
5443  187D
5444  187E
5445  187F
5446  1880
5447  1881
5448  1882
5449  1883
5450  1884
5451  1885
5452  1886
5453  1887
5454  1888
5455  1889
5456  188A
5457  188B
5458  188C
5459  188D
5460  188E
5461  188F
5462  1890
5463  1891
5464  1892
5465  1893
5466  1894
5467  1895
5468  1896
5469  1897
5470  1898
5471  1899
5472  189A
5473  189B
5474  189C
5475  189D
5476  189E
5477  189F
5478  18A0
5479  18A1
5480  18A2
5481  18A3
5482  18A4
5483  18A5
5484  18A6
5485  18A7
5486  18A8
5487  18A9
5488  18AA
5489  18AB
5490  18AC
5491  18AD
5492  18AE
5493  18AF
5494  18B0
5495  18B1
5496  18B2
5497  18B3
5498  18B4
5499  18B5
5500  18B6
5501  18B7
5502  18B8
5503  18B9
5504  18BA
5505  18BB
5506  18BC
5507  18BD
5508  18BE
5509  18BF
5510  18C0
5511  18C1
5512  18C2
5513  18C3
5514  18C4
5515  18C5
5516  18C6
5517  18C7
5518  18C8
5519  18C9
5520  18CA
5521  18CB
5522  18CC
5523  18CD
5524  18CE
5525  18CF
5526  18D0
5527  18D1
5528  18D2
5529  18D3
5530  18D4
5531  18D5
5532  18D6
5533  18D7
5534  18D8
5535  18D9
5536  18DA
5537  18DB
5538  18DC
5539  18DD
5540  18DE
5541  18DF
5542  18E0
5543  18E1
5544  18E2
5545  18E3
5546  18E4
5547  18E5
5548  18E6
5549  18E7
5550  18E8
5551  18E9
5552  18EA
5553  18EB
5554  18EC
5555  18ED
5556  18EE
5557  18EF
5558  18F0
5559  18F1
5560  18F2
5561  18F3
5562  18F4
5563  18F5
5564  18F6
5565  18F7
5566  18F8
5567  18F9
5568  18FA
5569  18FB
5570  18FC
5571  18FD
5572  18FE
5573  18FF
5574  1900
5575  1901
5576  1902
5577  1903
5578  1904
5579  1905
5580  1906
5581  1907
5582  1908
5583  1909
5584  190A
5585  190B
5586  190C
5587  190D
5588  190E
5589  190F
5590  1910
5591  1911
5592  1912
5593  1913
5594  1914
5595  1915
5596  1916
5597  1917
5598  1918
5599  1919
5600  191A
5601  191B
5602  191C
5603  191D
5604  191E
5605  191F
5606  1920
5607  1921
5608  1922
5609  1923
5610  1924
5611  1925
5612  1926
5613  1927
5614  1928
5615  1929
5616  192A
5617  192B
5618  192C
5619  192D
5620  192E
5621  192F
5622  1930
5623  1931
5624  1932
5625  1933
5626  1934
5627  1935
5628  1936
5629  1937
5630  1938
5631  1939
5632  193A
5633  193B
5634  193C
5635  193D
5636  193E
5637  193F
5638  1940
5639  1941
5640  1942
5641  1943
5642  1944
5643  1945
5644  1946
5645  1947
5646  1948
5647  1949
5648  194A
5649  194B
5650  194C
5651  194D
5652  194E
5653  194F
5654  1950
5655  1951
5656  1952
5657  1953
5658  1954
5659  1955
5660  1956
5661  1957
5662  1958
5663  1959
5664  195A
5665  195B
5666  195C
5667  195D
5668  195E
5669  195F
5670  1960
5671  1961
5672  1962
5673  1963
5674  1964
5675  1965
5676  1966
5677  1967
5678  1968
5679  1969
5680  196A
5681  196B
5682  196C
5683  196D
5684  196E
5685  196F
5686  1970
5687  1971
5688  1972
5689  1973
5690  1974
5691  1975
5692  1976
5693  1977
5694  1978
5695  1979
5696  197A
5697  197B
5698  197C
5699  197D
5700  197E
5701  197F
5702  1980
5703  1981
5704  1982
5705  1983
5706  1984
5707  1985
5708  1986
5709  1987
5710  1988
5711  1989
5712  198A
5713  198B
5714  198C
5715  198D
5716  198E
5717  198F
5718  1990
5719  1991
5720  1992
5721  1993
5722  1994
5723  1995
5724  1996
5725  1997
5726  1998
5727  1999
5728  199A
5729  199B
5730  199C
5731  199D
5732  199E
5733  199F
5734  19A0
5735  19A1
5736  19A2
5737  19A3
5738  19A4
5739  19A5
5740  19A6
5741  19A7
5742  19A8
5743  19A9
5744  19AA
5745  19AB
5746  19AC
5747  19AD
5748  19AE
5749  19AF
5750  19B0
5751  19B1
5752  19B2
5753  19B3
5754  19B4
5755  19B5
5756  19B6
5757  19B7
5758  19B8
5759  19B9
5760  19BA
5761  19BB
5762  19BC
5763  19BD
5764  19BE
5765  19BF
5766  19C0
5767  19C1
5768  19C2
5769  19C3
5770  19C4
5771  19C5
5772  19C6
5773  19C7
5774  19C8
5775  19C9
5776  19CA
5777  19CB
5778  19CC
5779  19CD
5780  19CE
5781  19CF
5782  19D0
5783  19D1
5784  19D2
5785  19D3
5786  19D4
5787  19D5
5788  19D6
5789  19D7
5790  19D8
5791  19D9
5792  19DA
5793  19DB
5794  19DC
5795  19DD
5796  19DE
5797  19DF
5798  19E0
5799  19E1
5800  19E2
5801  19E3
5802  19E4
5803  19E5
5804  19E6
5805  19E7
5806  19E8
5807  19E9
5808  19EA
5809  19EB
5810  19EC
5811  19ED
5812  19EE
5813  19EF
5814  19F0
5815  19F1
5816  19F2
5817  19F3
5818  19F4
5819  19F5
5820  19F6
5821  19F7
5822  19F8
5823  19F9
5824  19FA
5825  19FB
5826  19FC
5827  19FD
5828  19FE
5829  19FF
5830  1A00
5831  1A01
5832  1A02
5833  1A03
5834  1A04
5835  1A05
5836  1A06
5837  1A07
5838  1A08
5839  1A09
5840  1A0A
5841  1A0B
5842  1A0C
5843  1A0D
5844  1A0E
5845  1A0F
5846  1A10
5847  1A11
5848  1A12
5849  1A13
5850  1A14
5851  1A15
5852  1A16
5853  1A17
5854  1A18
5855  1A19
5856  1A1A
5857  1A1B
5858  1A1C
5859  1A1D
5860  1A1E
5861  1A1F
5862  1A20
5863  1A21
5864  1A22
5865  1A23
5866  1A24
5867  1A25
5868  1A26
5869  1A27
5870  1A28
5871  1A29
5872  1A2A
5873  1A2B
5874  1A2C
5875  1A2D
5876  1A2E
5877  1A2F
5878  1A30
5879  1A31
5880  1A32
5881  1A33
5882  1A34
5883  1A35
5884  1A36
5885  1A37
5886  1A38
5887  1A39
5888  1A3A
5889  1A3B
5890  1A3C
5891  1A3D
5892  1A3E
5893  1A3F
5894  1A40
5895  1A41
5896  1A42
5897  1A43
5898  1A44
5899  1A45
5900  1A46
5901  1A47
5902  1A48
5903  1A49
5904  1A4A
5905  1A4B
5906  1A4C
5907  1A4D
5908  1A4E
5909  1A4F
5910  1A50
5911  1A51
5912  1A52
5913  1A53
5914  1A54
5915  1A55
5916  1A56
5917  1A57
5918  1A58
5919  1A59
5920  1A5A
5921  1A5B
5922  1A5C
5923  1A5D
5924  1A5E
5925  1A5F
5926  1A60
5927  1A61
5928  1A62
5929  1A63
5930  1A64
5931  1A65
5932  1A66
5933  1A67
5934  1A68
5935  1A69
5936  1A6A
5937  1A6B
5938  1A6C
5939  1A6D
5940  1A6E
5941  1A6F
5942  1A70
5943  1A71
5944  1A72
5945  1A73
5946  1A74
5947  1A75
5948  1A76
5949  1A77
5950  1A78
5951  1A79
5952  1A7A
5953  1A7B
5954  1A7C
5955  1A7D
5956  1A7E
5957  1A7F
5958  1A80
5959  1A81
5960  1A82
5961  1A83
5962  1A84
5963  1A85
5964  1A86
5965  1A87
5966  1A88
5967  1A89
5968  1A8A
5969  1A8B
5970  1A8C
5971  1A8D
5972  1A8E
5973  1A8F
5974  1A90
5975  1A91
5976  1A92
5977  1A93
5978  1A94
5979  1A95
5980  1A96
5981  1A97
5982  1A98
5983  1A99
5984  1A9A
5985  1A9B
5986  1A9C
5987  1A9D
5988  1A9E
5989  1A9F
5990  1AA0
5991  1AA1
5992  1AA2
5993  1AA3
5994  1AA4
5995  1AA5
5996  1AA6
5997  1AA7
5998  1AA8
5999  1AA9
6000  1AAA
6001  1AAB
6002  1AAC
6003  1AAD
6004  1AAE
6005  1AAF
6006  1AB0
6007  1AB1
6008  1AB2
6009  1AB3
6010  1AB4
6011  1AB5
6012  1AB6
6013  1AB7
6014  1AB8
6015  1AB9
6016  1ABA
6017  1ABB
6018  1ABC
6019  1ABD
6020  1ABE
6021  1ABF
6022  1AC0
6023  1AC1
6024  1AC2
6025  1AC3
6026  1AC4
6027  1AC5
6028  1AC6
6029  1AC7
6030  1AC8
6031  1AC9
6032  1ACA
6033  1ACB
6034  1ACC
6035  1ACD
6036  1ACE
6037  1ACF
6038  1AD0
6039  1AD1
6040  1AD2
6041  1AD3
6042  1AD4
6043  1AD5
6044  1AD6
6045  1AD7
6046  1AD8
6047  1AD9
6048  1ADA
6049  1ADB
6050  1ADC
6051  1ADD
6052  1ADE
6053  1ADF
6054  1AE0
6055  1AE1
6056  1AE2
6057  1AE3
6058  1AE4
6059  1AE5
6060  1AE6
6061  1AE7
6062  1AE8
6063  1AE9
6064  1AEA
6065  1AEB
6066  1AEC
6067  1AED
6068  1AEE
6069  1AEF
6070  1AF0
6071  1AF1
6072  1AF2
6073  1AF3
6074  1AF4
6075  1AF5
6076  1AF6
6077  1AF7
6078  1AF8
6079  1AF9
6080  1AFA
6081  1AFB
6082  1AFC
6083  1AFD
6084  1AFE
6085  1AFF
6086  1B00
6087  1B01
6088  1B02
6089  1B03
6090  1B04
6091  1B05
6092  1B06
6093  1B07
6094  1B08
6095  1B09
6096  1B0A
6097  1B0B
6098  1B0C
6099  1B0D
6100  1B0E
6101  1B0F
6102  1B10
6103  1B11
6104  1B12
6105  1B13
6106  1B14
6107  1B15
6108  1B16
6109  1B17
6110  1B18
6111  1B19
6112  1B1A
6113  1B1B
6114  1B1C
6115  1B1D
6116  1B1E
6117  1B1F
6118  1B20
6119  1B21
6120  1B22
6121  1B23
6122  1B24
6123  1B25
6124  1B26
6125  1B27
6126  1B28
6127  1B29
6128  1B2A
6129  1B2B
6130  1B2C
6131  1B2D
6132  1B2E
6133  1B2F
6134  1B30
6135  1B31
6136  1B32
6137  1B33
6138  1B34
6139  1B35
6140  1B36
6141  1B37
6142  1B38
6143  1B39
6144  1B3A
6145  1B3B
6146  1B3C
6147  1B3D
6148  1B3E
6149  1B3F
6150  1B40
6151  1B41
6152  1B42
6153  1B43
6154  1B44
6155  1B45
6156  1B46
6157  1B47
6158  1B48
6159  1B49
6160  1B4A
6161  1B4B
6162  1B4C
6163  1B4D
6164  1B4E
6165  1B4F
6166  1B50
6167  1B51
6168  1B52
6169  1B53
6170  1B54
6171  1B55
6172  1B56
6173  1B57
6174  1B58
6175  1B59
6176  1B5A
6177  1B5B
6178  1B5C
6179  1B5D
6180  1B5E
6181  1B5F
6182  1B60
6183  1B61
6184  1B62
6185  1B63
6186  1B64
6187  1B65
6188  1B66
6189  1B67
6190  1B68
6191  1B69
6192  1B6A
6193  1B6B
6194  1B6C
6195  1B6D
6196  1B6E
6197  1B6F
6198  1B70
6199  1B71
6200  1B72
6201  1B73
6202  1B74
6203  1B75
6204  1B76
6205  1B77
6206  1B78
6207  1B79
6208  1B7A
6209  1B7B
6210  1B7C
6211  1B7D
6212  1B7E
6213  1B7F
6214  1B80
6215  1B81
6216  1B82
6217  1B83
6218  1B84
6219  1B85
6220  1B86
6221  1B87
6222  1B88
6223  1B89
6224  1B8A
6225  1B8B
6226  1B8C
6227  1B8D
6228  1B8E
6229  1B8F
6230  1B90
6231  1B91
6232  1B92
6233  1B93
6234  1B94
6235  1B95
6236  1B96
6237  1B97
6238  1B98
6239  1B99
6240  1B9A
6241  1B9B
6242  1B9C
6243  1B9D
6244  1B9E
6245  1B9F
6246  1BA0
6247  1BA1
6248  1BA2
6249  1BA3
6250  1BA4
6251  1BA5
6252  1BA6
6253  1BA7
6254  1BA8
6255  1BA9
6256  1BAA
6257  1BAB
6258  1BAC
6259  1BAD
6260  1BAE
6261  1BAF
6262  1BB0
6263  1BB1
6264  1BB2
6265  1BB3
6266  1BB4
6267  1BB5
6268  1BB6
6269  1BB7
6270  1BB8
6271  1BB9
6272  1BBA
6273  1BBB
6274  1BBC
6275  1BBD
6276  1BBE
6277  1BBF
6278  1BC0
6279  1BC1
6280  1BC2
6281  1BC3
6282  1BC4
6283  1BC5
6284  1BC6
6285  1BC7
6286  1BC8
6287  1BC9
6288  1BCA
6289  1BCB
6290  1BCC
6291  1BCD
6292  1BCE
6293  1BCF
6294  1BD0
6295  1BD1
6296  1BD2
6297  1BD3
6298  1BD4
6299  1BD5
6300  1BD6
6301  1BD7
6302  1BD8
6303  1BD9
6304  1BDA
6305  1BDB
6306  1BDC
6307  1BDD
6308  1BDE
6309  1BDF
6310  1BE0
6311  1BE1
6312  1BE2
6313  1BE3
6314  1BE4
6315  1BE5
6316  1BE6
6317  1BE7
6318  1BE8
6319  1BE9
6320  1BEA
6321  1BEB
6322  1BEC
6323  1BED
6324  1BEE
6325  1BEF
6326  1BF0
6327  1BF1
6328  1BF2
6329  1BF3
6330  1BF4
6331  1BF5
6332  1BF6
6333  1BF7
6334  1BF8
6335  1BF9
6336  1BFA
6337  1BFB
6338  1BFC
6339  1BFD
6340  1BFE
6341  1BFF
6342  1C00
6343  1C01
6344  1C02
6345  1C03
6346  1C04
6347  1C05
6348  1C06
6349  1C07
6350  1C08
6351  1C09
6352  1C0A
6353  1C0B
6354  1C0C
6355  1C0D
6356  1C0E
6357  1C0F
6358  1C10
6359  1C11
6360  1C12
6361  1C13
6362  1C14
6363  1C15
6364  1C16
6365  1C17
6366  1C18
6367  1C19
6368  1C1A
6369  1C1B
6370  1C1C
6371  1C1D
6372  1C1E
6373  1C1F
6374  1C20
6375  1C21
6376  1C22
6377  1C23
6378  1C24
6379  1C25
6380  1C26
6381  1C27
6382  1C28
6383  1C29
6384  1C2A
6385  1C2B
6386  1C2C
6387  1C2D
6388  1C2E
6389  1C2F
6390  1C30
6391  1C31
6392  1C32
6393  1C33
6394  1C34
6395  1C35
6396  1C36
6397  1C37
6398  1C38
6399  1C39
6400  1C3A
6401  1C3B
6402  1C3C
6403  1C3D
6404  1C3E
6405  1C3F
6406  1C40
6407  1C41
6408  1C42
6409  1C43
6410  1C44
6411  1C45
6412  1C46
6413  1C47
6414  1C48
6415  1C49
6416  1C4A
6417  1C4B
6418  1C4C
6419  1C4D
6420  1C4E
6421  1C4F
6422  1C50
6423  1C51
6424  1C52
6425  1C53
6426  1C54
6427  1C55
6428  1C56
6429  1C57
6430  1C58
6431  1C59
6432  1C5A
6433  1C5B
6434  1C5C
6435  1C5D
6436  1C5E
6437  1C5F
6438  1C60
6439  1C61
6440  1C62
6441  1C63
6442  1C64
6443  1C65
6444  1C66
6445  1C67
6446  1C68
6447  1C69
6448  1C6A
6449  1C6B
6450  1C6C
6451  1C6D
6452  1C6E
6453  1C6F
6454  1C70
6455  1C71
6456  1C72
6457  1C73
6458  1C74
6459  1C75
6460  1C76
6461  1C77
6462  1C78
6463  1C79
6464  1C7A
6465  1C7B
6466  1C7C
6467  1C7D
6468  1C7E
6469  1C7F
6470  1C80
6471  1C81
6472  1C82
6473  1C83
6474  1C84
6475  1C85
6476  1C86
6477  1C87
6478  1C88
6479  1C89
6480  1C8A
6481  1C8B
6482  1C8C
6483  1C8D
6484  1C8E
6485  1C8F
6486  1C90
6487  1C91
6488  1C92
6489  1C93
6490  1C94
6491  1C95
6492  1C96
6493  1C97
6494  1C98
6495  1C99
6496  1C9A
6497  1C9B
6498  1C9C
6499  1C9D
6500  1C9E
6501  1C9F
6502  1CA0
6503  1CA1
6504  1CA2
6505  1CA3
6506  1CA4
6507  1CA5
6508  1CA6
6509  1CA7
6510  1CA8
6511  1CA9
6512  1CAA
6513  1CAB
6514  1CAC
6515  1CAD
6516  1CAE
6517  1CAF
6518  1CB0
6519  1CB1
6520  1CB2
6521  1CB3
6522  1CB4
6523  1CB5
6524  1CB6
6525  1CB7
6526  1CB8
6527  1CB9
6528  1CBA
6529  1CBB
6530  1CBC
6531  1CBD
6532  1CBE
6533  1CBF
6534  1CC0
6535  1CC1
6536  1CC2
6537  1CC3
6538  1CC4
6539  1CC5
6540  1CC6
6541  1CC7
6542  1CC8
6543  1CC9
6544  1CCA
6545  1CCB
6546  1CCC
6547  1CCD
6548  1CCE
6549  1CCF
6550  1CD0
6551  1CD1
6552  1CD2
6553  1CD3
6554  1CD4
6555  1CD5
6556  1CD6
6557  1CD7
6558  1CD8
6559  1CD9
6560  1CDA
6561  1CDB
6562  1CDC
6563  1CDD
6564  1CDE
6565  1CDF
6566  1CE0
6567  1CE1
6568  1CE2
6569  1CE3
6570  1CE4
6571  1CE5
6572  1CE6
6573  1CE7
6574  1CE8
6575  1CE9
6576  1CEA
6577  1CEB
6578  1CEC
6579  1CED
6580  1CEE
6581  1CEF
6582  1CF0
6583  1CF1
6584  1CF2
6585  1CF3
6586  1CF4
6587  1CF5
6588  1CF6
6589  1CF7
6590  1CF8
6591  1CF9
6592  1CFA
6593  1CFB
6594  1CFC
6595  1CFD
6596  1CFE
6597  1CFF
6598  1D00
6599  1D01
6600  1D02
6601  1D03
6602  1D04
6603  1D05
6604  1D06
6605  1D07
6606  1D08
6607  1D09
6608  1D0A
6609  1D0B
6610  1D0C
6611  1D0D
6612  1D0E
6613  1D0F
6614  1D10
6615  1D11
6616  1D12
6617  1D13
6618  1D14
6619  1D15
6620  1D16
6621  1D17
6622  1D18
6623  1D19
6624  1D1A
6625  1D1B
6626  1D1C
6627  1D1D
6628  1D1E
6629  1D1F
6630  1D20
6631  1D21
6632  1D22
6633  1D23
6634  1D24
6635  1D25
6636  1D26
6637  1D27
6638  1D28
6639  1D29
6640  1D2A
6641  1D2B
6642  1D2C
6643  1D2D
6644  1D2E
6645  1D2F
6646  1D30
6647  1D31
6648  1D32
6649  1D33
6650  1D34
6651  1D35
6652  1D36
6653  1D37
6654  1D38
6655  1D39
6656  1D3A
6657  1D3B
6658  1D3C
6659  1D3D
6660  1D3E
6661  1D3F
6662  1D40
6663  1D41
6664  1D42
6665  1D43
6666  1D44
6667  1D45
6668  1D46
6669  1D47
6670  1D48
6671  1D49
6672  1D4A
6673  1D4B
6674  1D4C
6675  1D4D
6676  1D4E
6677  1D4F
6678  1D50
6679  1D51
6680  1D52
6681  1D53
6682  1D54
6683  1D55
6684  1D56
6685  1D57
6686  1D58
6687  1D59
6688  1D5A
6689  1D5B
6690  1D5C
6691  1D5D
6692  1D5E
6693  1D5F
6694  1D60
6695  1D61
6696  1D62
6697  1D63
6698  1D64
6699  1D65
6700  1D66
6701  1D67
6702  1D68
6703  1D69
6704  1D6A
6705  1D6B
6706  1D6C
6707  1D6D
6708  1D6E
6709  1D6F
6710  1D70
6711  1D71
6712  1D72
6713  1D73
6714  1D74
6715  1D75
6716  1D76
6717  1D77
6718  1D78
6719  1D79
6720  1D7A
6721  1D7B
6722  1D7C
6723  1D7D
6724  1D7E
6725  1D7F
6726  1D80
6727  1D81
6728  1D82
6729  1D83
6730  1D84
6731  1D85
6732  1D86
6733  1D87
6734  1D88
6735  1D89
6736  1D8A
6737  1D8B
6738  1D8C
6739  1D8D
6740  1D8E
6741  1D8F
6742  1D90
6743  1D91
6744  1D92
6745  1D93
6746  1D94
6747  1D95
6748  1D96
6749  1D97
6750  1D98
6751  1D99
6752  1D9A
6753  1D9B
6754  1D9C
6755  1D9D
6756  1D9E
6757  1D9F
6758  1DA0
6759  1DA1
6760  1DA2
6761  1DA3
6762  1DA4
6763  1DA5
6764  1DA6
6765  1DA7
6766  1DA8
6767  1DA9
6768  1DAA
6769  1DAB
6770  1DAC
6771  1DAD
6772  1DAE
6773  1DAF
6774  1DB0
6775  1DB1
6776  1DB2
6777  1DB3
6778  1DB4
6779  1DB5
6780  1DB6
6781  1DB7
6782  1DB8
6783  1DB9
6784  1DBA
6785  1DBB
6786  1DBC
6787  1DBD
6788  1DBE
6789  1DBF
6790  1DC0
6791  1DC1
6792  1DC2
6793  1DC3
6794  1DC4
6795  1DC5
6796  1DC6
6797  1DC7
6798  1DC8
6799  1DC9
6800  1DCA
6801  1DCB
6802  1DCC
6803  1DCD
6804  1DCE
6805  1DCF
6806  1DD0
6807  1DD1
6808  1DD2
6809  1DD3
6810  1DD4
6811  1DD5
6812  1DD6
6813  1DD7
6814  1DD8
6815  1DD9
6816  1DDA
6817  1DDB
6818  1DDC
6819  1DDD
6820  1DDE
6821  1DDF
6822  1DE0
6823  1DE1
6824  1DE2
6825  1DE3
6826  1DE4
6827  1DE5
6828  1DE6
6829  1DE7
6830  1DE8
6831  1DE9
6832  1DEA
6833  1DEB
6834  1DEC
6835  1DED
6836  1DEE
6837  1DEF
6838  1DF0
6839  1DF1
6840  1DF2
6841  1DF3
6842  1DF4
6843  1DF5
6844  1DF6
6845  1DF7
6846  1DF8
6847  1DF9
6848  1DFA
6849  1DFB
6850  1DFC
6851  1DFD
6852  1DFE
6853  1DFF
6854  1E00
6855  1E01
6856  1E02
6857  1E03
6858  1E04
6859  1E05
6860  1E06
6861  1E07
6862  1E08
6863  1E09
6864  1E0A
6865  1E0B
6866  1E0C
6867  1E0D
6868  1E0E
6869  1E0F
6870  1E10
6871  1E11
6872  1E12
6873  1E13
6874  1E14
6875  1E15
6876  1E16
6877  1E17
6878  1E18
6879  1E19
6880  1E1A
6881  1E1B
6882  1E1C
6883  1E1D
6884  1E1E
6885  1E1F
6886  1E20
6887  1E21
6888  1E22
6889  1E23
6890  1E24
6891  1E25
6892  1E26
6893  1E27
6894  1E28
6895  1E29
6896  1E2A
6897  1E2B
6898  1E2C
6899  1E2D
6900  1E2E
6901  1E2F
6902  1E30
6903  1E31
6904  1E32
6905  1E33
6906  1E34
6907  1E35
6908  1E36
6909  1E37
6910  1E38
6911  1E39
6912  1E3A
6913  1E3B
6914  1E3C
6915  1E3D
6916  1E3E
6917  1E3F
6918  1E40
6919  1E41
6920  1E42
6921  1E43
6922  1E44
6923  1E45
6924  1E46
6925  1E47
6926  1E48
6927  1E49
6928  1E4A
6929  1E4B
6930  1E4C
6931  1E4D
6932  1E4E
6933  1E4F
6934  1E50
6935  1E51
6936  1E52
6937  1E53
6938  1E54
6939  1E55
6940  1E56
6941  1E57
6942  1E58
6943  1E59
6944  1E5A
6945  1E5B
6946  1E5C
6947  1E5D
6948  1E5E
6949  1E5F
6950  1E60
6951  1E61
6952  1E62
6953  1E63
6954  1E64
6955  1E65
6956  1E66
6957  1E67
6958  1E68
6959  1E69
6960  1E6A
6961  1E6B
6962  1E6C
6963  1E6D
6964  1E6E
6965  1E6F
6966  1E70
6967  1E71
6968  1E72
6969  1E73
6970  1E74
6971  1E75
6972  1E76
6973  1E77
6974  1E78
6975  1E79
6976  1E7A
6977  1E7B
6978  1E7C
6979  1E7D
6980  1E7E
6981  1E7F
6982  1E80
6983  1E81
6984  1E82
6985  1E83
6986  1E84
6987  1E85
6988  1E86
6989  1E87
6990  1E88
6991  1E89
6992  1E8A
6993  1E8B
6994  1E8C
6995  1E8D
6996  1E8E
6997  1E8F
6998  1E90
6999  1E91
7000  1E92
7001  1E93
7002  1E94
7003  1E95
7004  1E96
7005  1E97
7006  1E98
7007  1E99
7008  1E9A
7009  1E9B
7010  1E9C
7011  1E9D
7012  1E9E
7013  1E9F
7014  1EA0
7015  1EA1
7016  1EA2
7017  1EA3
7018  1EA4
7019  1EA5
7020  1EA6
7021  1EA7
7022  1EA8
7023  1EA9
7024  1EAA
7025  1EAB
7026  1EAC
7027  1EAD
7028  1EAE
7029  1EAF
7030  1EB0
7031  1EB1
7032  1EB2
7033  1EB3
7034  1EB4
7035  1EB5
7036  1EB6
7037  1EB7
7038  1EB8
7039  1EB9
7040  1EBA
7041  1EBB
7042  1EBC
7043  1EBD
7044  1EBE
7045  1EBF
7046  1EC0
7047  1EC1
7048  1EC2
7049  1EC3
7050  1EC4
7051  1EC5
7052  1EC6
7053  1EC7
7054  1EC8
7055  1EC9
7056  1ECA
7057  1ECB
7058  1ECC
7059  1ECD
7060  1ECE
007061  000318        
007062  000319  var hFonts[10] ;
007063  000320  var iSounds[17] ;
007064  000321  var stringsCV[10] := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], hstrings ;
7065  0FB1
7066  0FB2
7067  0FB3
7068  0FB4
7069  0FB5
7070  0FB6
7071  0FB7
7072  0FB8
7073  0FB9
7074  0FBA
7075  0FBB
7076  0FBC
7077  0FBD
7078  0FBE
7079  0FBF
7080  0FC0
7081  0FC1
7082  0FC2
7083  0FC3
7084  0FC4
007085  000322  var scTracebuf[8] ;   // each scope has 8 entries
007086  000323  var scCurpos[1] := [0] ;
7087  0FB3
7088  0FB4
007089  000324  var sc0Oldval1[246], sc0Newval1[246]  ;
007090  000325  var sc0Oldval2[246], sc0Newval2[246]  ;
007091  000326  var sc0Oldval3[246], sc0Newval3[246]  ;
007092  000327  var sc0Oldval4[246], sc0Newval4[246]  ;
007093  000328  // Start P2.inc
007094  000329  var oObjects[MaxTotObjects+1] ;                 // address of objects
007095  000330  var curform ;
007096  000331  var x, y ;
007097  000332  var inputtype, TState, input, object ;
007098  000333  var comRX[40], cmd[CMDLenMAX] ;
007099  000334        
007100  000335  var cs, Ocs ;
007101  000336        
007102  000337  func seroutCS(var op)
007103  000338      serout(op) ;
007104  000339      Ocs ^= op ;
007105  000340  endfunc
007106  000341        
007107  000342  func seroutOcs()
007108  000343      serout(Ocs) ;
007109  000344      Ocs := 0 ;
007110  000345  endfunc
007111  000346        
007112  000347  func TMul(var p1, var p2, var p3)
007113  000348      var var32[2], var322[2] ;
007114  000349      umul_1616(var32, p1, *(input+p2)) ;
007115  000350      umul_1616(var322, var32[1], *(input+p3)) ;
007116  000351      umul_1616(var32, var32[0], *(input+p3)) ;
007117  000352      return(var32[1] + var322[0]) ;
007118  000353  endfunc
007119  000354        
007120  000355  func ReadObject(var ObjectType, var ObjectIdx)
007121  000356      var j, k, Objects ;
007122  000357      Objects := *(oObjects+ObjectType) ;
007123  000358        
007124  000359      seroutCS(REPORT_OBJ) ;
007125  000360      seroutCS(ObjectType) ;
007126  000361      seroutCS(ObjectIdx) ;
007127  000362      j := 2 + ObjectIdx * 2 + Objects ;
007128  000363       if (ObjectType == tForm)
007129  000364          k := curform ;
007130  000365      else if ((ObjectType == tCustomdigits) || (ObjectType == tLeddigits))
007131  000366          k := img_GetWord(hndl, *j, IMAGE_TAG2);
007132  000367      else if (ObjectType == tStrings)
007133  000368          k := stringsCV[ObjectIdx];
007134  000369      else if (ObjectType == tSounds)
007135  000370          k := snd_Playing();             // only a code of 0 is valid, return playing block regardless
007136  000371          else
007137  000372          k := img_GetWord(hndl, *j, IMAGE_INDEX);
007138  000373          if (((ObjectType == tWinButton) || (ObjectType == tAniButton) || (ObjectType == tUserButton) || (ObjectType == t4Dbutton)) && (k)) k := 1 ;
007139  000374      endif
007140  000375      seroutCS(k >> 8) ; // first 8 bits
007141  000376      seroutCS(k) ;
007142  000377      seroutOcs() ;
007143  000378  endfunc
007144  000379        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\Scope4.inc

007145  000380  #inherit "Scope4.inc"
007146  000380  #inherit "Scope4.inc"
007147  000001        
007148  000006             var *old_y4, var *new_y4, var color4  ) // draw a waveform from a table of vertices
007149  000007      var i, k, xstep, yskip;
007150  000008      var x1, y11, y12, y21, y22, y31, y32, y41, y42, x2, oldx1, oldx2, oldy11, oldy12, oldy21, oldy22, oldy31, oldy32, oldy41, oldy42 ;
007151  000009      var flag ;
007152  000010      flag := old_y1[0] + 1 ;
007153  000011      if(num_points < 2) return;
007154  000012        
007155  000013      xstep := 1;
007156  000014      yskip := 1;
007157  000015      if(xmag > 0)  xstep := xmag+1;
007158  000016      if(xmag < 0)  yskip := ABS(xmag-1);
007159  000017      if (Yamp > 200) Yamp := 200;                                                        // max amplitude
007160  000018        
007161  000019      width += left-1 ;
007162  000020      x1 := left ;                                                                        // set first x point
007163  000021      y11 := yzero - (new_y1[0] * Yamp) / 100;                                            // calc first y point
007164  000022      if (old_y2) y21 := yzero - (new_y2[0] * Yamp) / 100;
007165  000023      if (old_y3) y31 := yzero - (new_y3[0] * Yamp) / 100;
007166  000024      if (old_y4) y41 := yzero - (new_y4[0] * Yamp) / 100;
007167  000025      k := 0 ;
007168  000026      i := 0;
007169  000027        
007170  000028      while(1)
007171  000029          y12 := yzero - ( new_y1[(i+yskip)%num_points] * Yamp) / 100;                    // get next sample
007172  000030          if (old_y2) y22 := yzero - ( new_y2[(i+yskip)%num_points] * Yamp) / 100;
007173  000031          if (old_y3) y32 := yzero - ( new_y3[(i+yskip)%num_points] * Yamp) / 100;
007174  000032          if (old_y4) y42 := yzero - ( new_y4[(i+yskip)%num_points] * Yamp) / 100;
007175  000033          x2 := x1 + xstep;                                                               // next point
007176  000034          if ((flag) && (x2 <= width))
007177  000035              gfx_Line(x1, old_y1[k], x2, old_y1[k+1], colorbg );                         // undraw last
007178  000036              if (old_y2) gfx_Line(x1, old_y2[k], x2, old_y2[k+1], colorbg );
007179  000037              if (old_y3) gfx_Line(x1, old_y3[k], x2, old_y3[k+1], colorbg );
007180  000038              if (old_y4) gfx_Line(x1, old_y4[k], x2, old_y4[k+1], colorbg );
007181  000039          endif
007182  000040          old_y1[k] := y11;                                                               // copy new to old
007183  000041          if (old_y2) old_y2[k] := y21;
007184  000042          if (old_y3) old_y3[k] := y31;
007185  000043          if (old_y4) old_y4[k] := y41;
007186  000044          k++ ;
007187  000045        
007188  000046          if(k>1)
007189  000047              gfx_Line(oldx1, oldy11, oldx2, oldy12, color1);                             // draw new
007190  000048              if (old_y2) gfx_Line(oldx1, oldy21, oldx2, oldy22, color2);
007191  000049              if (old_y3) gfx_Line(oldx1, oldy31, oldx2, oldy32, color3);
007192  000050              if (old_y4) gfx_Line(oldx1, oldy41, oldx2, oldy42, color4);
007193  000051          endif
007194  000052          if(x2 > width) break;
007195  000053          oldx1 := x1;
007196  000054          oldx2 := x2;
007197  000055          oldy11 := y11;
007198  000056          oldy12 := y12;                                                                  // back propogate
007199  000057          oldy21 := y21;
007200  000058          oldy22 := y22;
007201  000059          oldy31 := y31;
007202  000060          oldy32 := y32;
007203  000061          oldy41 := y41;
007204  000062          oldy42 := y42;
007205  000063        
007206  000064          y11 := y12;
007207  000065          y21 := y22;
007208  000066          y31 := y32;
007209  000067          y41 := y42;
007210  000068          x1 := x2;                                                                   // next point
007211  000069          i += yskip;
007212  000070          i %= num_points;                                                            // next sample
007213  000071      wend
007214  000072  endfunc
007215  000073        
007216  000074  func Graticule(var x1, var y1, var x2, var y2, var xinc, var yinc, var color)
007217  000075      var y ;
007218  000076      x1 += xinc ;
007219  000077      while (x1 < x2)
007220  000078          y := y1 + yinc ;
007221  000079          while (y < y2)
007222  000080              gfx_PutPixel(x1, y, color) ;
007223  000081              y += yinc ;
007224  000082          wend
007225  000083          x1 += xinc ;
007226  000084      wend
007227  000085  endfunc
007228  000086        
007229  000087        
007230  000381        
007231  000382  #CONST
007232  000408  #END
007233  000409  var told[4], tnew[4] ;
007234  000410        
007235  000411  func addressTraces(var ObjectIdx, var scopeIdx)
007236  000412      var i, j ;
007237  000413      j := ObjectIdx * 8 ;
007238  000414      for (i := 0; i < 4 ; i++)
007239  000415          if (i < OPDataSc[scopeIdx+scTraces])
007240  000416              told[i] := scTracebuf[2*i+j] ;
007241  000417              tnew[i] := scTracebuf[2*i+j+1] ;
007242  000418          else
007243  000419              told[i] := 0 ;
007244  000420              tnew[i] := 0 ;
007245  000421          endif
007246  000422      next
007247  000423  endfunc
007248  000424        
007249  000425  func drawScope(var j)
007250  000426      if (OPDataSc[j+scForm] == curform)
007251  000427          if (OPDataSc[j+scGraticuleVis]) Graticule(OPDataSc[j+scLeft], OPDataSc[j+scTop], OPDataSc[j+scRight], OPDataSc[j+scBottom],
007252  000428                                                    OPDataSc[j+scGraticuleXinc], OPDataSc[j+scGraticuleYinc], OPDataSc[j+scGraticuleCol]) ;
007253  000429          gfx_Scope(OPDataSc[j+scLeft], OPDataSc[j+scWidth], OPDataSc[j+scYZero],
007254  000430                    OPDataSc[j+scDataPoints], OPDataSc[j+scXmag],OPDataSc[j+scYamp], OPDataSc[j+scColor],
007255  000431                    told[0],tnew[0],OPDataSc[j+scTrace1Col], told[1],tnew[1],OPDataSc[j+scTrace2Col],  told[2],tnew[2],OPDataSc[j+scTrace3Col],  told[3],tnew[3],OPDataSc[j+scTrace4Col]
007256  000432                    );
007257  000433          if (OPDataSc[j+scYLineVis]) gfx_Hline(OPDataSc[j+scYLineForm], OPDataSc[j+scLeft], OPDataSc[j+scRight], OPDataSc[j+scYLineCol]) ;
007258  000434      endif
007259  000435  endfunc
007260  000436        
007261  000437  func doScope(var ObjectIdx, var NewVal)
007262  000438      var curarr, curtrace, i, j, *p ;
007263  000439      j := ObjectIdx * SCOPEENTS ;
007264  000440      curarr   := scCurpos[ObjectIdx] / OPDataSc[j+scTraces] ;
007265  000441      curtrace := scCurpos[ObjectIdx] % OPDataSc[j+scTraces] ;
007266  000442      addressTraces(ObjectIdx, j) ;
007267  000443      p := tnew[curtrace] ;
007268  000444      // move trace
007269  000445      mem_Copy(&p[1], &p[0], (OPDataSc[j+scDataPoints]-1)*2);    // this will only work in R35 and above PmmC
007270  000446      p[OPDataSc[j+scDataPoints]-1] := NewVal ;
007271  000447      if (   (curtrace == OPDataSc[j+scTraces]-1)
007272  000448          && (curarr == OPDataSc[j+scRefreshInc]-1 ) ) 
007273  000449          drawScope(j) ;
007274  000450          scCurpos[ObjectIdx] := 0 ;
007275  000451      else
007276  000452          scCurpos[ObjectIdx]++ ;
007277  000453      endif
007278  000454  endfunc
007279  000455        
007280  000456  func WriteObject(var ObjectType, var ObjectIdx, var NewVal)
007281  000457      var i, j, Objects ;
007282  000458      ObjectType &= 0x3f ;
007283  000459      if (ObjectType == tForm)
007284  000460          ActivateForm(ObjectIdx) ;
007285  000461      else if (ObjectType == tScope)
007286  000462          doScope(ObjectIdx, NewVal) ;
007287  000463      else
007288  000464          Objects := *(oObjects+ObjectType)+ObjectIdx*2+2 ;
007289  000465          i := *(Objects) ;
007290  000466          switch (ObjectType)
007291  000467              case tWinButton :
007292  000468                  j := IPControls[oWinButtons[ObjectIdx+1]] ;
007293  000469                  break ;
007294  000470              case t4Dbutton :
007295  000471                  j := IPControls[o4Dbuttons[ObjectIdx+1]] ;
007296  000472                  break ;
007297  000473              default : j := -1 ;
007298  000474          endswitch
007299  000475          if (j != -1) 
007300  000476              if (*(j+IPData+IPD_P2) != -1) TurnOffButtons(*(j+IPData+IPD_P2)) ;
007301  000477              NewVal := NewVal << 1 ;
007302  000478          endif
007303  000479           if (ObjectType == tLeddigits)
007304  000480              img_SetWord(hndl, i , IMAGE_TAG2, NewVal); // where state is 0 to 2
007305  000481              ledDigitsDisplay(i, oLeddigitss, OPDataL) ;
007306  000482          else if (ObjectType == tStrings)
007307  000483              PrintStrings(ObjectIdx, NewVal, 0);
007308  000484          else if (ObjectType == tSounds)
007309  000485              if (!ObjectIdx)
007310  000486                  file_PlayWAV(iSounds[NewVal]);
007311  000487              else if (ObjectIdx == 1)
007312  000488                  snd_Volume(NewVal) ;
007313  000489              else if (ObjectIdx == 2)
007314  000490                  snd_Pause() ;
007315  000491              else if (ObjectIdx == 3)
007316  000492                  snd_Continue() ;
007317  000493              else if (ObjectIdx == 4)
007318  000494                  snd_Stop() ;
007319  000495              endif
007320  000496          else
007321  000497              img_SetWord(hndl, i , IMAGE_INDEX, NewVal); // where state is 0 to 2
007322  000498              img_Show(hndl, i) ; // will only display if form is current
007323  000499          endif
007324  000500      endif
007325  000501  endfunc
007326  000502        
007327  000503  func TurnOffButtons(var group)
007328  000504      var j, k, l;
007329  000505      for (j := 0; j < nInputs; j++)
007330  000506          k := j*IPDatasize ;
007331  000507          if (*(IPData+k+IPD_P2) == group)
007332  000508              l := -1 ;
007333  000509               if (*(IPData+k) == t4Dbutton)
007334  000510                  l := o4Dbuttons[*(IPData+k+IPD_OBJVidx)/2] ;
007335  000511                  img_SetWord(hndl, l, IMAGE_INDEX, 0);
007336  000512                  img_Show(hndl, l);      // only shows on current form
007337  000513              else if (*(IPData+k) == tWinButton)
007338  000514                  l := oWinButtons[*(IPData+k+IPD_OBJVidx)/2] ;
007339  000515                  img_SetWord(hndl, l, IMAGE_INDEX, 0);
007340  000516                  img_Show(hndl, l);      // only shows on current form
007341  000517              endif
007342  000518          endif
007343  000519      next
007344  000520  endfunc
007345  000521        
007346  000522        
007347  000523  // WARNING, this code will crash if newval exceeds maximum displayable number
007348  000524  func ledDigitsDisplay(var imgidx, var typeptr, var setptr)
007349  000525      var i, j, k, l, lb, newval ;
007350  000526      if (!((img_GetWord(hndl, imgidx, IMAGE_FLAGS) & I_ENABLED))) return ;  // ;img_GetWord(hndl, imgidx, IMAGE_TAG2) ;if diabled then exit
007351  000527      newval := img_GetWord(hndl, imgidx, IMAGE_TAG2) ;
007352  000528      i := -1 ;
007353  000529      j := *(typeptr) ;
007354  000530      repeat
007355  000531          typeptr += 2 ;
007356  000532          i++ ;
007357  000533          until (*(typeptr) == imgidx);
007358  000534      j := setptr + i*10 ;
007359  000535        
007360  000536      imgidx++ ;
007361  000537      l := 1 ;
007362  000538      for (i := 1; i < *(j+iDigits); i++)
007363  000539          l *= 10 ;
007364  000540      next
007365  000541      lb := *(j+iLeadingBlanks) ;
007366  000542      for (i := 0; i < *(j+iDigits); i++)
007367  000543          k := newval / l ;
007368  000544          newval -= k * l ;
007369  000545          if ( lb && (i < *(j+iDigits) - *(j+iMinDigits)) )
007370  000546              if (k == 0)
007371  000547                  k := 10 ;
007372  000548              else
007373  000549                  lb := 0 ;
007374  000550              endif
007375  000551          endif
007376  000552          l /= 10 ;
007377  000553          img_SetWord(hndl, imgidx, IMAGE_INDEX, k);
007378  000554          img_SetWord(hndl, imgidx, IMAGE_XPOS, *(j+ileft)+i* *(j+iWidthDigit)) ;
007379  000555          img_Show(hndl, imgidx);
007380  000556      next
007381  000557  endfunc
007382  000558        
007383  000559        
007384  000560  func ActivateForm(var newform)
007385  000561      var i, j, *p ;
007386  000562      if (curform != -1) // deactivate old form, by disabling all inputs
007387  000563          for (i := formstidx[curform]; i <= formenidx[curform]; i++)
007388  000564              if (img_GetWord(hndl, i, IMAGE_TAG))
007389  000565                  img_Disable(hndl,i) ;
007390  000566              endif
007391  000567          next
007392  000568      endif
007393  000569      curform := newform ;
007394  000570      // display newform image or clear to image color
007395  000571      if (formBGcol[curform] != BGIMAGE)
007396  000572          gfx_Set(BACKGROUND_COLOUR,formBGcol[curform]);
007397  000573          gfx_Cls() ;
007398  000574          DoGFXObjects() ;                                    // display GFX 'widgets'
007399  000575      endif
007400  000576        
007401  000577      // enable inputs
007402  000578      for (i := formstidx[curform]; i < formenidx[curform]; i++)
007403  000579          j := img_GetWord(hndl, i, IMAGE_TAG) ;
007404  000580          if (j)
007405  000581              j-- ;
007406  000582              img_SetAttributes(hndl, i, I_STAYONTOP+I_ENABLED);        // make sure this is on top of form, if applicable
007407  000583              //if (j != tKeyboard)
007408  000584              if ((j <= tWinButton) || (j >= t4Dbutton) )               // enable inputs
007409  000585                  img_ClearAttributes(hndl, i, I_TOUCH_DISABLE);        // ensure touch is enabled
007410  000586              endif
007411  000587              img_Show(hndl,i) ; // show initialy, if required
007412  000588              if (j == tForm)
007413  000589                  DoGFXObjects() ;                                    // display GFX 'widgets' for image backgruobds
007414  000590              else if (j == tLeddigits)
007415  000591                  ledDigitsDisplay(i, oLeddigitss, OPDataL) ;
007416  000592              endif
007417  000593          endif
007418  000594      next
007419  000595      for (i := 0; i < oStringss[0]; i++)
007420  000596          if (stringsCV[i] != -1)
007421  000597              WriteObject(tStrings, i, stringsCV[i]) ;
007422  000598          endif
007423  000599      next
007424  000600      for (i := 0; i < oScopes[0]; i++)
007425  000601          j := i * SCOPEENTS ;
007426  000602          if (OPDataSc[j+scForm] == curform)
007427  000603              addressTraces(i,j) ;
007428  000604              p := told[0] ;
007429  000605              p[0] := -1 ; // force init scope
007430  000606              gfx_RectangleFilled(OPDataSc[j+scLeft], OPDataSc[j+scTop], OPDataSc[j+scRight], OPDataSc[j+scBottom], OPDataSc[j+scColor]) ;
007431  000607              if (OPDataSc[j+scGraticuleVis]) Graticule(OPDataSc[j+scLeft], OPDataSc[j+scTop], OPDataSc[j+scRight], OPDataSc[j+scBottom],
007432  000608                                                        OPDataSc[j+scGraticuleXinc], OPDataSc[j+scGraticuleYinc], OPDataSc[j+scGraticuleCol]) ;
007433  000609              drawScope(i*SCOPEENTS) ;    // draw scope when activating form, may look a bit first time up....
007434  000610              if (OPDataSc[j+scYLineVis]) gfx_Hline(OPDataSc[j+scYLineForm], OPDataSc[j+scLeft], OPDataSc[j+scRight], OPDataSc[j+scYLineCol]) ;
007435  000611          endif
007436  000612      next
007437  000613  endfunc
007438  000614        
007439  000615  func UpdateObjects(var newval)
007440  000616      var IPidx, otherOBJ ;
007441  000617      if ( ( img_GetWord(hndl, *(object), IMAGE_INDEX) != newval) || (TState == IPD_RELEASE) ) // only bother if values changed, or release
007442  000618        
007443  000619          img_SetWord(hndl, *(object), IMAGE_INDEX, newval);
007444  000620              img_Show(hndl, *(object));      // only shows on current form
007445  000621          if (((inputtype == t4Dbutton) || (inputtype == tUserButton) || (inputtype == tWinButton) || (inputtype == tAniButton) )&& (newval > 1)) newval := 1;
007446  000622          IPidx := *(input+TState) ;
007447  000623          while(IPidx != 0)
007448  000624              otherOBJ := IPidx + IPData;
007449  000625              if (*(otherOBJ) == OT_REPORT)
007450  000626                  seroutCS(REPORT_EVENT) ;
007451  000627                  seroutCS(inputtype) ;
007452  000628                  seroutCS(*(otherOBJ+IPD_OBJVidx)) ;
007453  000629                  seroutCS(newval >> 8) ;
007454  000630                  seroutCS(newval) ;
007455  000631                  seroutOcs() ;
007456  000632              else if (TState == *(otherOBJ+IPD_P4))
007457  000633                  if (*(otherOBJ) == OT_ACTIVATE)
007458  000634                      ActivateForm(*(otherOBJ+IPD_P2) ) ;
007459  000635                      inputtype := tForm ;
007460  000636                  else if (*(otherOBJ) == OT_SETCONST)
007461  000637                      newval := *(otherOBJ+IPD_P3) ;
007462  000638                      WriteObject(*(otherOBJ+IPD_P1), *(otherOBJ+IPD_P2), newval) ;
007463  000639                  else if (*(otherOBJ) == OT_SETANOTHER)
007464  000640                      WriteObject(*(otherOBJ+IPD_P1), *(otherOBJ+IPD_P2), newval) ;
007465  000641                  else if (*(otherOBJ) == OT_PREVFRAME)
007466  000642                      if (img_GetWord(hndl, *(otherOBJ+IPD_P6), IMAGE_INDEX))
007467  000643                          WriteObject(*(otherOBJ+IPD_P5),*(otherOBJ+IPD_P2),img_GetWord(hndl, *(otherOBJ+IPD_P6), IMAGE_INDEX)-1) ;
007468  000644                      endif
007469  000645                      newval := img_GetWord(hndl, *(otherOBJ+IPD_P6), IMAGE_INDEX) ;
007470  000646                  else if (*(otherOBJ) == OT_NEXTFRAME)
007471  000647                      if (img_GetWord(hndl, *(otherOBJ+IPD_P6), IMAGE_INDEX) < *(otherOBJ+IPD_P3)) 
007472  000648                          WriteObject(*(otherOBJ+IPD_P5),*(otherOBJ+IPD_P2),img_GetWord(hndl, *(otherOBJ+IPD_P6), IMAGE_INDEX)+1) ;
007473  000649                      endif
007474  000650                      newval := img_GetWord(hndl, *(otherOBJ+IPD_P6), IMAGE_INDEX) ;
007475  000651                  else if (*(otherOBJ) == OT_PREVSTRING)
007476  000652                      if (stringsCV[*(otherOBJ+IPD_P2)])
007477  000653                          WriteObject(tStrings,*(otherOBJ+IPD_P2),stringsCV[*(otherOBJ+IPD_P2)]-1) ;
007478  000654                      endif
007479  000655                  else if (*(otherOBJ) == OT_NEXTSTRING)
007480  000656                      if (stringsCV[*(otherOBJ+IPD_P2)] < *(otherOBJ+IPD_P3)) // fix IPD_P2 not filled in yet
007481  000657                          WriteObject(tStrings,*(otherOBJ+IPD_P2),stringsCV[*(otherOBJ+IPD_P2)]+1) ;
007482  000658                      endif
007483  000659                  endif
007484  000660              endif
007485  000661              IPidx := *(otherOBJ+TState) ;
007486  000662          wend
007487  000663      endif
007488  000664  endfunc
007489  000665        
007490  000666  // End P2.inc
007491  000667  func DoGFXObjects()
007492  000668  endfunc
007493  000669        
007494  000670  // Start P3.inc
007495  000671  func main()
007496  000672      var comTX[50], cmdi, i, j, n, state, oldn ;
007497  000673      putstr("Mounting...\n");
007498  000674      if (!(disk:=file_Mount()))
007499  000675          while(!(disk :=file_Mount()))
007500  000676              putstr("Drive not mounted...");
007501  000677              pause(200);
007502  000678              gfx_Cls();
007503  000679              pause(200);
007504  000680          wend
007505  000681      endif
007506  000682  //    gfx_MoveTo(0, 0);
007507  000683  //    print(mem_Heap()," ") ;
007508  000684  //    gfx_TransparentColour(0x0020);
007509  000685  //    gfx_Transparency(ON);
007510  000686        
007511  000687      gfx_ScreenMode(LANDSCAPE) ;
007512  000688        
007513  000689      // open image control
007514  000690      hndl := file_LoadImageControl("MCTRL_~1.dat", "MCTRL_~1.gci", 1);
007515  000691        
007516  000692      // init 'constants'
007517  000693  // End P3.inc
007518  000694        
007519  000695      oObjects[tDipSwitch] := oDipSwitchs ;
007520  000696      oObjects[tKnob] := oKnobs ;
007521  000697      oObjects[tRockerSwitch] := oRockerSwitchs ;
007522  000698      oObjects[tRotarySwitch] := oRotarySwitchs ;
007523  000699      oObjects[tGSlider] := oGSliders ;
007524  000700      oObjects[tTrackbar] := oTrackbars ;
007525  000701      oObjects[tWinButton] := oWinButtons ;
007526  000702      oObjects[tAngularmeter] := oAngularmeters ;
007527  000703      oObjects[tCoolgauge] := oCoolgauges ;
007528  000704      oObjects[tCustomdigits] := oCustomdigitss ;
007529  000705      oObjects[tForm] := oForms ;
007530  000706      oObjects[tGauge] := oGauges ;
007531  000707      oObjects[tImage] := oImages ;
007532  000708      oObjects[tKeyboard] := oKeyboards ;
007533  000709      oObjects[tLed] := oLeds ;
007534  000710      oObjects[tLeddigits] := oLeddigitss ;
007535  000711      oObjects[tMeter] := oMeters ;
007536  000712      oObjects[tStrings] := oStringss ;
007537  000713      oObjects[tThermometer] := oThermometers ;
007538  000714      oObjects[tUserled] := oUserleds ;
007539  000715      oObjects[tVideo] := oVideos ;
007540  000716      oObjects[tStaticText] := oStaticTexts ;
007541  000717      oObjects[tSounds] := oSoundss ;
007542  000718      oObjects[tTimer] := oTimers ;
007543  000719      oObjects[tSpectrum] := oSpectrums ;
007544  000720      oObjects[tTank] := oTanks ;
007545  000721      oObjects[tUserImages] := oUserImagess ;
007546  000722      oObjects[tPinOutput] := oPinOutputs ;
007547  000723      oObjects[tPinInput] := oPinInputs ;
007548  000724      oObjects[t4Dbutton] := o4Dbuttons ;
007549  000725      oObjects[tAniButton] := oAniButtons ;
007550  000726      oObjects[tColorPicker] := oColorPickers ;
007551  000727      oObjects[tUserButton] := oUserButtons ;
007552  000728      iSounds[0] := Sounds ;
007553  000729      iSounds[1] := Sounds + 13 ;
007554  000730      iSounds[2] := Sounds + 26 ;
007555  000731      iSounds[3] := Sounds + 39 ;
007556  000732      iSounds[4] := Sounds + 52 ;
007557  000733      iSounds[5] := Sounds + 65 ;
007558  000734      iSounds[6] := Sounds + 78 ;
007559  000735      iSounds[7] := Sounds + 91 ;
007560  000736      iSounds[8] := Sounds + 104 ;
007561  000737      iSounds[9] := Sounds + 117 ;
007562  000738      iSounds[10] := Sounds + 130 ;
007563  000739      iSounds[11] := Sounds + 143 ;
007564  000740      iSounds[12] := Sounds + 155 ;
007565  000741      iSounds[13] := Sounds + 168 ;
007566  000742      iSounds[14] := Sounds + 181 ;
007567  000743      iSounds[15] := Sounds + 192 ;
007568  000744      iSounds[16] := Sounds + 200 ;
007569  000745      hFonts[0] := file_LoadImageControl("MCTRL_~1.da2", "MCTRL_~1.gc2", 1)  ;
007570  000746      hFonts[1] := file_LoadImageControl("MCTRL_~1.da1", "MCTRL_~1.gc1", 1)  ;
007571  000747      hFonts[2] := FONT3 ;
007572  000748      hFonts[3] := file_LoadImageControl("MCTRL_~1.da5", "MCTRL_~1.gc5", 1)  ;
007573  000749      hFonts[4] := file_LoadImageControl("MCTRL_~1.da6", "MCTRL_~1.gc6", 1)  ;
007574  000750      hFonts[5] := file_LoadImageControl("MCTRL_~1.da7", "MCTRL_~1.gc7", 1)  ;
007575  000751      hFonts[6] := FONT3 ;
007576  000752      hFonts[8] := FONT3 ;
007577  000753      hFonts[7] := hFonts[0] ;
007578  000754      hFonts[9] := hFonts[0] ;
007579  000755      sc0Oldval1[0] := -1 ; // init scope, only needed for first trace
007580  000756      scTracebuf[0] := sc0Oldval1 ;
007581  000757      scTracebuf[1] := sc0Newval1 ;
007582  000758      scTracebuf[2] := sc0Oldval2 ;
007583  000759      scTracebuf[3] := sc0Newval2 ;
007584  000760      scTracebuf[4] := sc0Oldval3 ;
007585  000761      scTracebuf[5] := sc0Newval3 ;
007586  000762      scTracebuf[6] := sc0Oldval4 ;
007587  000763      scTracebuf[7] := sc0Newval4 ;
007588  000764  // Start P4.inc
007589  000765      hstrings := file_Open("MCTRL_~1.txf", 'r') ; // Open handle to access uSD strings, uncomment if required
007590  000766      // init comms
007591  000767      com_Init(comRX,CMDLenMAX,0);
007592  000768      com_SetBaud(COM0,11520);
007593  000769      com_TXbuffer(comTX, 100, 0);
007594  000770      // tag 'real' objects
007595  000771      for (i := 0; i <= MaxTotObjects; i++)
007596  000772          if (   (i != tSounds)
007597  000773              && (i != tTimer)
007598  000774              && (i != tPinOutput)
007599  000775              && (i != tPinInput) )
007600  000776              x := oObjects[i] ;
007601  000777              y := *(x) ;
007602  000778              for (n := 1; n <= y; n++)
007603  000779                  oldn := *(x+n*2) ;
007604  000780                  img_SetAttributes(hndl, oldn, I_TOUCH_DISABLE);  // ensure touch is enabled
007605  000781                  if (oldn != -1)
007606  000782                      img_SetWord(hndl, oldn, IMAGE_TAG, i+1);
007607  000783                      img_Disable(hndl, oldn) ;
007608  000784                  endif
007609  000785              next
007610  000786          endif
007611  000787      next
007612  000788        
007613  000789      // display initial form
007614  000790      curform := -1 ;
007615  000791      ActivateForm(0) ; // need to change this according to first actual form
007616  000792  // End P4.inc
007617  000793      WriteObject(5, 1, 32) ; // init volume control
007618  000794      WriteObject(5, 1, 32) ; // init volume control
007619  000795  // Start P5.inc
007620  000796      touch_Set(TOUCH_ENABLE);                            // enable the touch screen
007621  000797      oldn := -1 ;
007622  000798      repeat
007623  000799          // check comms for command, how to NAK invalid command
007624  000800          if (com_Count() != 0)
007625  000801              i := serin() ;
007626  000802              cs ^= i ;               // update checksum
007627  000803              if (   (cmdi > 2)
007628  000804                  && (cmd[0] == WRITE_STRU) )
007629  000805                  j := (cmdi-1) >> 1 + 2 ;
007630  000806                  if (j == CMDLenMAX)    // max length exceeded
007631  000807                      serout(NAK) ;
007632  000808                      cs := 0 ;
007633  000809                      cmdi := -1 ;
007634  000810                  else if (cmdi & 1)
007635  000811                      cmd[j] := i ;
007636  000812                      if (cmd[2] == 0)    // if string complete
007637  000813                          if (cs)
007638  000814                              serout(NAK) ;
007639  000815                              cs := 0 ;
007640  000816                          else
007641  000817                              cmd[j] := 0 ;                     // terminate it
007642  000818                              PrintStrings(cmd[1], &cmd[3], 1) ;
007643  000819                              serout(ACK) ;
007644  000820                          endif
007645  000821                          cmdi := -1 ;
007646  000822                      endif
007647  000823                  else
007648  000824                      cmd[j] := cmd[j] << 8 + i ;
007649  000825                      cmd[2]-- ;          // dec length
007650  000826                  endif
007651  000827                  cmdi++ ;
007652  000828              else // not unicode string
007653  000829                  cmd[cmdi++] := i ;
007654  000830                   if (cmd[0] == WRITE_STR)        // ansi string
007655  000831                      if (cmdi == CMDLenMAX)      // max length exceeded
007656  000832                          serout(NAK) ;
007657  000833                          cs := 0 ;
007658  000834                          cmdi := 0 ;
007659  000835                      else if (cmdi > 2)
007660  000836                          if (cmd[2] == -1)
007661  000837                              if (cs)
007662  000838                                  serout(NAK) ;
007663  000839                                  cs := 0 ;
007664  000840                              else
007665  000841                                  cmd[cmdi-1] := 0 ;                     // terminate it
007666  000842                                  PrintStrings(cmd[1], &cmd[3], 1) ;
007667  000843                                  serout(ACK) ;
007668  000844                              endif
007669  000845                              cmdi := 0 ;
007670  000846                          else
007671  000847                              cmd[2]-- ;          // dec length
007672  000848                          endif
007673  000849                      endif
007674  000850                  else if (   (cmd[0] == READ_OBJ)
007675  000851                           && (cmdi == 4)         )
007676  000852                      if (cs)
007677  000853                          serout(NAK) ;
007678  000854                          cs := 0 ;
007679  000855                      else
007680  000856                          ReadObject(cmd[1], cmd[2]) ;
007681  000857                      endif
007682  000858                      cmdi := 0 ;
007683  000859                  else if (   (cmd[0] == WRITE_OBJ)    // 6 byte write command (gen option)
007684  000860                           && (cmdi == 6)          )
007685  000861                      if (cs)
007686  000862                          serout(NAK) ;
007687  000863                          cs := 0 ;
007688  000864                      else
007689  000865                          WriteObject(cmd[1], cmd[2], cmd[3] << 8 + cmd[4]) ;
007690  000866                          serout(ACK) ;
007691  000867                      endif
007692  000868                      cmdi := 0 ;
007693  000869                  else if (   (cmd[0] == WRITE_CONTRAST)
007694  000870                           && (cmdi == 3)         )
007695  000871                      if (cs)
007696  000872                          serout(NAK) ;
007697  000873                          cs := 0 ;
007698  000874                      else
007699  000875                          gfx_Contrast(cmd[1]) ;
007700  000876                          serout(ACK) ;
007701  000877                      endif
007702  000878                      cmdi := 0 ;
007703  000879                  else if (cmdi == 6)    // we have 6 bytes and we've gotten here -> something wrong
007704  000880                      serout(NAK) ;
007705  000881                      cs := 0 ;
007706  000882                      cmdi := 0 ;
007707  000883                  endif
007708  000884              endif   // not unicode string
007709  000885          endif   // a character is available
007710  000886        
007711  000887        
007712  000888      // touch code processing
007713  000889        
007714  000890          state := touch_Get(TOUCH_STATUS);               // get touchscreen status
007715  000891          n := img_Touched(hndl,-1) ;
007716  000892          if ((state == TOUCH_PRESSED) || (state == TOUCH_RELEASED) || (state == TOUCH_MOVING))
007717  000893              if ((state != TOUCH_RELEASED) && (n != oldn) && (oldn != -1)) 
007718  000894                  state := TOUCH_RELEASED ;       // simulate release if we move off object
007719  000895              endif
007720  000896              if (state != TOUCH_RELEASED)        // if not released
007721  000897                  if (oldn != -1) 
007722  000898                      n := oldn ;
007723  000899                  else 
007724  000900                      oldn := n ;
007725  000901                      state := TOUCH_PRESSED ;
007726  000902                  endif
007727  000903                  x  := touch_Get(TOUCH_GETX);
007728  000904                  y  := touch_Get(TOUCH_GETY);
007729  000905                  TState := IPD_DOWN ;
007730  000906              else
007731  000907                  n := oldn ;                     // simulate release of what we touched
007732  000908                  oldn := -1 ;                    // prevent double release
007733  000909                  TState := IPD_RELEASE ;
007734  000910              endif
007735  000911              if (n != -1)
007736  000912                          input := IPControls[n] + IPData;
007737  000913                          inputtype := *(input) ;
007738  000914                          i := inputtype ;
007739  000915                          if (inputtype >= t4Dbutton) i -= 23 ; // adjust to ensure next in gosub
007740  000916                          gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
007741  000917              endif
007742  000918          endif
007743  000919   //       if ((n != -1) && (oldn == -1)) oldn := n ;    // save what we touched in case we move off it
007744  000920        
007745  000921          sys_EventsResume() ;
007746  000922      forever
007747  000923        
007748  000924  cDipswitch:
007749  000925        
007750  000926  cKnob:
007751  000927      i := XYposToDegree(x-*(input+IPD_P1),      // x - CentreX
007752  000928                         y-*(input+IPD_P2)) ;    // y - centreY
007753  000929      if (i < *(input+IPD_P3))                   // anything in the first 'dead zone' is minvalue
007754  000930          i := 0 ;
007755  000931      else
007756  000932          if (i > *(input+IPD_P4))               // anything in the last 'dead zone' is maxvalue
007757  000933              i := *(input+IPD_P5) ;
007758  000934          else
007759  000935              i -= *(input+IPD_P3) ;             // offset by -baseangle
007760  000936          endif
007761  000937      endif
007762  000938  //  i := i * *(input+IPD_P6) / *(input+IPD_P5) ;   // convert degrees to position
007763  000939      i := TMul(i, IPD_P6, IPD_P7) ;   // convert degrees to position
007764  000940      object := oKnobs + *(input+IPD_OBJVidx) ;
007765  000941      UpdateObjects(i) ;
007766  000942  endsub ;
007767  000943        
007768  000944  cRockerswitch:
007769  000945        
007770  000946  cRotaryswitch:
007771  000947        
007772  000948  cSlider:
007773  000949  cTrackbar:
007774  000950      if (*(input+IPD_P1))
007775  000951          i := x - *(input+IPD_P2) ;
007776  000952          if (i < 0)
007777  000953              i := 0 ;
007778  000954          else if (i > *(input+IPD_P3))        // height/width - 17)
007779  000955              i := *(input+IPD_P4) ;           // maxvalue-minvalue
007780  000956          else
007781  000957  //            i := *(input+IPD_P4) * i / *(input+IPD_P3) ;    // max-min - (max-min) * posn / (height-17)
007782  000958              i := TMul(i, IPD_P4, IPD_P5) ;    // max-min - (max-min) * posn / (height-17)
007783  000959          endif
007784  000960      else
007785  000961          i := y - *(input+IPD_P2) ;
007786  000962          if (i < 0)
007787  000963              i := *(input+IPD_P4) ;           // maxvalue-minvalue
007788  000964          else if (i > *(input+IPD_P3))        // height/width - 17)
007789  000965              i := 0 ;
007790  000966          else
007791  000967  //            i := *(input+IPD_P4) - *(input+IPD_P4) * i / *(input+IPD_P3) ;    // max-min - (max-min) * posn / (height-17)
007792  000968              i := *(input+IPD_P4) - TMul(i, IPD_P4, IPD_P5) ;    // max-min - (max-min) * posn / (height-17)
007793  000969          endif
007794  000970      endif
007795  000971      if (inputtype == tGSlider)
007796  000972          object := oGSliders ;
007797  000973      else
007798  000974          object := oTrackbars ;
007799  000975      endif
007800  000976      object += *(input+IPD_OBJVidx) ;
007801  000977      UpdateObjects(i) ;
007802  000978  endsub ;
007803  000979        
007804  000980  c4DButton:
007805  000981      object := o4Dbuttons + *(input+IPD_OBJVidx) ;
007806  000982      goto gbutton ;
007807  000983  cUserButton:
007808  000984  cWinbutton:
007809  000985      object := oWinButtons + *(input+IPD_OBJVidx) ;
007810  000986  gbutton:
007811  000987      if (*(input+IPD_P1))                                 // momentary, reports 0, but should report 1
007812  000988          if (state == TOUCH_RELEASED)
007813  000989              i := 0 ;
007814  000990              TState == IPD_DOWN ;
007815  000991          else
007816  000992              i := 1 ;
007817  000993              TState == IPD_RELEASE ;
007818  000994          endif
007819  000995      else if (*(input+IPD_P2) == -1)                      // Toggle, reports 0+2, but should report 0+1
007820  000996          i := img_GetWord(hndl, *(object), IMAGE_INDEX) ; // current state
007821  000997          if (state == TOUCH_RELEASED)                     // only truly change on release
007822  000998              i := ++i & 3 ;
007823  000999          else
007824  001000              i |= 1 ;                                      // make down regardless of current state
007825  001001          endif
007826  001002      else                        // group action, up all other buttons on touch press, reports 0 for button down
007827  001003          if (state == TOUCH_PRESSED)                     // only truly change on release
007828  001004              TurnOffButtons(*(input+IPD_P2)) ;
007829  001005          endif
007830  001006      i := 2 ;
007831  001007      endif
007832  001008        
007833  001009      UpdateObjects(i) ;
007834  001010  endsub ;
007835  001011        
007836  001012  cAniButton:
007837  001013        
007838  001014  cColorPicker:
007839  001015        
007840  001016  endfunc
007841  001017  // End P5.inc
Notice: local var 'i' in func 'doScope' is never used (line 438 file:MCTRL_REV2.4DGenieS)


Symbol Table:
name                 decimal    hex
_1F                                  -40  0xffffffd8 (PmmC func) args[0] r=0  (not used)
__MAXMEM                           14400  0x00003840 (const dword)  (usage 1)
__MAXPROG                          14400  0x00003840 (const dword)  (usage 1)
__PLATFORM                             1  0x00000001 (const dword)  (not used)
ABS                                  -13  0xfffffff3 (PmmC func) args[1] r=1  (usage 9)
ACK                                    6  0x00000006 (const dword)  (usage 12)
ActivateForm                        7328  0x00001ca0 (User func) args[1] r=0  (usage 9)
addressTraces                       9439  0x000024df (User func) args[2] r=0  (usage 6)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ALL                                65535  0x0000ffff (const dword)  (not used)
ANITIMERS                              0  0x00000000 (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (usage 18)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
arctan                                 7  0x00000007arctan                                 7  0x00000007 (mem) byte[101] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
AUDIO_ENABLE                           7  0x00000007 (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (usage 3)
BACKLITE                               6  0x00000006 (const dword)  (not used)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (not used)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
BGIMAGE                               32  0x00000020 (const dword)  (usage 12)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
BLACK                                  0  0x00000000 (const dword)  (usage 33)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (usage 3)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
BUS_0                                  8  0x00000008 (const dword)  (not used)
BUS_1                                  9  0x00000009 (const dword)  (not used)
BUS_2                                 10  0x0000000a (const dword)  (not used)
BUS_3                                 11  0x0000000b (const dword)  (not used)
BUS_4                                 12  0x0000000c (const dword)  (not used)
BUS_5                                 13  0x0000000d (const dword)  (not used)
BUS_6                                 14  0x0000000e (const dword)  (not used)
BUS_7                                 15  0x0000000f (const dword)  (not used)
bus_In                               -45  0xffffffd3 (PmmC func) args[0] r=1  (not used)
bus_Out                              -46  0xffffffd2 (PmmC func) args[1] r=0  (not used)
BUS_RD_PIN                             4  0x00000004 (const dword)  (not used)
bus_Read                             -49  0xffffffcf (PmmC func) args[0] r=1  (not used)
bus_Set                              -47  0xffffffd1 (PmmC func) args[1] r=0  (not used)
BUS_WR_PIN                             5  0x00000005 (const dword)  (not used)
bus_Write                            -48  0xffffffd0 (PmmC func) args[1] r=0  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                            -215  0xffffff29 (PmmC func) args[1] r=1  (not used)
c4DButton                         UNRESOLVED  (not used)
C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS    2710  0x00000a96 (const ??? 0)  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
cAniButton                        UNRESOLVED  (not used)
cColorPicker                      UNRESOLVED  (not used)
cDipswitch                        UNRESOLVED  (not used)
charheight                          -159  0xffffff61 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                           -158  0xffffff62 (PmmC func) args[1] r=1  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
CKMODE_0                               0  0x00000000 (const dword)  (not used)
CKMODE_1                               1  0x00000001 (const dword)  (not used)
CKMODE_2                               2  0x00000002 (const dword)  (not used)
CKMODE_3                               3  0x00000003 (const dword)  (not used)
cKnob                             UNRESOLVED  (not used)
CLIPPING                              19  0x00000013 (const dword)  (not used)
cmd                                 4196  0x00001064 (mem) word[80] (global)  (usage 78)
CMDLenMAX                             80  0x00000050 (const dword)  (usage 12)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COLOUR_MODE                           27  0x0000001b (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (usage 3)
COM1                               63496  0x0000f808 (const dword)  (not used)
com1_Count                          -132  0xffffff7c (PmmC func) args[0] r=1  (not used)
com1_Error                          -134  0xffffff7a (PmmC func) args[0] r=1  (not used)
com1_Full                           -133  0xffffff7b (PmmC func) args[0] r=1  (not used)
com1_Init                           -130  0xffffff7e (PmmC func) args[3] r=0  (not used)
com1_Reset                          -131  0xffffff7d (PmmC func) args[0] r=0  (not used)
com1_Sync                           -135  0xffffff79 (PmmC func) args[0] r=1  (not used)
com1_TXbuffer                       -136  0xffffff78 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -139  0xffffff75 (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -137  0xffffff77 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -138  0xffffff76 (PmmC func) args[1] r=1  (not used)
com_Count                           -122  0xffffff86 (PmmC func) args[0] r=1  (usage 3)
com_Error                           -124  0xffffff84 (PmmC func) args[0] r=1  (not used)
com_Full                            -123  0xffffff85 (PmmC func) args[0] r=1  (not used)
com_Init                            -120  0xffffff88 (PmmC func) args[3] r=0  (usage 3)
com_Reset                           -121  0xffffff87 (PmmC func) args[0] r=0  (not used)
com_SetBaud                         -142  0xffffff72 (PmmC func) args[2] r=1  (usage 3)
com_Sync                            -125  0xffffff83 (PmmC func) args[0] r=1  (not used)
com_TXbuffer                        -126  0xffffff82 (PmmC func) args[3] r=0  (usage 3)
com_TXbufferHold                    -129  0xffffff7f (PmmC func) args[1] r=1  (not used)
com_TXcount                         -127  0xffffff81 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -128  0xffffff80 (PmmC func) args[1] r=1  (not used)
comRX                               4116  0x00001014 (mem) word[40] (global)  (usage 3)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -18  0xffffffee (PmmC func) args[1] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
cRockerswitch                     UNRESOLVED  (not used)
cRotaryswitch                     UNRESOLVED  (not used)
cs                                  4356  0x00001104 (mem) word (global)  (usage 42)
cSlider                           UNRESOLVED  (not used)
cTrackbar                         UNRESOLVED  (not used)
curform                             4102  0x00001006 (mem) word (global)  (usage 48)
cUserButton                       UNRESOLVED  (not used)
cWinbutton                        UNRESOLVED  (not used)
CY                                  -285  0xfffffee3 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
disk                                   0  0x00000000 (mem) word (global)  (usage 6)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_Disconnect                     -293  0xfffffedb (PmmC func) args[0] r=0  (not used)
disp_Init                           -143  0xffffff71 (PmmC func) args[0] r=0  (not used)
disp_ReadWord                       -149  0xffffff6b (PmmC func) args[0] r=1  (not used)
disp_setGRAM                        -145  0xffffff6f (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -144  0xffffff70 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -284  0xfffffee4 (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -147  0xffffff6d (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -148  0xffffff6c (PmmC func) args[1] r=0  (not used)
DISPLAY_PAGE                          33  0x00000021 (const dword)  (not used)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DoGFXObjects                        6693  0x00001a25 (User func) args[0] r=0  (usage 6)
doScope                             8908  0x000022cc (User func) args[2] r=0  (usage 3)
DOWN                                   0  0x00000000 (const dword)  (not used)
drawScope                           9108  0x00002394 (User func) args[1] r=0  (usage 6)
DSK                                63490  0x0000f802 (const dword)  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                              -282  0xfffffee6 (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                           -283  0xfffffee5 (PmmC func) args[0] r=1  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FILE_TIMEOUT                       26  0x0000001a (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_Close                          -232  0xffffff18 (PmmC func) args[1] r=1  (not used)
file_Count                          -226  0xffffff1e (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -247  0xffffff09 (PmmC func) args[1] r=1  (not used)
file_Error                          -225  0xffffff1f (PmmC func) args[0] r=1  (not used)
file_Exec                           -251  0xffffff05 (PmmC func) args[2] r=1  (not used)
file_Exists                         -230  0xffffff1a (PmmC func) args[1] r=1  (not used)
file_FindFirst                      -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
file_FindNext                       -229  0xffffff1b (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -242  0xffffff0e (PmmC func) args[1] r=1  (usage 3)
file_GetS                           -246  0xffffff0a (PmmC func) args[3] r=1  (not used)
file_GetW                           -244  0xffffff0c (PmmC func) args[1] r=1  (usage 3)
file_Image                          -239  0xffffff11 (PmmC func) args[3] r=1  (not used)
file_Index                          -235  0xffffff15 (PmmC func) args[4] r=1  (not used)
file_LoadFunction                   -249  0xffffff07 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -252  0xffffff04 (PmmC func) args[3] r=1  (usage 18)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -253  0xffffff03 (PmmC func) args[0] r=1  (usage 6)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -231  0xffffff19 (PmmC func) args[2] r=1  (usage 3)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -255  0xffffff01 (PmmC func) args[1] r=1  (usage 3)
file_PutC                           -241  0xffffff0f (PmmC func) args[2] r=1  (not used)
file_PutS                           -245  0xffffff0b (PmmC func) args[2] r=1  (not used)
file_PutW                           -243  0xffffff0d (PmmC func) args[2] r=1  (not used)
file_Read                           -233  0xffffff17 (PmmC func) args[3] r=1  (not used)
file_Rewind                         -248  0xffffff08 (PmmC func) args[1] r=1  (not used)
file_Run                            -250  0xffffff06 (PmmC func) args[2] r=1  (not used)
file_ScreenCapture                  -240  0xffffff10 (PmmC func) args[5] r=1  (not used)
file_Seek                           -234  0xffffff16 (PmmC func) args[3] r=1  (usage 3)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_Size                           -238  0xffffff12 (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -236  0xffffff14 (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -254  0xffffff02 (PmmC func) args[0] r=0  (not used)
file_Write                          -237  0xffffff13 (PmmC func) args[3] r=1  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
flash_BlockErase                    -157  0xffffff63 (PmmC func) args[1] r=1  (not used)
flash_BulkErase                     -156  0xffffff64 (PmmC func) args[0] r=0  (not used)
flash_ID                            -155  0xffffff65 (PmmC func) args[0] r=1  (not used)
flash_SIG                           -154  0xffffff66 (PmmC func) args[0] r=1  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
FONT1                                  0  0x00000000 (const dword)  (not used)
FONT2                                  1  0x00000001 (const dword)  (not used)
FONT3                                  2  0x00000002 (const dword)  (usage 9)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
formBGcol                           3668  0x00000e54formBGcol                           3668  0x00000e54 (mem) word[11] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 8)
formBGcol                         UNRESOLVED  (usage 4)
formenidx                            130  0x00000082formenidx                            130  0x00000082 (mem) word[11] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 6)
formstidx                            108  0x0000006cformstidx                            108  0x0000006c (mem) word[11] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 7)
formstidx                         UNRESOLVED  (usage 2)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (usage 3)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
gbutton                           UNRESOLVED  (not used)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                         -85  0xffffffab (PmmC func) args[1] r=1  (not used)
gfx_BevelShadow                     -104  0xffffff98 (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -103  0xffffff99 (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                         -92  0xffffffa4 (PmmC func) args[1] r=1  (not used)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                            -74  0xffffffb6 (PmmC func) args[2] r=0  (not used)
gfx_Bullet                           -71  0xffffffb9 (PmmC func) args[1] r=0  (not used)
gfx_Button                           -80  0xffffffb0 (PmmC func) args[9] r=0  (not used)
GFX_BUTTON_BACKGROUND                 64  0x00000040 (const dword)  (not used)
GFX_BUTTON_FOREGROUND                 63  0x0000003f (const dword)  (not used)
GFX_BUTTON_MODE                       65  0x00000041 (const dword)  (not used)
gfx_ChangeColour                     -76  0xffffffb4 (PmmC func) args[2] r=0  (not used)
gfx_Circle                           -61  0xffffffc3 (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                     -62  0xffffffc2 (PmmC func) args[4] r=0  (not used)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                         -94  0xffffffa2 (PmmC func) args[1] r=0  (usage 6)
gfx_ClipWindow                       -75  0xffffffb5 (PmmC func) args[4] r=0  (usage 3)
gfx_Cls                              -51  0xffffffcd (PmmC func) args[0] r=0  (usage 6)
gfx_ColourMode                      -102  0xffffff9a (PmmC func) args[1] r=1  (not used)
gfx_Contrast                        -100  0xffffff9c (PmmC func) args[1] r=1  (usage 3)
gfx_Dot                              -70  0xffffffba (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                          -78  0xffffffb2 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                    -79  0xffffffb1 (PmmC func) args[5] r=0  (not used)
gfx_FrameDelay                       -97  0xffffff9f (PmmC func) args[1] r=1  (not used)
gfx_Get                              -90  0xffffffa6 (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                         -64  0xffffffc0 (PmmC func) args[2] r=1  (not used)
GFX_HILIGHT_BACKGROUND                61  0x0000003d (const dword)  (not used)
GFX_HILIGHT_FOREGROUND                62  0x0000003e (const dword)  (not used)
GFX_HILITE_LINE                       58  0x0000003a (const dword)  (not used)
gfx_Hline                            -57  0xffffffc7 (PmmC func) args[4] r=1  (usage 6)
gfx_IncX                             -72  0xffffffb8 (PmmC func) args[0] r=1  (not used)
gfx_IncY                             -73  0xffffffb7 (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_SELECTION                    60  0x0000003c (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
GFX_LEFT_GUTTER_WIDTH                 68  0x00000044 (const dword)  (not used)
gfx_Line                             -56  0xffffffc8 (PmmC func) args[5] r=0  (usage 24)
GFX_LINE_COUNT                        59  0x0000003b (const dword)  (not used)
gfx_LinePattern                     -101  0xffffff9b (PmmC func) args[1] r=1  (not used)
gfx_LineRel                          -55  0xffffffc9 (PmmC func) args[2] r=0  (not used)
gfx_LineTo                           -54  0xffffffca (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                          -53  0xffffffcb (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                           -52  0xffffffcc (PmmC func) args[2] r=0  (usage 3)
gfx_ObjectColour                     -93  0xffffffa3 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                            -67  0xffffffbd (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                        -66  0xffffffbe (PmmC func) args[2] r=0  (not used)
gfx_Origin                           -89  0xffffffa7 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                    -99  0xffffff9d (PmmC func) args[1] r=1  (not used)
gfx_Panel                            -81  0xffffffaf (PmmC func) args[6] r=0  (not used)
gfx_PenSize                          -91  0xffffffa5 (PmmC func) args[1] r=1  (not used)
GFX_PIXEL_SHIFT                       70  0x00000046 (const dword)  (not used)
gfx_Polygon                          -69  0xffffffbb (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                    -88  0xffffffa8 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                         -68  0xffffffbc (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                         -63  0xffffffc1 (PmmC func) args[3] r=0  (usage 3)
GFX_RECT_X1                           71  0x00000047 (const dword)  (not used)
GFX_RECT_X2                           73  0x00000049 (const dword)  (not used)
GFX_RECT_Y1                           72  0x00000048 (const dword)  (not used)
GFX_RECT_Y2                           74  0x0000004a (const dword)  (not used)
gfx_Rectangle                        -59  0xffffffc5 (PmmC func) args[5] r=0  (not used)
gfx_RectangleFilled                  -60  0xffffffc4 (PmmC func) args[5] r=0  (usage 9)
gfx_RGBto565                         -84  0xffffffac (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
GFX_RIGHT_GUTTER_WIDTH                69  0x00000045 (const dword)  (not used)
gfx_Scope                           9633  0x000025a1 (User func) args[19] r=0  (usage 3)
gfx_ScreenCopyPaste                  -83  0xffffffad (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                       -98  0xffffff9e (PmmC func) args[1] r=1  (usage 3)
gfx_Selection                        -86  0xffffffaa (PmmC func) args[3] r=0  (not used)
gfx_Set                              -50  0xffffffce (PmmC func) args[2] r=0  (usage 3)
gfx_SetClipRegion                    -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
gfx_Slider                           -82  0xffffffae (PmmC func) args[8] r=1  (not used)
GFX_STATUSBAR_HEIGHT                  67  0x00000043 (const dword)  (not used)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOOLBAR_HEIGHT                    66  0x00000042 (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                     -96  0xffffffa0 (PmmC func) args[1] r=1  (not used)
gfx_TransparentColour                -95  0xffffffa1 (PmmC func) args[1] r=1  (not used)
gfx_Triangle                         -65  0xffffffbf (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                   -87  0xffffffa9 (PmmC func) args[7] r=0  (not used)
gfx_Vline                            -58  0xffffffc6 (PmmC func) args[4] r=1  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -105  0xffffff97 (PmmC func) args[1] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -106  0xffffff96 (PmmC func) args[1] r=1  (not used)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
Graticule                           9562  0x0000255a (User func) args[7] r=0  (usage 6)
GRAY                               33808  0x00008410 (const dword)  (not used)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (not used)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
hFonts                                 4  0x00000004 (mem) word[10] (global)  (usage 39)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                              -214  0xffffff2a (PmmC func) args[1] r=1  (not used)
HIDE                                   2  0x00000002 (const dword)  (not used)
hndl                                   2  0x00000002 (mem) word (global)  (usage 108)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
hstrings                              78  0x0000004e (mem) word (global)  (usage 12)
I2C                                63520  0x0000f820 (const dword)  (not used)
I2C_Ack                             -169  0xffffff57 (PmmC func) args[0] r=0  (not used)
I2C_AckPoll                         -172  0xffffff54 (PmmC func) args[1] r=1  (not used)
I2C_AckStatus                       -171  0xffffff55 (PmmC func) args[0] r=0  (not used)
I2C_Close                           -163  0xffffff5d (PmmC func) args[0] r=0  (not used)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_Getn                            -175  0xffffff51 (PmmC func) args[2] r=1  (not used)
I2C_Gets                            -174  0xffffff52 (PmmC func) args[2] r=1  (not used)
I2C_Idle                            -173  0xffffff53 (PmmC func) args[0] r=0  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_Nack                            -170  0xffffff56 (PmmC func) args[0] r=0  (not used)
I2C_Open                            -162  0xffffff5e (PmmC func) args[1] r=0  (not used)
I2C_Putn                            -177  0xffffff4f (PmmC func) args[2] r=1  (not used)
I2C_Puts                            -176  0xffffff50 (PmmC func) args[1] r=1  (not used)
I2C_Read                            -167  0xffffff59 (PmmC func) args[0] r=1  (not used)
I2C_Restart                         -166  0xffffff5a (PmmC func) args[0] r=1  (not used)
I2C_SLOW                               0  0x00000000 (const dword)  (not used)
I2C_Start                           -164  0xffffff5c (PmmC func) args[0] r=1  (not used)
I2C_Stop                            -165  0xffffff5b (PmmC func) args[0] r=1  (not used)
I2C_Write                           -168  0xffffff58 (PmmC func) args[1] r=1  (not used)
i4Dbutton0                            13  0x0000000d (const ??? 0)  (usage 3)
i4Dbutton1                            14  0x0000000e (const ??? 0)  (usage 3)
i4Dbutton13                           69  0x00000045 (const ??? 0)  (usage 3)
i4Dbutton14                           70  0x00000046 (const ??? 0)  (usage 3)
i4Dbutton15                           66  0x00000042 (const ??? 0)  (usage 3)
i4Dbutton16                           71  0x00000047 (const ??? 0)  (usage 3)
i4Dbutton17                           72  0x00000048 (const ??? 0)  (usage 3)
i4Dbutton18                           73  0x00000049 (const ??? 0)  (usage 3)
i4Dbutton19                           74  0x0000004a (const ??? 0)  (usage 3)
i4Dbutton2                            15  0x0000000f (const ??? 0)  (usage 3)
i4Dbutton20                          113  0x00000071 (const ??? 0)  (usage 3)
i4Dbutton21                          114  0x00000072 (const ??? 0)  (usage 3)
i4Dbutton22                          115  0x00000073 (const ??? 0)  (usage 3)
i4Dbutton23                          116  0x00000074 (const ??? 0)  (usage 3)
i4Dbutton24                           80  0x00000050 (const ??? 0)  (usage 3)
i4Dbutton25                           81  0x00000051 (const ??? 0)  (usage 3)
i4Dbutton26                           82  0x00000052 (const ??? 0)  (usage 3)
i4Dbutton27                           83  0x00000053 (const ??? 0)  (usage 3)
i4Dbutton28                           84  0x00000054 (const ??? 0)  (usage 3)
i4Dbutton29                           85  0x00000055 (const ??? 0)  (usage 3)
i4Dbutton3                            16  0x00000010 (const ??? 0)  (usage 3)
i4Dbutton4                            68  0x00000044 (const ??? 0)  (usage 3)
i4Dbutton5                            61  0x0000003d (const ??? 0)  (usage 3)
i4Dbutton6                            62  0x0000003e (const ??? 0)  (usage 3)
i4Dbutton7                            63  0x0000003f (const ??? 0)  (usage 3)
i4Dbutton8                            64  0x00000040 (const ??? 0)  (usage 3)
i4Dbutton9                            65  0x00000041 (const ??? 0)  (usage 3)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (usage 6)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (usage 3)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (usage 6)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
iCoolgauge0                           88  0x00000058 (const ??? 0)  (usage 3)
iCoolgauge1                           92  0x0000005c (const ??? 0)  (usage 3)
iCoolgauge2                           89  0x00000059 (const ??? 0)  (usage 3)
iCoolgauge3                           90  0x0000005a (const ??? 0)  (usage 3)
iDigits                                2  0x00000002 (const dword)  (usage 9)
iForm8                               100  0x00000064 (const ??? 0)  (usage 3)
iForm9                               119  0x00000077 (const ??? 0)  (usage 3)
iiLeddigits0                          59  0x0000003b (const ??? 0)  (not used)
iiLeddigits1                          29  0x0000001d (const ??? 0)  (not used)
iiLeddigits2                          27  0x0000001b (const ??? 0)  (not used)
iiLeddigits3                          51  0x00000033 (const ??? 0)  (not used)
iiLeddigits4                          53  0x00000035 (const ??? 0)  (not used)
iImage0                                4  0x00000004 (const ??? 0)  (usage 3)
iImage1                               86  0x00000056 (const ??? 0)  (usage 3)
iImage2                               87  0x00000057 (const ??? 0)  (usage 3)
iImage3                                6  0x00000006 (const ??? 0)  (usage 3)
iImage4                               57  0x00000039 (const ??? 0)  (usage 3)
iImage5                                5  0x00000005 (const ??? 0)  (usage 3)
iKnob1                                45  0x0000002d (const ??? 0)  (usage 3)
iKnob2                                44  0x0000002c (const ??? 0)  (usage 3)
iLeadingBlanks                         8  0x00000008 (const dword)  (usage 3)
iLed0                                 18  0x00000012 (const ??? 0)  (usage 3)
iLed1                                 40  0x00000028 (const ??? 0)  (usage 3)
iLed2                                 39  0x00000027 (const ??? 0)  (usage 3)
iLed3                                 38  0x00000026 (const ??? 0)  (usage 3)
iLed4                                 37  0x00000025 (const ??? 0)  (usage 3)
iLed5                                 36  0x00000024 (const ??? 0)  (usage 3)
iLed6                                 19  0x00000013 (const ??? 0)  (usage 3)
iLed7                                 20  0x00000014 (const ??? 0)  (usage 3)
iLed8                                 21  0x00000015 (const ??? 0)  (usage 3)
iLeddigits0                           58  0x0000003a (const ??? 0)  (usage 3)
iLeddigits1                           28  0x0000001c (const ??? 0)  (usage 3)
iLeddigits2                           26  0x0000001a (const ??? 0)  (usage 3)
iLeddigits3                           50  0x00000032 (const ??? 0)  (usage 3)
iLeddigits4                           52  0x00000034 (const ??? 0)  (usage 3)
ileft                                  0  0x00000000 (const dword)  (usage 3)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (usage 3)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (not used)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (usage 42)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_TAG                             12  0x0000000c (const dword)  (usage 9)
IMAGE_TAG2                            13  0x0000000d (const dword)  (usage 9)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (not used)
IMAGE_XPOS                             2  0x00000002 (const dword)  (usage 3)
IMAGE_YPOS                             3  0x00000003 (const dword)  (not used)
iMeter0                                7  0x00000007 (const ??? 0)  (usage 3)
iMeter1                                8  0x00000008 (const ??? 0)  (usage 3)
iMeter2                                9  0x00000009 (const ??? 0)  (usage 3)
iMeter3                               10  0x0000000a (const ??? 0)  (usage 3)
iMeter4                               11  0x0000000b (const ??? 0)  (usage 3)
iMeter5                               32  0x00000020 (const ??? 0)  (usage 3)
img_ClearAttributes                 -187  0xffffff45 (PmmC func) args[3] r=1  (usage 3)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -181  0xffffff4b (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -180  0xffffff4c (PmmC func) args[2] r=1  (usage 6)
img_Enable                          -179  0xffffff4d (PmmC func) args[2] r=1  (not used)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -184  0xffffff48 (PmmC func) args[3] r=1  (usage 42)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -182  0xffffff4a (PmmC func) args[2] r=1  (not used)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SetAttributes                   -186  0xffffff46 (PmmC func) args[3] r=1  (usage 6)
img_SetPosition                     -178  0xffffff4e (PmmC func) args[4] r=1  (not used)
img_SetWord                         -183  0xffffff49 (PmmC func) args[4] r=1  (usage 24)
img_Show                            -185  0xffffff47 (PmmC func) args[2] r=1  (usage 21)
img_Touched                         -188  0xffffff44 (PmmC func) args[2] r=1  (usage 3)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
iMinDigits                             4  0x00000004 (const dword)  (usage 3)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
input                               4112  0x00001010 (mem) word (global)  (usage 81)
INPUT                                  1  0x00000001 (const dword)  (not used)
inputtype                           4108  0x0000100c (mem) word (global)  (usage 30)
INVERSE                               64  0x00000040 (const dword)  (not used)
IO1_PIN                                1  0x00000001 (const dword)  (not used)
IO2_PIN                                2  0x00000002 (const dword)  (not used)
IO3_PIN                                3  0x00000003 (const dword)  (not used)
IO4_PIN                                4  0x00000004 (const dword)  (not used)
IO5_PIN                                5  0x00000005 (const dword)  (not used)
IPControls                           152  0x00000098IPControls                           152  0x00000098 (mem) word[129] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 9)
IPD_DOWN                              16  0x00000010 (const dword)  (usage 6)
IPD_OBJVidx                           20  0x00000014 (const dword)  (usage 21)
IPD_P1                                 2  0x00000002 (const dword)  (usage 15)
IPD_P2                                 4  0x00000004 (const dword)  (usage 57)
IPD_P3                                 6  0x00000006 (const dword)  (usage 21)
IPD_P4                                 8  0x00000008 (const dword)  (usage 21)
IPD_P5                                10  0x0000000a (const dword)  (usage 15)
IPD_P6                                12  0x0000000c (const dword)  (usage 21)
IPD_P7                                14  0x0000000e (const dword)  (usage 3)
IPD_RELEASE                           18  0x00000012 (const dword)  (usage 9)
IPData                               410  0x0000019aIPData                               410  0x0000019a (mem) word[1309] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 27)
IPDatasize                            22  0x00000016 (const dword)  (usage 3)
isalnum                             -207  0xffffff31 (PmmC func) args[1] r=1  (not used)
isalpha                             -206  0xffffff32 (PmmC func) args[1] r=1  (not used)
isdigit                             -202  0xffffff36 (PmmC func) args[1] r=1  (not used)
iSlider0                              12  0x0000000c (const ??? 0)  (usage 3)
iSlider1                             101  0x00000065 (const ??? 0)  (usage 3)
iSlider2                             106  0x0000006a (const ??? 0)  (usage 3)
iSlider3                             104  0x00000068 (const ??? 0)  (usage 3)
iSlider4                             105  0x00000069 (const ??? 0)  (usage 3)
islower                             -205  0xffffff33 (PmmC func) args[1] r=1  (not used)
iSounds                               24  0x00000018 (mem) word[17] (global)  (usage 54)
isprint                             -208  0xffffff30 (PmmC func) args[1] r=1  (not used)
isspace                             -209  0xffffff2f (PmmC func) args[1] r=1  (not used)
iStatictext0                          98  0x00000062 (const ??? 0)  (usage 3)
iStatictext1                          41  0x00000029 (const ??? 0)  (usage 3)
iStatictext10                         77  0x0000004d (const ??? 0)  (usage 3)
iStatictext11                         78  0x0000004e (const ??? 0)  (usage 3)
iStatictext12                         79  0x0000004f (const ??? 0)  (usage 3)
iStatictext13                        102  0x00000066 (const ??? 0)  (usage 3)
iStatictext14                        103  0x00000067 (const ??? 0)  (usage 3)
iStatictext15                        108  0x0000006c (const ??? 0)  (usage 3)
iStatictext16                        109  0x0000006d (const ??? 0)  (usage 3)
iStatictext17                        110  0x0000006e (const ??? 0)  (usage 3)
iStatictext18                        111  0x0000006f (const ??? 0)  (usage 3)
iStatictext19                        112  0x00000070 (const ??? 0)  (usage 3)
iStatictext2                          42  0x0000002a (const ??? 0)  (usage 3)
iStatictext23                         43  0x0000002b (const ??? 0)  (usage 3)
iStatictext24                         49  0x00000031 (const ??? 0)  (usage 3)
iStatictext25                         48  0x00000030 (const ??? 0)  (usage 3)
iStatictext26                        117  0x00000075 (const ??? 0)  (usage 3)
iStatictext27                        118  0x00000076 (const ??? 0)  (usage 3)
iStatictext28                         99  0x00000063 (const ??? 0)  (usage 3)
iStatictext3                          75  0x0000004b (const ??? 0)  (usage 3)
iStatictext4                          55  0x00000037 (const ??? 0)  (usage 3)
iStatictext5                          56  0x00000038 (const ??? 0)  (usage 3)
iStatictext6                          31  0x0000001f (const ??? 0)  (usage 3)
iStatictext7                          30  0x0000001e (const ??? 0)  (usage 3)
iStatictext8                          25  0x00000019 (const ??? 0)  (usage 3)
iStatictext9                          76  0x0000004c (const ??? 0)  (usage 3)
iStrings0                           3028  0x00000bd4iStrings0                           3028  0x00000bd4 (mem) word[13] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
iStrings1                           3054  0x00000beeiStrings1                           3054  0x00000bee (mem) word[13] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
iStrings2                           3080  0x00000c08iStrings2                           3080  0x00000c08 (mem) word[13] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
iStrings3                           3106  0x00000c22iStrings3                           3106  0x00000c22 (mem) word[13] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
iStrings4                           3132  0x00000c3ciStrings4                           3132  0x00000c3c (mem) word[13] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
iStrings5                           3158  0x00000c56iStrings5                           3158  0x00000c56 (mem) word[13] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
iStrings6                           3184  0x00000c70iStrings6                           3184  0x00000c70 (mem) word[13] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
iStrings7                           3210  0x00000c8aiStrings7                           3210  0x00000c8a (mem) word[13] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
iStrings8                           3236  0x00000ca4iStrings8                           3236  0x00000ca4 (mem) word[13] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
iStrings9                           3262  0x00000cbeiStrings9                           3262  0x00000cbe (mem) word[13] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
isupper                             -204  0xffffff34 (PmmC func) args[1] r=1  (not used)
iswhite                             -210  0xffffff2e (PmmC func) args[1] r=1  (not used)
isxdigit                            -203  0xffffff35 (PmmC func) args[1] r=1  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
iTank1                                24  0x00000018 (const ??? 0)  (usage 3)
iterator                            -198  0xffffff3a (PmmC func) args[1] r=0  (not used)
iThermometer1                         33  0x00000021 (const ??? 0)  (usage 3)
iTrackbar1                            67  0x00000043 (const ??? 0)  (usage 3)
iUserled0                             94  0x0000005e (const ??? 0)  (usage 3)
iUserled1                             34  0x00000022 (const ??? 0)  (usage 3)
iUserled10                            47  0x0000002f (const ??? 0)  (usage 3)
iUserled2                             35  0x00000023 (const ??? 0)  (usage 3)
iUserled3                             95  0x0000005f (const ??? 0)  (usage 3)
iUserled4                             96  0x00000060 (const ??? 0)  (usage 3)
iUserled5                             97  0x00000061 (const ??? 0)  (usage 3)
iUserled9                             46  0x0000002e (const ??? 0)  (usage 3)
IVORY                              65534  0x0000fffe (const dword)  (not used)
iWidthDigit                            6  0x00000006 (const dword)  (usage 3)
iWinbutton0                           17  0x00000011 (const ??? 0)  (usage 3)
iWinbutton1                            0  0x00000000 (const ??? 0)  (usage 3)
iWinbutton10                          93  0x0000005d (const ??? 0)  (usage 3)
iWinbutton11                         107  0x0000006b (const ??? 0)  (usage 3)
iWinbutton12                         120  0x00000078 (const ??? 0)  (usage 3)
iWinbutton13                         121  0x00000079 (const ??? 0)  (usage 3)
iWinbutton14                         122  0x0000007a (const ??? 0)  (usage 3)
iWinbutton15                         123  0x0000007b (const ??? 0)  (usage 3)
iWinbutton16                         124  0x0000007c (const ??? 0)  (usage 3)
iWinbutton17                         125  0x0000007d (const ??? 0)  (usage 3)
iWinbutton18                         126  0x0000007e (const ??? 0)  (usage 3)
iWinbutton19                         127  0x0000007f (const ??? 0)  (usage 3)
iWinbutton2                            1  0x00000001 (const ??? 0)  (usage 3)
iWinbutton20                         128  0x00000080 (const ??? 0)  (usage 3)
iWinbutton3                           23  0x00000017 (const ??? 0)  (usage 3)
iWinbutton4                            2  0x00000002 (const ??? 0)  (usage 3)
iWinbutton5                            3  0x00000003 (const ??? 0)  (usage 3)
iWinbutton6                           60  0x0000003c (const ??? 0)  (usage 3)
iWinbutton7                           91  0x0000005b (const ??? 0)  (usage 3)
iWinbutton8                           22  0x00000016 (const ??? 0)  (usage 3)
iWinbutton9                           54  0x00000036 (const ??? 0)  (usage 3)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
kKeyboardKeystrokes                 3690  0x00000e6akKeyboardKeystrokes                 3690  0x00000e6a (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (not used)
LANDSCAPE                              0  0x00000000 (const dword)  (usage 3)
LANDSCAPE_R                            1  0x00000001 (const dword)  (not used)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
ledDigitsDisplay                    8011  0x00001f4b (User func) args[3] r=0  (usage 6)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (usage 9)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                              -213  0xffffff2b (PmmC func) args[1] r=1  (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                4271  0x000010af (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -15  0xfffffff1 (PmmC func) args[2] r=1  (not used)
MaxTotObjects                         33  0x00000021 (const dword)  (usage 6)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
MEDIA_ADDRESS_MW                      92  0x0000005c (const dword)  (not used)
MEDIA_ADDRESS_UW                      93  0x0000005d (const dword)  (not used)
media_Flush                         -118  0xffffff8a (PmmC func) args[0] r=1  (not used)
media_Image                         -117  0xffffff8b (PmmC func) args[2] r=0  (not used)
media_Init                          -119  0xffffff89 (PmmC func) args[0] r=1  (not used)
media_RdSector                      -111  0xffffff91 (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -113  0xffffff8f (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -114  0xffffff8e (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                      124  0x0000007c (const dword)  (not used)
MEDIA_SECTOR_LO                      123  0x0000007b (const dword)  (not used)
media_SetAdd                        -109  0xffffff93 (PmmC func) args[2] r=0  (not used)
media_SetSector                     -110  0xffffff92 (PmmC func) args[2] r=0  (not used)
media_Video                         -107  0xffffff95 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -108  0xffffff94 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -115  0xffffff8d (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
media_WrSector                      -112  0xffffff90 (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
mem_Alloc                           -216  0xffffff28 (PmmC func) args[1] r=1  (not used)
mem_AllocV                          -217  0xffffff27 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -218  0xffffff26 (PmmC func) args[1] r=1  (not used)
mem_Compare                         -224  0xffffff20 (PmmC func) args[3] r=1  (not used)
mem_Copy                            -223  0xffffff21 (PmmC func) args[3] r=1  (usage 3)
mem_Free                            -220  0xffffff24 (PmmC func) args[1] r=1  (not used)
mem_Heap                            -221  0xffffff23 (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -219  0xffffff25 (PmmC func) args[2] r=1  (not used)
mem_Set                             -222  0xffffff22 (PmmC func) args[3] r=1  (not used)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -14  0xfffffff2 (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
NAK                                   21  0x00000015 (const dword)  (usage 24)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
nInputs                              119  0x00000077 (const dword)  (usage 3)
nObjects                             129  0x00000081 (const dword)  (not used)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
o4Dbuttons                          3594  0x00000e0ao4Dbuttons                          3594  0x00000e0a (mem) word[31] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 12)
oAngularmeters                      3364  0x00000d24oAngularmeters                      3364  0x00000d24 (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oAniButtons                         3656  0x00000e48oAniButtons                         3656  0x00000e48 (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
object                              4114  0x00001012 (mem) word (global)  (usage 30)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
oColorPickers                       3658  0x00000e4aoColorPickers                       3658  0x00000e4a (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oCoolgauges                         3366  0x00000d26oCoolgauges                         3366  0x00000d26 (mem) word[5] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
Ocs                                 4358  0x00001106 (mem) word (global)  (usage 9)
oCustomdigitss                      3376  0x00000d30oCustomdigitss                      3376  0x00000d30 (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oDipSwitchs                         3288  0x00000cd8oDipSwitchs                         3288  0x00000cd8 (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
OFF                                    0  0x00000000 (const dword)  (usage 3)
oForms                              3378  0x00000d32oForms                              3378  0x00000d32 (mem) word[12] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oGauges                             3402  0x00000d4aoGauges                             3402  0x00000d4a (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oGSliders                           3302  0x00000ce6oGSliders                           3302  0x00000ce6 (mem) word[6] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 6)
oImages                             3404  0x00000d4coImages                             3404  0x00000d4c (mem) word[7] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oKeyboards                          3418  0x00000d5aoKeyboards                          3418  0x00000d5a (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oKnobs                              3290  0x00000cdaoKnobs                              3290  0x00000cda (mem) word[4] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 6)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
oLeddigitss                         3440  0x00000d70oLeddigitss                         3440  0x00000d70 (mem) word[6] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 9)
oLeds                               3420  0x00000d5coLeds                               3420  0x00000d5c (mem) word[10] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
oMeters                             3452  0x00000d7coMeters                             3452  0x00000d7c (mem) word[7] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
ON                                     1  0x00000001 (const dword)  (usage 3)
oObjects                            4034  0x00000fc2 (mem) word[34] (global)  (usage 108)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
OPDataL                             3692  0x00000e6cOPDataL                             3692  0x00000e6c (mem) word[25] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 6)
OPDataSc                            3742  0x00000e9eOPDataSc                            3742  0x00000e9e (mem) word[24] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 153)
oPinInputs                          3592  0x00000e08oPinInputs                          3592  0x00000e08 (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oPinOutputs                         3666  0x00000e52oPinOutputs                         3666  0x00000e52 (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
oRockerSwitchs                      3298  0x00000ce2oRockerSwitchs                      3298  0x00000ce2 (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oRotarySwitchs                      3300  0x00000ce4oRotarySwitchs                      3300  0x00000ce4 (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oScopes                             3582  0x00000dfeoScopes                             3582  0x00000dfe (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oSoundss                            3664  0x00000e50oSoundss                            3664  0x00000e50 (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oSpectrums                          3580  0x00000dfcoSpectrums                          3580  0x00000dfc (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oStaticTexts                        3520  0x00000dc0oStaticTexts                        3520  0x00000dc0 (mem) word[30] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oStringss                           3466  0x00000d8aoStringss                           3466  0x00000d8a (mem) word[11] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 7)
oStringss                         UNRESOLVED  (usage 2)
OT_ACTIVATE                          103  0x00000067 (const dword)  (usage 66)
OT_NEXTFRAME                         104  0x00000068 (const dword)  (usage 3)
OT_NEXTSTRING                        106  0x0000006a (const dword)  (usage 3)
OT_PREVFRAME                         105  0x00000069 (const dword)  (usage 3)
OT_PREVSTRING                        107  0x0000006b (const dword)  (usage 3)
OT_REPORT                            100  0x00000064 (const dword)  (usage 42)
OT_SETANOTHER                        102  0x00000066 (const dword)  (usage 33)
OT_SETCONST                          101  0x00000065 (const dword)  (usage 60)
oTanks                              3584  0x00000e00oTanks                              3584  0x00000e00 (mem) word[3] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oThermometers                       3488  0x00000da0oThermometers                       3488  0x00000da0 (mem) word[3] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oTimers                             3662  0x00000e4eoTimers                             3662  0x00000e4e (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oTrackbars                          3314  0x00000cf2oTrackbars                          3314  0x00000cf2 (mem) word[3] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 6)
oUserButtons                        3660  0x00000e4coUserButtons                        3660  0x00000e4c (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oUserImagess                        3590  0x00000e06oUserImagess                        3590  0x00000e06 (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oUserleds                           3494  0x00000da6oUserleds                           3494  0x00000da6 (mem) word[12] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OUTPUT                                 0  0x00000000 (const dword)  (not used)
OVF                                  -21  0xffffffeb (PmmC func) args[0] r=1  (not used)
oVideos                             3518  0x00000dbeoVideos                             3518  0x00000dbe (mem) word[1] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 3)
oWinButtons                         3320  0x00000cf8oWinButtons                         3320  0x00000cf8 (mem) word[22] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 12)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (not used)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 6)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekW                                -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
PEN_SIZE                              16  0x00000010 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
PICASO                                 1  0x00000001 (const dword)  (usage 3)
PICASO_FUNCTIONS                       0  0x00000000 (const ??? 0)  (not used)
pin_HI                               -42  0xffffffd6 (PmmC func) args[1] r=1  (not used)
pin_LO                               -43  0xffffffd5 (PmmC func) args[1] r=1  (not used)
pin_Read                             -44  0xffffffd4 (PmmC func) args[1] r=1  (not used)
pin_Set                              -41  0xffffffd7 (PmmC func) args[2] r=1  (not used)
PINK                               65049  0x0000fe19 (const dword)  (not used)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeW                                -12  0xfffffff4 (PmmC func) args[2] r=0  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
PrintStrings                       10711  0x000029d7 (User func) args[3] r=0  (usage 9)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (usage 6)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (not used)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (usage 6)
RAND                                 -19  0xffffffed (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
READ_OBJ                               0  0x00000000 (const dword)  (usage 3)
READ_PAGE                             34  0x00000022 (const dword)  (not used)
ReadCmd                              128  0x00000080 (const dword)  (not used)
ReadObject                         10375  0x00002887 (User func) args[2] r=0  (usage 3)
RED                                63488  0x0000f800 (const dword)  (usage 6)
REPORT_EVENT                           7  0x00000007 (const dword)  (usage 3)
REPORT_OBJ                             5  0x00000005 (const dword)  (usage 3)
reserved                            -294  0xfffffeda (PmmC func) args[0] r=0  (not used)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RUNFLASH                             128  0x00000080 (const dword)  (usage 3)
RXMODE_0                               0  0x00000000 (const dword)  (not used)
RXMODE_1                               1  0x00000001 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
sc0Newval1                           590  0x0000024e (mem) word[246] (global)  (usage 3)
sc0Newval2                          1574  0x00000626 (mem) word[246] (global)  (usage 3)
sc0Newval3                          2558  0x000009fe (mem) word[246] (global)  (usage 3)
sc0Newval4                          3542  0x00000dd6 (mem) word[246] (global)  (usage 3)
sc0Oldval1                            98  0x00000062 (mem) word[246] (global)  (usage 6)
sc0Oldval2                          1082  0x0000043a (mem) word[246] (global)  (usage 3)
sc0Oldval3                          2066  0x00000812 (mem) word[246] (global)  (usage 3)
sc0Oldval4                          3050  0x00000bea (mem) word[246] (global)  (usage 3)
scBottom                              21  0x00000015 (const ??? 0)  (usage 9)
scColor                                0  0x00000000 (const ??? 0)  (usage 6)
scCurpos                              96  0x00000060 (mem) word[1] (global)  (usage 12)
scDataPoints                          22  0x00000016 (const ??? 0)  (usage 9)
scForm                                19  0x00000013 (const ??? 0)  (usage 6)
scGraticuleCol                         1  0x00000001 (const ??? 0)  (usage 6)
scGraticuleVis                         2  0x00000002 (const ??? 0)  (usage 6)
scGraticuleXinc                        3  0x00000003 (const ??? 0)  (usage 6)
scGraticuleYinc                        4  0x00000004 (const ??? 0)  (usage 6)
scLeft                                 5  0x00000005 (const ??? 0)  (usage 18)
SCOPEENTS                             24  0x00000018 (const ??? 0)  (usage 9)
SCREEN_MODE                           23  0x00000017 (const dword)  (not used)
scRefreshInc                           6  0x00000006 (const ??? 0)  (usage 3)
scRight                               20  0x00000014 (const ??? 0)  (usage 15)
scTop                                  7  0x00000007 (const ??? 0)  (usage 9)
scTrace1Col                            8  0x00000008 (const ??? 0)  (usage 3)
scTrace2Col                            9  0x00000009 (const ??? 0)  (usage 3)
scTrace3Col                           10  0x0000000a (const ??? 0)  (usage 3)
scTrace4Col                           11  0x0000000b (const ??? 0)  (usage 3)
scTracebuf                            80  0x00000050 (mem) word[8] (global)  (usage 30)
scTraces                              12  0x0000000c (const ??? 0)  (usage 12)
scWidth                               13  0x0000000d (const ??? 0)  (usage 3)
scXmag                                14  0x0000000e (const ??? 0)  (usage 3)
scYamp                                15  0x0000000f (const ??? 0)  (usage 3)
scYLineCol                            17  0x00000011 (const ??? 0)  (usage 6)
scYLineForm                           16  0x00000010 (const ??? 0)  (usage 6)
scYLineVis                            18  0x00000012 (const ??? 0)  (usage 6)
scYZero                               23  0x00000017 (const ??? 0)  (usage 3)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SEED                                 -20  0xffffffec (PmmC func) args[1] r=0  (not used)
SELECT                                 3  0x00000003 (const dword)  (not used)
SELECT_MULTIPLE                        4  0x00000004 (const dword)  (not used)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (usage 3)
serin1                              -140  0xffffff74 (PmmC func) args[0] r=1  (not used)
serout                                -3  0xfffffffd (PmmC func) args[1] r=0  (usage 42)
serout1                             -141  0xffffff73 (PmmC func) args[1] r=0  (not used)
seroutCS                           10692  0x000029c4 (User func) args[1] r=0  (usage 30)
seroutOcs                          10675  0x000029b3 (User func) args[0] r=0  (usage 6)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (not used)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (not used)
SIN                                  -17  0xffffffef (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (not used)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -258  0xfffffefe (PmmC func) args[1] r=0  (not used)
snd_Continue                        -261  0xfffffefb (PmmC func) args[0] r=0  (usage 3)
snd_Pause                           -260  0xfffffefc (PmmC func) args[0] r=0  (usage 3)
snd_Pitch                           -257  0xfffffeff (PmmC func) args[1] r=1  (not used)
snd_Playing                         -262  0xfffffefa (PmmC func) args[0] r=1  (usage 3)
snd_Stop                            -259  0xfffffefd (PmmC func) args[0] r=0  (usage 3)
snd_Volume                          -256  0xffffff00 (PmmC func) args[1] r=0  (usage 3)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (not used)
Sounds                              3790  0x00000eceSounds                              3790  0x00000ece (mem) byte[208] (member of C:\Users\Brandon\Google Drive\Senior Design Fall 2013\Brandon\Visi\New folder\MCTRL_REV2.4DWork\MCTRL_REV2.4DGenieS)  (usage 51)
spi_Disable                         -153  0xffffff67 (PmmC func) args[0] r=0  (not used)
SPI_FAST                               0  0x00000000 (const dword)  (not used)
spi_Init                            -150  0xffffff6a (PmmC func) args[3] r=0  (not used)
SPI_MED                                1  0x00000001 (const dword)  (not used)
spi_Read                            -151  0xffffff69 (PmmC func) args[0] r=1  (not used)
SPI_SLOW                               2  0x00000002 (const dword)  (not used)
spi_Write                           -152  0xffffff68 (PmmC func) args[1] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -22  0xffffffea (PmmC func) args[1] r=1  (not used)
SSD1963_ENTER_IDLE_MODE               57  0x00000039 (const dword)  (not used)
SSD1963_ENTER_INVERT_MODE             33  0x00000021 (const dword)  (not used)
SSD1963_ENTER_NORMAL_MODE             19  0x00000013 (const dword)  (not used)
SSD1963_ENTER_PARTIAL_MODE            18  0x00000012 (const dword)  (not used)
SSD1963_ENTER_SLEEP_MODE              16  0x00000010 (const dword)  (not used)
SSD1963_EXIT_IDLE_MODE                56  0x00000038 (const dword)  (not used)
SSD1963_EXIT_INVERT_MODE              32  0x00000020 (const dword)  (not used)
SSD1963_EXIT_SLEEP_MODE               17  0x00000011 (const dword)  (not used)
SSD1963_GET_ADDRESS_MODE              11  0x0000000b (const dword)  (not used)
SSD1963_GET_DBC_CONF                 209  0x000000d1 (const dword)  (not used)
SSD1963_GET_DBC_TH                   213  0x000000d5 (const dword)  (not used)
SSD1963_GET_DISPLAY_MODE              13  0x0000000d (const dword)  (not used)
SSD1963_GET_GPIO0_ROP                201  0x000000c9 (const dword)  (not used)
SSD1963_GET_GPIO1_ROP                203  0x000000cb (const dword)  (not used)
SSD1963_GET_GPIO2_ROP                205  0x000000cd (const dword)  (not used)
SSD1963_GET_GPIO3_ROP                207  0x000000cf (const dword)  (not used)
SSD1963_GET_GPIO_CONFIG              185  0x000000b9 (const dword)  (not used)
SSD1963_GET_GPIO_STATUS              187  0x000000bb (const dword)  (not used)
SSD1963_GET_HORZ_PERIOD              181  0x000000b5 (const dword)  (not used)
SSD1963_GET_LCD_GEN0                 192  0x000000c0 (const dword)  (not used)
SSD1963_GET_LCD_GEN1                 194  0x000000c2 (const dword)  (not used)
SSD1963_GET_LCD_GEN2                 196  0x000000c4 (const dword)  (not used)
SSD1963_GET_LCD_GEN3                 198  0x000000c6 (const dword)  (not used)
SSD1963_GET_LCD_MODE                 177  0x000000b1 (const dword)  (not used)
SSD1963_GET_LSHIFT_FREQ              231  0x000000e7 (const dword)  (not used)
SSD1963_GET_PIXEL_DATA_INTERFACE     241  0x000000f1 (const dword)  (not used)
SSD1963_GET_PLL_MN                   227  0x000000e3 (const dword)  (not used)
SSD1963_GET_PLL_STATUS               228  0x000000e4 (const dword)  (not used)
SSD1963_GET_POST_PROC                189  0x000000bd (const dword)  (not used)
SSD1963_GET_POWER_MODE                10  0x0000000a (const dword)  (not used)
SSD1963_GET_PWM_CONFIG               191  0x000000bf (const dword)  (not used)
SSD1963_GET_SCANLINE                  69  0x00000045 (const dword)  (not used)
SSD1963_GET_TEAR_EFFECT_STATUS        14  0x0000000e (const dword)  (not used)
SSD1963_GET_VERT_PERIOD              183  0x000000b7 (const dword)  (not used)
SSD1963_NOP                            0  0x00000000 (const dword)  (not used)
SSD1963_READ_DDB                     161  0x000000a1 (const dword)  (not used)
SSD1963_READ_MEMORY_CONTINUE          62  0x0000003e (const dword)  (not used)
SSD1963_READ_MEMORY_START             46  0x0000002e (const dword)  (not used)
SSD1963_SET_ADDRESS_MODE              54  0x00000036 (const dword)  (not used)
SSD1963_SET_COLUMN_ADDRESS            42  0x0000002a (const dword)  (not used)
SSD1963_SET_DBC_CONF                 208  0x000000d0 (const dword)  (not used)
SSD1963_SET_DBC_TH                   212  0x000000d4 (const dword)  (not used)
SSD1963_SET_DEEP_SLEEP               229  0x000000e5 (const dword)  (not used)
SSD1963_SET_DISPLAY_OFF               40  0x00000028 (const dword)  (not used)
SSD1963_SET_DISPLAY_ON                41  0x00000029 (const dword)  (not used)
SSD1963_SET_GAMMA_CURVE               38  0x00000026 (const dword)  (not used)
SSD1963_SET_GPIO0_ROP                200  0x000000c8 (const dword)  (not used)
SSD1963_SET_GPIO1_ROP                202  0x000000ca (const dword)  (not used)
SSD1963_SET_GPIO2_ROP                204  0x000000cc (const dword)  (not used)
SSD1963_SET_GPIO3_ROP                206  0x000000ce (const dword)  (not used)
SSD1963_SET_GPIO_CONFIG              184  0x000000b8 (const dword)  (not used)
SSD1963_SET_GPIO_VALUE               186  0x000000ba (const dword)  (not used)
SSD1963_SET_HORZ_PERIOD              180  0x000000b4 (const dword)  (not used)
SSD1963_SET_LCD_GEN0                 193  0x000000c1 (const dword)  (not used)
SSD1963_SET_LCD_GEN1                 195  0x000000c3 (const dword)  (not used)
SSD1963_SET_LCD_GEN2                 197  0x000000c5 (const dword)  (not used)
SSD1963_SET_LCD_GEN3                 199  0x000000c7 (const dword)  (not used)
SSD1963_SET_LCD_MODE                 176  0x000000b0 (const dword)  (not used)
SSD1963_SET_LSHIFT_FREQ              230  0x000000e6 (const dword)  (not used)
SSD1963_SET_PAGE_ADDRESS              43  0x0000002b (const dword)  (not used)
SSD1963_SET_PARTIAL_AREA              48  0x00000030 (const dword)  (not used)
SSD1963_SET_PLL                      224  0x000000e0 (const dword)  (not used)
SSD1963_SET_PLL_MN                   226  0x000000e2 (const dword)  (not used)
SSD1963_SET_POST_PROC                188  0x000000bc (const dword)  (not used)
SSD1963_SET_PWM_CONFIG               190  0x000000be (const dword)  (not used)
SSD1963_SET_REAR_ON                   53  0x00000035 (const dword)  (not used)
SSD1963_SET_SCROLL_AREA               51  0x00000033 (const dword)  (not used)
SSD1963_SET_SCROLL_START              55  0x00000037 (const dword)  (not used)
SSD1963_SET_TEAR_OFF                  52  0x00000034 (const dword)  (not used)
SSD1963_SET_TEAR_SCANLINE             68  0x00000044 (const dword)  (not used)
SSD1963_SET_VERT_PERIOD              182  0x000000b6 (const dword)  (not used)
SSD1963_SOFT_RESET                     1  0x00000001 (const dword)  (not used)
SSD1963_WRITE_MEMORY_CONTINUE         60  0x0000003c (const dword)  (not used)
SSD1963_WRITE_MEMORY_START            44  0x0000002c (const dword)  (not used)
STAnsi                                22  0x00000016 (const dword)  (usage 3)
STBGColor                             16  0x00000010 (const dword)  (usage 6)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STFGColor                             14  0x0000000e (const dword)  (usage 3)
STFontAttribs                         18  0x00000012 (const dword)  (usage 3)
STForm                                24  0x00000018 (const dword)  (usage 3)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
str_Cat                             -278  0xfffffeea (PmmC func) args[2] r=1  (not used)
str_CatN                            -279  0xfffffee9 (PmmC func) args[3] r=1  (not used)
str_Copy                            -287  0xfffffee1 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -288  0xfffffee0 (PmmC func) args[3] r=1  (not used)
str_Find                            -274  0xfffffeee (PmmC func) args[2] r=1  (not used)
str_FindI                           -275  0xfffffeed (PmmC func) args[2] r=1  (not used)
str_GetByte                         -268  0xfffffef4 (PmmC func) args[1] r=1  (not used)
str_GetC                            -267  0xfffffef5 (PmmC func) args[2] r=1  (not used)
str_GetD                            -264  0xfffffef8 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -266  0xfffffef6 (PmmC func) args[2] r=1  (not used)
str_GetW                            -265  0xfffffef7 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -269  0xfffffef3 (PmmC func) args[1] r=1  (not used)
str_Length                          -276  0xfffffeec (PmmC func) args[1] r=1  (not used)
str_Match                           -272  0xfffffef0 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -273  0xfffffeef (PmmC func) args[2] r=1  (not used)
str_Printf                          -277  0xfffffeeb (PmmC func) args[2] r=1  (not used)
str_Ptr                             -263  0xfffffef9 (PmmC func) args[1] r=1  (not used)
str_PutByte                         -270  0xfffffef2 (PmmC func) args[2] r=0  (not used)
str_PutWord                         -271  0xfffffef1 (PmmC func) args[2] r=0  (not used)
strheight                           -161  0xffffff5f (PmmC func) args[0] r=1  (not used)
Strings0Count                          1  0x00000001 (const dword)  (not used)
Strings0Size                          11  0x0000000b (const dword)  (usage 3)
Strings0StartH                         0  0x00000000 (const dword)  (usage 3)
Strings0StartL                      1024  0x00000400 (const dword)  (usage 3)
Strings1Count                          1  0x00000001 (const dword)  (not used)
Strings1Size                          30  0x0000001e (const dword)  (usage 3)
Strings1StartH                         0  0x00000000 (const dword)  (usage 3)
Strings1StartL                       512  0x00000200 (const dword)  (usage 3)
Strings2Count                          1  0x00000001 (const dword)  (not used)
Strings2Size                          35  0x00000023 (const dword)  (usage 3)
Strings2StartH                         0  0x00000000 (const dword)  (usage 3)
Strings2StartL                         0  0x00000000 (const dword)  (usage 3)
Strings3Count                          1  0x00000001 (const dword)  (not used)
Strings3Size                          22  0x00000016 (const dword)  (usage 3)
Strings3StartH                         0  0x00000000 (const dword)  (usage 3)
Strings3StartL                      3072  0x00000c00 (const dword)  (usage 3)
Strings4Count                          1  0x00000001 (const dword)  (not used)
Strings4Size                          24  0x00000018 (const dword)  (usage 3)
Strings4StartH                         0  0x00000000 (const dword)  (usage 3)
Strings4StartL                      3584  0x00000e00 (const dword)  (usage 3)
Strings5Count                          1  0x00000001 (const dword)  (not used)
Strings5Size                          20  0x00000014 (const dword)  (usage 3)
Strings5StartH                         0  0x00000000 (const dword)  (usage 3)
Strings5StartL                      4096  0x00001000 (const dword)  (usage 3)
Strings6Count                          1  0x00000001 (const dword)  (not used)
Strings6Size                          17  0x00000011 (const dword)  (usage 3)
Strings6StartH                         0  0x00000000 (const dword)  (usage 3)
Strings6StartL                      2560  0x00000a00 (const dword)  (usage 3)
Strings7Count                          1  0x00000001 (const dword)  (not used)
Strings7Size                          12  0x0000000c (const dword)  (usage 3)
Strings7StartH                         0  0x00000000 (const dword)  (usage 3)
Strings7StartL                      1536  0x00000600 (const dword)  (usage 3)
Strings8Count                          1  0x00000001 (const dword)  (not used)
Strings8Size                          13  0x0000000d (const dword)  (usage 3)
Strings8StartH                         0  0x00000000 (const dword)  (usage 3)
Strings8StartL                      4608  0x00001200 (const dword)  (usage 3)
Strings9Count                          1  0x00000001 (const dword)  (not used)
Strings9Size                          11  0x0000000b (const dword)  (usage 3)
Strings9StartH                         0  0x00000000 (const dword)  (usage 3)
Strings9StartL                      2048  0x00000800 (const dword)  (usage 3)
stringsCV                             58  0x0000003a (mem) word[10] (global)  (usage 27)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                            -160  0xffffff60 (PmmC func) args[1] r=1  (not used)
STSize                                 4  0x00000004 (const dword)  (usage 3)
STStartH                               0  0x00000000 (const dword)  (usage 3)
STStartL                               2  0x00000002 (const dword)  (usage 3)
STTransparent                         20  0x00000014 (const dword)  (usage 3)
STx1                                   6  0x00000006 (const dword)  (usage 12)
STx2                                  10  0x0000000a (const dword)  (usage 9)
STy1                                   8  0x00000008 (const dword)  (usage 12)
STy2                                  12  0x0000000c (const dword)  (usage 9)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
SWAP                                 -16  0xfffffff0 (PmmC func) args[2] r=0  (usage 3)
sys_DeepSleep                       -295  0xfffffed9 (PmmC func) args[1] r=1  (not used)
sys_EventQueue                      -194  0xffffff3e (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -195  0xffffff3d (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -196  0xffffff3c (PmmC func) args[0] r=0  (usage 3)
sys_GetTimer                        -192  0xffffff40 (PmmC func) args[1] r=1  (not used)
sys_SetTimer                        -191  0xffffff41 (PmmC func) args[2] r=0  (not used)
sys_SetTimerEvent                   -193  0xffffff3f (PmmC func) args[2] r=1  (not used)
sys_Sleep                           -197  0xffffff3b (PmmC func) args[1] r=1  (not used)
sys_StoreTouchCalibration           -280  0xfffffee8 (PmmC func) args[0] r=1  (not used)
sys_T                               -189  0xffffff43 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -190  0xffffff42 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (not used)
t4Dbutton                             30  0x0000001e (const dword)  (usage 102)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
tAngularmeter                          7  0x00000007 (const dword)  (usage 3)
tAniButton                            31  0x0000001f (const dword)  (usage 9)
tColorPicker                          32  0x00000020 (const dword)  (usage 3)
tCoolgauge                             8  0x00000008 (const dword)  (usage 3)
tCustomdigits                          9  0x00000009 (const dword)  (usage 6)
tDipSwitch                             0  0x00000000 (const dword)  (usage 3)
TEAL                                1040  0x00000410 (const dword)  (not used)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
tForm                                 10  0x0000000a (const dword)  (usage 15)
tGauge                                11  0x0000000b (const dword)  (usage 3)
tGSlider                               4  0x00000004 (const dword)  (usage 21)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
tImage                                12  0x0000000c (const dword)  (usage 3)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (not used)
TIMER2                                 2  0x00000002 (const dword)  (not used)
TIMER3                                 3  0x00000003 (const dword)  (not used)
TIMER4                                 4  0x00000004 (const dword)  (not used)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (not used)
tKeyboard                             13  0x0000000d (const dword)  (usage 3)
tKnob                                  1  0x00000001 (const dword)  (usage 9)
tLed                                  14  0x0000000e (const dword)  (usage 3)
tLeddigits                            15  0x0000000f (const dword)  (usage 12)
tMeter                                16  0x00000010 (const dword)  (usage 3)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
TMul                               10618  0x0000297a (User func) args[3] r=0  (usage 9)
tnew                                4368  0x00001110 (mem) word[4] (global)  (usage 21)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (not used)
told                                4360  0x00001108 (mem) word[4] (global)  (usage 21)
tolower                             -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -199  0xffffff39 (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_DRIVE                           78  0x0000004e (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -201  0xffffff37 (PmmC func) args[1] r=1  (usage 9)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 3)
TOUCH_GETY                             2  0x00000002 (const dword)  (usage 3)
TOUCH_MOVING                           3  0x00000003 (const dword)  (usage 3)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (usage 9)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (usage 18)
touch_Set                           -200  0xffffff38 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 3)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
toupper                             -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
tPinInput                             29  0x0000001d (const dword)  (usage 6)
tPinOutput                            28  0x0000001c (const dword)  (usage 6)
translate                             -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (usage 3)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
tRockerSwitch                          2  0x00000002 (const dword)  (usage 3)
tRotarySwitch                          3  0x00000003 (const dword)  (usage 3)
tScope                                25  0x00000019 (const dword)  (usage 3)
tSounds                               22  0x00000016 (const dword)  (usage 12)
tSpectrum                             24  0x00000018 (const dword)  (usage 3)
TState                              4110  0x0000100e (mem) word (global)  (usage 24)
tStaticText                           21  0x00000015 (const dword)  (usage 3)
tStrings                              17  0x00000011 (const dword)  (usage 18)
tTank                                 26  0x0000001a (const dword)  (usage 3)
tThermometer                          18  0x00000012 (const dword)  (usage 3)
tTimer                                23  0x00000017 (const dword)  (usage 6)
tTrackbar                              5  0x00000005 (const dword)  (usage 6)
TurnOffButtons                      8325  0x00002085 (User func) args[1] r=0  (usage 6)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
tUserButton                           33  0x00000021 (const dword)  (usage 9)
tUserImages                           27  0x0000001b (const dword)  (usage 3)
tUserled                              19  0x00000013 (const dword)  (usage 3)
tVideo                                20  0x00000014 (const dword)  (usage 3)
tWinButton                             6  0x00000006 (const dword)  (usage 81)
txt_Attributes                       -38  0xffffffda (PmmC func) args[1] r=1  (usage 3)
txt_BGcolour                         -26  0xffffffe6 (PmmC func) args[1] r=1  (usage 3)
txt_Bold                             -34  0xffffffde (PmmC func) args[1] r=1  (not used)
txt_Delay                            -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -25  0xffffffe7 (PmmC func) args[1] r=1  (usage 3)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontID                           -27  0xffffffe5 (PmmC func) args[1] r=1  (usage 3)
txt_Height                           -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Inverse                          -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
txt_Italic                           -35  0xffffffdd (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -23  0xffffffe9 (PmmC func) args[2] r=0  (not used)
txt_Opacity                          -33  0xffffffdf (PmmC func) args[1] r=1  (usage 3)
txt_Set                              -24  0xffffffe8 (PmmC func) args[2] r=0  (not used)
txt_Underline                        -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
txt_Width                            -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_Wrap                             -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
uadd_3232                           -290  0xfffffede (PmmC func) args[3] r=1  (usage 3)
ucmp_3232                           -292  0xfffffedc (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
uLCD_43PT_GFX2                         0  0x00000000 (const ??? 0)  (not used)
umul_1616                           -289  0xfffffedf (PmmC func) args[3] r=1  (usage 12)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                        -281  0xfffffee7 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
UpdateObjects                       6694  0x00001a26 (User func) args[1] r=0  (usage 9)
USER_INITIALIZED_DISPLAY              32  0x00000020 (const dword)  (not used)
usub_3232                           -291  0xfffffedd (PmmC func) args[3] r=1  (not used)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
WHEAT                              63222  0x0000f6f6 (const dword)  (not used)
WHITE                              65535  0x0000ffff (const dword)  (not used)
WHITESMOKE                         63422  0x0000f7be (const dword)  (not used)
WRITE_CONTRAST                         4  0x00000004 (const dword)  (usage 3)
WRITE_OBJ                              1  0x00000001 (const dword)  (usage 3)
WRITE_PAGE                            35  0x00000023 (const dword)  (not used)
WRITE_STR                              2  0x00000002 (const dword)  (usage 3)
WRITE_STRU                             3  0x00000003 (const dword)  (usage 3)
WriteCmd                               0  0x00000000 (const dword)  (not used)
WriteObject                         8511  0x0000213f (User func) args[3] r=0  (usage 30)
x                                   4104  0x00001008 (mem) word (global)  (usage 18)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
XYposToDegree                      11189  0x00002bb5 (User func) args[2] r=0  (usage 3)
y                                   4106  0x0000100a (mem) word (global)  (usage 16)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (usage 3)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
